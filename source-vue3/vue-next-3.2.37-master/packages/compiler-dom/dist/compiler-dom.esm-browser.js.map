{"version":3,"file":"compiler-dom.esm-browser.js","sources":["../../shared/src/makeMap.ts","../../shared/src/patchFlags.ts","../../shared/src/slotFlags.ts","../../shared/src/codeframe.ts","../../shared/src/normalizeProp.ts","../../shared/src/domTagConfig.ts","../../shared/src/index.ts","../../compiler-core/src/errors.ts","../../compiler-core/src/runtimeHelpers.ts","../../compiler-core/src/ast.ts","../../compiler-core/src/utils.ts","../../compiler-core/src/compat/compatConfig.ts","../../compiler-core/src/parse.ts","../../compiler-core/src/transforms/hoistStatic.ts","../../compiler-core/src/transform.ts","../../compiler-core/src/codegen.ts","../../compiler-core/src/babelUtils.ts","../../compiler-core/src/validateExpression.ts","../../compiler-core/src/transforms/transformExpression.ts","../../compiler-core/src/transforms/vIf.ts","../../compiler-core/src/transforms/vFor.ts","../../compiler-core/src/transforms/vSlot.ts","../../compiler-core/src/transforms/transformElement.ts","../../compiler-core/src/transforms/transformSlotOutlet.ts","../../compiler-core/src/transforms/vOn.ts","../../compiler-core/src/transforms/vBind.ts","../../compiler-core/src/transforms/transformText.ts","../../compiler-core/src/transforms/vOnce.ts","../../compiler-core/src/transforms/vModel.ts","../../compiler-core/src/compat/transformFilter.ts","../../compiler-core/src/transforms/vMemo.ts","../../compiler-core/src/compile.ts","../../compiler-core/src/transforms/noopDirectiveTransform.ts","../src/runtimeHelpers.ts","../src/decodeHtmlBrowser.ts","../src/parserOptions.ts","../src/transforms/transformStyle.ts","../src/errors.ts","../src/transforms/vHtml.ts","../src/transforms/vText.ts","../src/transforms/vModel.ts","../src/transforms/vOn.ts","../src/transforms/vShow.ts","../src/transforms/Transition.ts","../src/transforms/ignoreSideEffectTags.ts","../src/index.ts"],"sourcesContent":["/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","/**\n * Patch flags are optimization hints generated by the compiler.\n * when a block with dynamicChildren is encountered during diff, the algorithm\n * enters \"optimized mode\". In this mode, we know that the vdom is produced by\n * a render function generated by the compiler, so the algorithm only needs to\n * handle updates explicitly marked by these patch flags.\n *\n * Patch flags can be combined using the | bitwise operator and can be checked\n * using the & operator, e.g.\n *\n * ```js\n * const flag = TEXT | CLASS\n * if (flag & TEXT) { ... }\n * ```\n *\n * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the\n * flags are handled during diff.\n */\nexport const enum PatchFlags {\n  /**\n   * Indicates an element with dynamic textContent (children fast path)\n   */\n  TEXT = 1,\n\n  /**\n   * Indicates an element with dynamic class binding.\n   */\n  CLASS = 1 << 1,\n\n  /**\n   * Indicates an element with dynamic style\n   * The compiler pre-compiles static string styles into static objects\n   * + detects and hoists inline static objects\n   * e.g. `style=\"color: red\"` and `:style=\"{ color: 'red' }\"` both get hoisted\n   * as:\n   * ```js\n   * const style = { color: 'red' }\n   * render() { return e('div', { style }) }\n   * ```\n   */\n  STYLE = 1 << 2,\n\n  /**\n   * Indicates an element that has non-class/style dynamic props.\n   * Can also be on a component that has any dynamic props (includes\n   * class/style). when this flag is present, the vnode also has a dynamicProps\n   * array that contains the keys of the props that may change so the runtime\n   * can diff them faster (without having to worry about removed props)\n   */\n  PROPS = 1 << 3,\n\n  /**\n   * Indicates an element with props with dynamic keys. When keys change, a full\n   * diff is always needed to remove the old key. This flag is mutually\n   * exclusive with CLASS, STYLE and PROPS.\n   */\n  FULL_PROPS = 1 << 4,\n\n  /**\n   * Indicates an element with event listeners (which need to be attached\n   * during hydration)\n   */\n  HYDRATE_EVENTS = 1 << 5,\n\n  /**\n   * Indicates a fragment whose children order doesn't change.\n   */\n  STABLE_FRAGMENT = 1 << 6,\n\n  /**\n   * Indicates a fragment with keyed or partially keyed children\n   */\n  KEYED_FRAGMENT = 1 << 7,\n\n  /**\n   * Indicates a fragment with unkeyed children.\n   */\n  UNKEYED_FRAGMENT = 1 << 8,\n\n  /**\n   * Indicates an element that only needs non-props patching, e.g. ref or\n   * directives (onVnodeXXX hooks). since every patched vnode checks for refs\n   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block\n   * will track it.\n   */\n  NEED_PATCH = 1 << 9,\n\n  /**\n   * Indicates a component with dynamic slots (e.g. slot that references a v-for\n   * iterated value, or dynamic slot names).\n   * Components with this flag are always force updated.\n   */\n  DYNAMIC_SLOTS = 1 << 10,\n\n  /**\n   * Indicates a fragment that was created only because the user has placed\n   * comments at the root level of a template. This is a dev-only flag since\n   * comments are stripped in production.\n   */\n  DEV_ROOT_FRAGMENT = 1 << 11,\n\n  /**\n   * SPECIAL FLAGS -------------------------------------------------------------\n   * Special flags are negative integers. They are never matched against using\n   * bitwise operators (bitwise matching should only happen in branches where\n   * patchFlag > 0), and are mutually exclusive. When checking for a special\n   * flag, simply check patchFlag === FLAG.\n   */\n\n  /**\n   * Indicates a hoisted static vnode. This is a hint for hydration to skip\n   * the entire sub tree since static content never needs to be updated.\n   */\n  HOISTED = -1,\n  /**\n   * A special flag that indicates that the diffing algorithm should bail out\n   * of optimized mode. For example, on block fragments created by renderSlot()\n   * when encountering non-compiler generated slots (i.e. manually written\n   * render functions, which should always be fully diffed)\n   * OR manually cloneVNodes\n   */\n  BAIL = -2\n}\n\n/**\n * dev only flag -> name mapping\n */\nexport const PatchFlagNames = {\n  [PatchFlags.TEXT]: `TEXT`,\n  [PatchFlags.CLASS]: `CLASS`,\n  [PatchFlags.STYLE]: `STYLE`,\n  [PatchFlags.PROPS]: `PROPS`,\n  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,\n  [PatchFlags.HYDRATE_EVENTS]: `HYDRATE_EVENTS`,\n  [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`,\n  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,\n  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,\n  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,\n  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,\n  [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`,\n  [PatchFlags.HOISTED]: `HOISTED`,\n  [PatchFlags.BAIL]: `BAIL`\n}\n","export const enum SlotFlags {\n  /**\n   * Stable slots that only reference slot props or context state. The slot\n   * can fully capture its own dependencies so when passed down the parent won't\n   * need to force the child to update.\n   */\n  STABLE = 1,\n  /**\n   * Slots that reference scope variables (v-for or an outer slot prop), or\n   * has conditional structure (v-if, v-for). The parent will need to force\n   * the child to update because the slot does not fully capture its dependencies.\n   */\n  DYNAMIC = 2,\n  /**\n   * `<slot/>` being forwarded into a child component. Whether the parent needs\n   * to update the child is dependent on what kind of slots the parent itself\n   * received. This has to be refined at runtime, when the child's vnode\n   * is being created (in `normalizeChildren`)\n   */\n  FORWARDED = 3\n}\n\n/**\n * Dev only\n */\nexport const slotFlagsText = {\n  [SlotFlags.STABLE]: 'STABLE',\n  [SlotFlags.DYNAMIC]: 'DYNAMIC',\n  [SlotFlags.FORWARDED]: 'FORWARDED'\n}\n","const range: number = 2\n\nexport function generateCodeFrame(\n  source: string,\n  start = 0,\n  end = source.length\n): string {\n  // Split the content into individual lines but capture the newline sequence\n  // that separated each line. This is important because the actual sequence is\n  // needed to properly take into account the full line length for offset\n  // comparison\n  let lines = source.split(/(\\r?\\n)/)\n\n  // Separate the lines and newline sequences into separate arrays for easier referencing\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1)\n  lines = lines.filter((_, idx) => idx % 2 === 0)\n\n  let count = 0\n  const res: string[] = []\n  for (let i = 0; i < lines.length; i++) {\n    count +=\n      lines[i].length +\n      ((newlineSequences[i] && newlineSequences[i].length) || 0)\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue\n        const line = j + 1\n        res.push(\n          `${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${\n            lines[j]\n          }`\n        )\n        const lineLength = lines[j].length\n        const newLineSeqLength =\n          (newlineSequences[j] && newlineSequences[j].length) || 0\n\n        if (j === i) {\n          // push underline\n          const pad = start - (count - (lineLength + newLineSeqLength))\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          )\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1)\n            res.push(`   |  ` + '^'.repeat(length))\n          }\n\n          count += lineLength + newLineSeqLength\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n","import { isArray, isString, isObject, hyphenate } from './'\nimport { isNoUnitNumericStyleProp } from './domAttrConfig'\n\nexport type NormalizedStyle = Record<string, string | number>\n\nexport function normalizeStyle(\n  value: unknown\n): NormalizedStyle | string | undefined {\n  if (isArray(value)) {\n    const res: NormalizedStyle = {}\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      const normalized = isString(item)\n        ? parseStringStyle(item)\n        : (normalizeStyle(item) as NormalizedStyle)\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key]\n        }\n      }\n    }\n    return res\n  } else if (isString(value)) {\n    return value\n  } else if (isObject(value)) {\n    return value\n  }\n}\n\nconst listDelimiterRE = /;(?![^(]*\\))/g\nconst propertyDelimiterRE = /:(.+)/\n\nexport function parseStringStyle(cssText: string): NormalizedStyle {\n  const ret: NormalizedStyle = {}\n  cssText.split(listDelimiterRE).forEach(item => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE)\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())\n    }\n  })\n  return ret\n}\n\nexport function stringifyStyle(\n  styles: NormalizedStyle | string | undefined\n): string {\n  let ret = ''\n  if (!styles || isString(styles)) {\n    return ret\n  }\n  for (const key in styles) {\n    const value = styles[key]\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)\n    if (\n      isString(value) ||\n      (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))\n    ) {\n      // only render valid values\n      ret += `${normalizedKey}:${value};`\n    }\n  }\n  return ret\n}\n\nexport function normalizeClass(value: unknown): string {\n  let res = ''\n  if (isString(value)) {\n    res = value\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i])\n      if (normalized) {\n        res += normalized + ' '\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + ' '\n      }\n    }\n  }\n  return res.trim()\n}\n\nexport function normalizeProps(props: Record<string, any> | null) {\n  if (!props) return null\n  let { class: klass, style } = props\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass)\n  }\n  if (style) {\n    props.style = normalizeStyle(style)\n  }\n  return props\n}\n","// These tag configs are shared between compiler-dom and runtime-dom, so they\n// must be extracted in shared to avoid creating a dependency between the two.\nimport { makeMap } from './makeMap'\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS =\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n  'option,output,progress,select,textarea,details,dialog,menu,' +\n  'summary,template,blockquote,iframe,tfoot'\n\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS =\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n  'text,textPath,title,tspan,unknown,use,view'\n\nconst VOID_TAGS =\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\n\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\n */\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\n */\nexport const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\n */\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\n","import { makeMap } from './makeMap'\n\nexport { makeMap }\nexport * from './patchFlags'\nexport * from './shapeFlags'\nexport * from './slotFlags'\nexport * from './globalsWhitelist'\nexport * from './codeframe'\nexport * from './normalizeProp'\nexport * from './domTagConfig'\nexport * from './domAttrConfig'\nexport * from './escapeHtml'\nexport * from './looseEqual'\nexport * from './toDisplayString'\nexport * from './typeUtils'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nconst onRE = /^on[^a-z]/\nexport const isOn = (key: string) => onRE.test(key)\n\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\n\nexport const extend = Object.assign\n\nexport const remove = <T>(arr: T[], el: T) => {\n  const i = arr.indexOf(el)\n  if (i > -1) {\n    arr.splice(i, 1)\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isMap = (val: unknown): val is Map<any, any> =>\n  toTypeString(val) === '[object Map]'\nexport const isSet = (val: unknown): val is Set<any> =>\n  toTypeString(val) === '[object Set]'\n\nexport const isDate = (val: unknown): val is Date => toTypeString(val) === '[object Date]'\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const toRawType = (value: unknown): string => {\n  // extract \"RawType\" from strings like \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isIntegerKey = (key: unknown) =>\n  isString(key) &&\n  key !== 'NaN' &&\n  key[0] !== '-' &&\n  '' + parseInt(key, 10) === key\n\nexport const isReservedProp = /*#__PURE__*/ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  ',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\n)\n\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'\n)\n\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\n  const cache: Record<string, string> = Object.create(null)\n  return ((str: string) => {\n    const hit = cache[str]\n    return hit || (cache[str] = fn(str))\n  }) as any\n}\n\nconst camelizeRE = /-(\\w)/g\n/**\n * @private\n */\nexport const camelize = cacheStringFunction((str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n})\n\nconst hyphenateRE = /\\B([A-Z])/g\n/**\n * @private\n */\nexport const hyphenate = cacheStringFunction((str: string) =>\n  str.replace(hyphenateRE, '-$1').toLowerCase()\n)\n\n/**\n * @private\n */\nexport const capitalize = cacheStringFunction(\n  (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\n)\n\n/**\n * @private\n */\nexport const toHandlerKey = cacheStringFunction((str: string) =>\n  str ? `on${capitalize(str)}` : ``\n)\n\n// compare whether a value has changed, accounting for NaN.\nexport const hasChanged = (value: any, oldValue: any): boolean =>\n  !Object.is(value, oldValue)\n\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg)\n  }\n}\n\nexport const def = (obj: object, key: string | symbol, value: any) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  })\n}\n\nexport const toNumber = (val: any): any => {\n  const n = parseFloat(val)\n  return isNaN(n) ? val : n\n}\n\nlet _globalThis: any\nexport const getGlobalThis = (): any => {\n  return (\n    _globalThis ||\n    (_globalThis =\n      typeof globalThis !== 'undefined'\n        ? globalThis\n        : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n        ? window\n        : typeof global !== 'undefined'\n        ? global\n        : {})\n  )\n}\n\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\n\nexport function genPropsAccessExp(name: string) {\n  return identRE.test(name)\n    ? `__props.${name}`\n    : `__props[${JSON.stringify(name)}]`\n}\n","import { SourceLocation } from './ast'\n\nexport interface CompilerError extends SyntaxError {\n  code: number | string\n  loc?: SourceLocation\n}\n\nexport interface CoreCompilerError extends CompilerError {\n  code: ErrorCodes\n}\n\nexport function defaultOnError(error: CompilerError) {\n  throw error\n}\n\nexport function defaultOnWarn(msg: CompilerError) {\n  __DEV__ && console.warn(`[Vue warn] ${msg.message}`)\n}\n\ntype InferCompilerError<T> = T extends ErrorCodes\n  ? CoreCompilerError\n  : CompilerError\n\nexport function createCompilerError<T extends number>(\n  code: T,\n  loc?: SourceLocation,\n  messages?: { [code: number]: string },\n  additionalMessage?: string\n): InferCompilerError<T> {\n  const msg =\n    __DEV__ || !__BROWSER__\n      ? (messages || errorMessages)[code] + (additionalMessage || ``)\n      : code\n  const error = new SyntaxError(String(msg)) as InferCompilerError<T>\n  error.code = code\n  error.loc = loc\n  return error\n}\n\nexport const enum ErrorCodes {\n  // parse errors\n  ABRUPT_CLOSING_OF_EMPTY_COMMENT,\n  CDATA_IN_HTML_CONTENT,\n  DUPLICATE_ATTRIBUTE,\n  END_TAG_WITH_ATTRIBUTES,\n  END_TAG_WITH_TRAILING_SOLIDUS,\n  EOF_BEFORE_TAG_NAME,\n  EOF_IN_CDATA,\n  EOF_IN_COMMENT,\n  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,\n  EOF_IN_TAG,\n  INCORRECTLY_CLOSED_COMMENT,\n  INCORRECTLY_OPENED_COMMENT,\n  INVALID_FIRST_CHARACTER_OF_TAG_NAME,\n  MISSING_ATTRIBUTE_VALUE,\n  MISSING_END_TAG_NAME,\n  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES,\n  NESTED_COMMENT,\n  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\n  UNEXPECTED_NULL_CHARACTER,\n  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n  UNEXPECTED_SOLIDUS_IN_TAG,\n\n  // Vue-specific parse errors\n  X_INVALID_END_TAG,\n  X_MISSING_END_TAG,\n  X_MISSING_INTERPOLATION_END,\n  X_MISSING_DIRECTIVE_NAME,\n  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\n\n  // transform errors\n  X_V_IF_NO_EXPRESSION,\n  X_V_IF_SAME_KEY,\n  X_V_ELSE_NO_ADJACENT_IF,\n  X_V_FOR_NO_EXPRESSION,\n  X_V_FOR_MALFORMED_EXPRESSION,\n  X_V_FOR_TEMPLATE_KEY_PLACEMENT,\n  X_V_BIND_NO_EXPRESSION,\n  X_V_ON_NO_EXPRESSION,\n  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n  X_V_SLOT_MIXED_SLOT_USAGE,\n  X_V_SLOT_DUPLICATE_SLOT_NAMES,\n  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\n  X_V_SLOT_MISPLACED,\n  X_V_MODEL_NO_EXPRESSION,\n  X_V_MODEL_MALFORMED_EXPRESSION,\n  X_V_MODEL_ON_SCOPE_VARIABLE,\n  X_INVALID_EXPRESSION,\n  X_KEEP_ALIVE_INVALID_CHILDREN,\n\n  // generic errors\n  X_PREFIX_ID_NOT_SUPPORTED,\n  X_MODULE_MODE_NOT_SUPPORTED,\n  X_CACHE_HANDLER_NOT_SUPPORTED,\n  X_SCOPE_ID_NOT_SUPPORTED,\n\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__\n}\n\nexport const errorMessages: Record<ErrorCodes, string> = {\n  // parse errors\n  [ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT]: 'Illegal comment.',\n  [ErrorCodes.CDATA_IN_HTML_CONTENT]:\n    'CDATA section is allowed only in XML context.',\n  [ErrorCodes.DUPLICATE_ATTRIBUTE]: 'Duplicate attribute.',\n  [ErrorCodes.END_TAG_WITH_ATTRIBUTES]: 'End tag cannot have attributes.',\n  [ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS]: \"Illegal '/' in tags.\",\n  [ErrorCodes.EOF_BEFORE_TAG_NAME]: 'Unexpected EOF in tag.',\n  [ErrorCodes.EOF_IN_CDATA]: 'Unexpected EOF in CDATA section.',\n  [ErrorCodes.EOF_IN_COMMENT]: 'Unexpected EOF in comment.',\n  [ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT]:\n    'Unexpected EOF in script.',\n  [ErrorCodes.EOF_IN_TAG]: 'Unexpected EOF in tag.',\n  [ErrorCodes.INCORRECTLY_CLOSED_COMMENT]: 'Incorrectly closed comment.',\n  [ErrorCodes.INCORRECTLY_OPENED_COMMENT]: 'Incorrectly opened comment.',\n  [ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME]:\n    \"Illegal tag name. Use '&lt;' to print '<'.\",\n  [ErrorCodes.MISSING_ATTRIBUTE_VALUE]: 'Attribute value was expected.',\n  [ErrorCodes.MISSING_END_TAG_NAME]: 'End tag name was expected.',\n  [ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES]:\n    'Whitespace was expected.',\n  [ErrorCodes.NESTED_COMMENT]: \"Unexpected '<!--' in comment.\",\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME]:\n    'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE]:\n    'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\n  [ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME]:\n    \"Attribute name cannot start with '='.\",\n  [ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME]:\n    \"'<?' is allowed only in XML context.\",\n  [ErrorCodes.UNEXPECTED_NULL_CHARACTER]: `Unexpected null character.`,\n  [ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG]: \"Illegal '/' in tags.\",\n\n  // Vue-specific parse errors\n  [ErrorCodes.X_INVALID_END_TAG]: 'Invalid end tag.',\n  [ErrorCodes.X_MISSING_END_TAG]: 'Element is missing end tag.',\n  [ErrorCodes.X_MISSING_INTERPOLATION_END]:\n    'Interpolation end sign was not found.',\n  [ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END]:\n    'End bracket for dynamic directive argument was not found. ' +\n    'Note that dynamic directive argument cannot contain spaces.',\n  [ErrorCodes.X_MISSING_DIRECTIVE_NAME]: 'Legal directive name was expected.',\n\n  // transform errors\n  [ErrorCodes.X_V_IF_NO_EXPRESSION]: `v-if/v-else-if is missing expression.`,\n  [ErrorCodes.X_V_IF_SAME_KEY]: `v-if/else branches must use unique keys.`,\n  [ErrorCodes.X_V_ELSE_NO_ADJACENT_IF]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\n  [ErrorCodes.X_V_FOR_NO_EXPRESSION]: `v-for is missing expression.`,\n  [ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION]: `v-for has invalid expression.`,\n  [ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT]: `<template v-for> key should be placed on the <template> tag.`,\n  [ErrorCodes.X_V_BIND_NO_EXPRESSION]: `v-bind is missing expression.`,\n  [ErrorCodes.X_V_ON_NO_EXPRESSION]: `v-on is missing expression.`,\n  [ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET]: `Unexpected custom directive on <slot> outlet.`,\n  [ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE]:\n    `Mixed v-slot usage on both the component and nested <template>.` +\n    `When there are multiple named slots, all slots should use <template> ` +\n    `syntax to avoid scope ambiguity.`,\n  [ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES]: `Duplicate slot names found. `,\n  [ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN]:\n    `Extraneous children found when component already has explicitly named ` +\n    `default slot. These children will be ignored.`,\n  [ErrorCodes.X_V_SLOT_MISPLACED]: `v-slot can only be used on components or <template> tags.`,\n  [ErrorCodes.X_V_MODEL_NO_EXPRESSION]: `v-model is missing expression.`,\n  [ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION]: `v-model value must be a valid JavaScript member expression.`,\n  [ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n  [ErrorCodes.X_INVALID_EXPRESSION]: `Error parsing JavaScript expression: `,\n  [ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN]: `<KeepAlive> expects exactly one child component.`,\n\n  // generic errors\n  [ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n  [ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED]: `ES module mode is not supported in this build of compiler.`,\n  [ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\n  [ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED]: `\"scopeId\" option is only supported in module mode.`,\n\n  // just to fulfill types\n  [ErrorCodes.__EXTEND_POINT__]: ``\n}\n","export const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)\nexport const TELEPORT = Symbol(__DEV__ ? `Teleport` : ``)\nexport const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)\nexport const KEEP_ALIVE = Symbol(__DEV__ ? `KeepAlive` : ``)\nexport const BASE_TRANSITION = Symbol(__DEV__ ? `BaseTransition` : ``)\nexport const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)\nexport const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)\nexport const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)\nexport const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)\nexport const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)\nexport const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)\nexport const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``)\nexport const CREATE_STATIC = Symbol(__DEV__ ? `createStaticVNode` : ``)\nexport const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)\nexport const RESOLVE_DYNAMIC_COMPONENT = Symbol(\n  __DEV__ ? `resolveDynamicComponent` : ``\n)\nexport const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)\nexport const RESOLVE_FILTER = Symbol(__DEV__ ? `resolveFilter` : ``)\nexport const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)\nexport const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)\nexport const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)\nexport const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)\nexport const TO_DISPLAY_STRING = Symbol(__DEV__ ? `toDisplayString` : ``)\nexport const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)\nexport const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)\nexport const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)\nexport const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)\nexport const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)\nexport const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)\nexport const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)\nexport const CAPITALIZE = Symbol(__DEV__ ? `capitalize` : ``)\nexport const TO_HANDLER_KEY = Symbol(__DEV__ ? `toHandlerKey` : ``)\nexport const SET_BLOCK_TRACKING = Symbol(__DEV__ ? `setBlockTracking` : ``)\nexport const PUSH_SCOPE_ID = Symbol(__DEV__ ? `pushScopeId` : ``)\nexport const POP_SCOPE_ID = Symbol(__DEV__ ? `popScopeId` : ``)\nexport const WITH_CTX = Symbol(__DEV__ ? `withCtx` : ``)\nexport const UNREF = Symbol(__DEV__ ? `unref` : ``)\nexport const IS_REF = Symbol(__DEV__ ? `isRef` : ``)\nexport const WITH_MEMO = Symbol(__DEV__ ? `withMemo` : ``)\nexport const IS_MEMO_SAME = Symbol(__DEV__ ? `isMemoSame` : ``)\n\n// Name mapping for runtime helpers that need to be imported from 'vue' in\n// generated code. Make sure these are correctly exported in the runtime!\n// Using `any` here because TS doesn't allow symbols as index type.\nexport const helperNameMap: any = {\n  [FRAGMENT]: `Fragment`,\n  [TELEPORT]: `Teleport`,\n  [SUSPENSE]: `Suspense`,\n  [KEEP_ALIVE]: `KeepAlive`,\n  [BASE_TRANSITION]: `BaseTransition`,\n  [OPEN_BLOCK]: `openBlock`,\n  [CREATE_BLOCK]: `createBlock`,\n  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\n  [CREATE_VNODE]: `createVNode`,\n  [CREATE_ELEMENT_VNODE]: `createElementVNode`,\n  [CREATE_COMMENT]: `createCommentVNode`,\n  [CREATE_TEXT]: `createTextVNode`,\n  [CREATE_STATIC]: `createStaticVNode`,\n  [RESOLVE_COMPONENT]: `resolveComponent`,\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\n  [RESOLVE_FILTER]: `resolveFilter`,\n  [WITH_DIRECTIVES]: `withDirectives`,\n  [RENDER_LIST]: `renderList`,\n  [RENDER_SLOT]: `renderSlot`,\n  [CREATE_SLOTS]: `createSlots`,\n  [TO_DISPLAY_STRING]: `toDisplayString`,\n  [MERGE_PROPS]: `mergeProps`,\n  [NORMALIZE_CLASS]: `normalizeClass`,\n  [NORMALIZE_STYLE]: `normalizeStyle`,\n  [NORMALIZE_PROPS]: `normalizeProps`,\n  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\n  [TO_HANDLERS]: `toHandlers`,\n  [CAMELIZE]: `camelize`,\n  [CAPITALIZE]: `capitalize`,\n  [TO_HANDLER_KEY]: `toHandlerKey`,\n  [SET_BLOCK_TRACKING]: `setBlockTracking`,\n  [PUSH_SCOPE_ID]: `pushScopeId`,\n  [POP_SCOPE_ID]: `popScopeId`,\n  [WITH_CTX]: `withCtx`,\n  [UNREF]: `unref`,\n  [IS_REF]: `isRef`,\n  [WITH_MEMO]: `withMemo`,\n  [IS_MEMO_SAME]: `isMemoSame`\n}\n\nexport function registerRuntimeHelpers(helpers: any) {\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\n    helperNameMap[s] = helpers[s]\n  })\n}\n","import { isString } from '@vue/shared'\nimport { ForParseResult } from './transforms/vFor'\nimport {\n  RENDER_SLOT,\n  CREATE_SLOTS,\n  RENDER_LIST,\n  OPEN_BLOCK,\n  FRAGMENT,\n  WITH_DIRECTIVES,\n  WITH_MEMO\n} from './runtimeHelpers'\nimport { PropsExpression } from './transforms/transformElement'\nimport { ImportItem, TransformContext } from './transform'\nimport { getVNodeBlockHelper, getVNodeHelper } from './utils'\n\n// Vue template is a platform-agnostic superset of HTML (syntax only).\n// More namespaces like SVG and MathML are declared by platform specific\n// compilers.\nexport type Namespace = number\n\nexport const enum Namespaces {\n  HTML\n}\n\nexport const enum NodeTypes {\n  ROOT,\n  ELEMENT,\n  TEXT,\n  COMMENT,\n  SIMPLE_EXPRESSION,\n  INTERPOLATION,\n  ATTRIBUTE,\n  DIRECTIVE,\n  // containers\n  COMPOUND_EXPRESSION,\n  IF,\n  IF_BRANCH,\n  FOR,\n  TEXT_CALL,\n  // codegen\n  VNODE_CALL,\n  JS_CALL_EXPRESSION,\n  JS_OBJECT_EXPRESSION,\n  JS_PROPERTY,\n  JS_ARRAY_EXPRESSION,\n  JS_FUNCTION_EXPRESSION,\n  JS_CONDITIONAL_EXPRESSION,\n  JS_CACHE_EXPRESSION,\n\n  // ssr codegen\n  JS_BLOCK_STATEMENT,\n  JS_TEMPLATE_LITERAL,\n  JS_IF_STATEMENT,\n  JS_ASSIGNMENT_EXPRESSION,\n  JS_SEQUENCE_EXPRESSION,\n  JS_RETURN_STATEMENT\n}\n\nexport const enum ElementTypes {\n  ELEMENT,\n  COMPONENT,\n  SLOT,\n  TEMPLATE\n}\n\nexport interface Node {\n  type: NodeTypes\n  loc: SourceLocation\n}\n\n// The node's range. The `start` is inclusive and `end` is exclusive.\n// [start, end)\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source: string\n}\n\nexport interface Position {\n  offset: number // from start of file\n  line: number\n  column: number\n}\n\nexport type ParentNode = RootNode | ElementNode | IfBranchNode | ForNode\n\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\n\nexport type TemplateChildNode =\n  | ElementNode\n  | InterpolationNode\n  | CompoundExpressionNode\n  | TextNode\n  | CommentNode\n  | IfNode\n  | IfBranchNode\n  | ForNode\n  | TextCallNode\n\nexport interface RootNode extends Node {\n  type: NodeTypes.ROOT\n  children: TemplateChildNode[]\n  helpers: symbol[]\n  components: string[]\n  directives: string[]\n  hoists: (JSChildNode | null)[]\n  imports: ImportItem[]\n  cached: number\n  temps: number\n  ssrHelpers?: symbol[]\n  codegenNode?: TemplateChildNode | JSChildNode | BlockStatement\n\n  // v2 compat only\n  filters?: string[]\n}\n\nexport type ElementNode =\n  | PlainElementNode\n  | ComponentNode\n  | SlotOutletNode\n  | TemplateNode\n\nexport interface BaseElementNode extends Node {\n  type: NodeTypes.ELEMENT\n  ns: Namespace\n  tag: string\n  tagType: ElementTypes\n  isSelfClosing: boolean\n  props: Array<AttributeNode | DirectiveNode>\n  children: TemplateChildNode[]\n}\n\nexport interface PlainElementNode extends BaseElementNode {\n  tagType: ElementTypes.ELEMENT\n  codegenNode:\n    | VNodeCall\n    | SimpleExpressionNode // when hoisted\n    | CacheExpression // when cached by v-once\n    | MemoExpression // when cached by v-memo\n    | undefined\n  ssrCodegenNode?: TemplateLiteral\n}\n\nexport interface ComponentNode extends BaseElementNode {\n  tagType: ElementTypes.COMPONENT\n  codegenNode:\n    | VNodeCall\n    | CacheExpression // when cached by v-once\n    | MemoExpression // when cached by v-memo\n    | undefined\n  ssrCodegenNode?: CallExpression\n}\n\nexport interface SlotOutletNode extends BaseElementNode {\n  tagType: ElementTypes.SLOT\n  codegenNode:\n    | RenderSlotCall\n    | CacheExpression // when cached by v-once\n    | undefined\n  ssrCodegenNode?: CallExpression\n}\n\nexport interface TemplateNode extends BaseElementNode {\n  tagType: ElementTypes.TEMPLATE\n  // TemplateNode is a container type that always gets compiled away\n  codegenNode: undefined\n}\n\nexport interface TextNode extends Node {\n  type: NodeTypes.TEXT\n  content: string\n}\n\nexport interface CommentNode extends Node {\n  type: NodeTypes.COMMENT\n  content: string\n}\n\nexport interface AttributeNode extends Node {\n  type: NodeTypes.ATTRIBUTE\n  name: string\n  value: TextNode | undefined\n}\n\nexport interface DirectiveNode extends Node {\n  type: NodeTypes.DIRECTIVE\n  name: string\n  exp: ExpressionNode | undefined\n  arg: ExpressionNode | undefined\n  modifiers: string[]\n  /**\n   * optional property to cache the expression parse result for v-for\n   */\n  parseResult?: ForParseResult\n}\n\n/**\n * Static types have several levels.\n * Higher levels implies lower levels. e.g. a node that can be stringified\n * can always be hoisted and skipped for patch.\n */\nexport const enum ConstantTypes {\n  NOT_CONSTANT = 0,\n  CAN_SKIP_PATCH,\n  CAN_HOIST,\n  CAN_STRINGIFY\n}\n\nexport interface SimpleExpressionNode extends Node {\n  type: NodeTypes.SIMPLE_EXPRESSION\n  content: string\n  isStatic: boolean\n  constType: ConstantTypes\n  /**\n   * Indicates this is an identifier for a hoist vnode call and points to the\n   * hoisted node.\n   */\n  hoisted?: JSChildNode\n  /**\n   * an expression parsed as the params of a function will track\n   * the identifiers declared inside the function body.\n   */\n  identifiers?: string[]\n  isHandlerKey?: boolean\n}\n\nexport interface InterpolationNode extends Node {\n  type: NodeTypes.INTERPOLATION\n  content: ExpressionNode\n}\n\nexport interface CompoundExpressionNode extends Node {\n  type: NodeTypes.COMPOUND_EXPRESSION\n  children: (\n    | SimpleExpressionNode\n    | CompoundExpressionNode\n    | InterpolationNode\n    | TextNode\n    | string\n    | symbol\n  )[]\n\n  /**\n   * an expression parsed as the params of a function will track\n   * the identifiers declared inside the function body.\n   */\n  identifiers?: string[]\n  isHandlerKey?: boolean\n}\n\nexport interface IfNode extends Node {\n  type: NodeTypes.IF\n  branches: IfBranchNode[]\n  codegenNode?: IfConditionalExpression | CacheExpression // <div v-if v-once>\n}\n\nexport interface IfBranchNode extends Node {\n  type: NodeTypes.IF_BRANCH\n  condition: ExpressionNode | undefined // else\n  children: TemplateChildNode[]\n  userKey?: AttributeNode | DirectiveNode\n  isTemplateIf?: boolean\n}\n\nexport interface ForNode extends Node {\n  type: NodeTypes.FOR\n  source: ExpressionNode\n  valueAlias: ExpressionNode | undefined\n  keyAlias: ExpressionNode | undefined\n  objectIndexAlias: ExpressionNode | undefined\n  parseResult: ForParseResult\n  children: TemplateChildNode[]\n  codegenNode?: ForCodegenNode\n}\n\nexport interface TextCallNode extends Node {\n  type: NodeTypes.TEXT_CALL\n  content: TextNode | InterpolationNode | CompoundExpressionNode\n  codegenNode: CallExpression | SimpleExpressionNode // when hoisted\n}\n\nexport type TemplateTextChildNode =\n  | TextNode\n  | InterpolationNode\n  | CompoundExpressionNode\n\nexport interface VNodeCall extends Node {\n  type: NodeTypes.VNODE_CALL\n  tag: string | symbol | CallExpression\n  props: PropsExpression | undefined\n  children:\n    | TemplateChildNode[] // multiple children\n    | TemplateTextChildNode // single text child\n    | SlotsExpression // component slots\n    | ForRenderListExpression // v-for fragment call\n    | SimpleExpressionNode // hoisted\n    | undefined\n  patchFlag: string | undefined\n  dynamicProps: string | SimpleExpressionNode | undefined\n  directives: DirectiveArguments | undefined\n  isBlock: boolean\n  disableTracking: boolean\n  isComponent: boolean\n}\n\n// JS Node Types ---------------------------------------------------------------\n\n// We also include a number of JavaScript AST nodes for code generation.\n// The AST is an intentionally minimal subset just to meet the exact needs of\n// Vue render function generation.\n\nexport type JSChildNode =\n  | VNodeCall\n  | CallExpression\n  | ObjectExpression\n  | ArrayExpression\n  | ExpressionNode\n  | FunctionExpression\n  | ConditionalExpression\n  | CacheExpression\n  | AssignmentExpression\n  | SequenceExpression\n\nexport interface CallExpression extends Node {\n  type: NodeTypes.JS_CALL_EXPRESSION\n  callee: string | symbol\n  arguments: (\n    | string\n    | symbol\n    | JSChildNode\n    | SSRCodegenNode\n    | TemplateChildNode\n    | TemplateChildNode[]\n  )[]\n}\n\nexport interface ObjectExpression extends Node {\n  type: NodeTypes.JS_OBJECT_EXPRESSION\n  properties: Array<Property>\n}\n\nexport interface Property extends Node {\n  type: NodeTypes.JS_PROPERTY\n  key: ExpressionNode\n  value: JSChildNode\n}\n\nexport interface ArrayExpression extends Node {\n  type: NodeTypes.JS_ARRAY_EXPRESSION\n  elements: Array<string | Node>\n}\n\nexport interface FunctionExpression extends Node {\n  type: NodeTypes.JS_FUNCTION_EXPRESSION\n  params: ExpressionNode | string | (ExpressionNode | string)[] | undefined\n  returns?: TemplateChildNode | TemplateChildNode[] | JSChildNode\n  body?: BlockStatement | IfStatement\n  newline: boolean\n  /**\n   * This flag is for codegen to determine whether it needs to generate the\n   * withScopeId() wrapper\n   */\n  isSlot: boolean\n  /**\n   * __COMPAT__ only, indicates a slot function that should be excluded from\n   * the legacy $scopedSlots instance property.\n   */\n  isNonScopedSlot?: boolean\n}\n\nexport interface ConditionalExpression extends Node {\n  type: NodeTypes.JS_CONDITIONAL_EXPRESSION\n  test: JSChildNode\n  consequent: JSChildNode\n  alternate: JSChildNode\n  newline: boolean\n}\n\nexport interface CacheExpression extends Node {\n  type: NodeTypes.JS_CACHE_EXPRESSION\n  index: number\n  value: JSChildNode\n  isVNode: boolean\n}\n\nexport interface MemoExpression extends CallExpression {\n  callee: typeof WITH_MEMO\n  arguments: [ExpressionNode, MemoFactory, string, string]\n}\n\ninterface MemoFactory extends FunctionExpression {\n  returns: BlockCodegenNode\n}\n\n// SSR-specific Node Types -----------------------------------------------------\n\nexport type SSRCodegenNode =\n  | BlockStatement\n  | TemplateLiteral\n  | IfStatement\n  | AssignmentExpression\n  | ReturnStatement\n  | SequenceExpression\n\nexport interface BlockStatement extends Node {\n  type: NodeTypes.JS_BLOCK_STATEMENT\n  body: (JSChildNode | IfStatement)[]\n}\n\nexport interface TemplateLiteral extends Node {\n  type: NodeTypes.JS_TEMPLATE_LITERAL\n  elements: (string | JSChildNode)[]\n}\n\nexport interface IfStatement extends Node {\n  type: NodeTypes.JS_IF_STATEMENT\n  test: ExpressionNode\n  consequent: BlockStatement\n  alternate: IfStatement | BlockStatement | ReturnStatement | undefined\n}\n\nexport interface AssignmentExpression extends Node {\n  type: NodeTypes.JS_ASSIGNMENT_EXPRESSION\n  left: SimpleExpressionNode\n  right: JSChildNode\n}\n\nexport interface SequenceExpression extends Node {\n  type: NodeTypes.JS_SEQUENCE_EXPRESSION\n  expressions: JSChildNode[]\n}\n\nexport interface ReturnStatement extends Node {\n  type: NodeTypes.JS_RETURN_STATEMENT\n  returns: TemplateChildNode | TemplateChildNode[] | JSChildNode\n}\n\n// Codegen Node Types ----------------------------------------------------------\n\nexport interface DirectiveArguments extends ArrayExpression {\n  elements: DirectiveArgumentNode[]\n}\n\nexport interface DirectiveArgumentNode extends ArrayExpression {\n  elements: // dir, exp, arg, modifiers\n  | [string]\n    | [string, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode, ObjectExpression]\n}\n\n// renderSlot(...)\nexport interface RenderSlotCall extends CallExpression {\n  callee: typeof RENDER_SLOT\n  arguments: // $slots, name, props, fallback\n  | [string, string | ExpressionNode]\n    | [string, string | ExpressionNode, PropsExpression]\n    | [\n        string,\n        string | ExpressionNode,\n        PropsExpression | '{}',\n        TemplateChildNode[]\n      ]\n}\n\nexport type SlotsExpression = SlotsObjectExpression | DynamicSlotsExpression\n\n// { foo: () => [...] }\nexport interface SlotsObjectExpression extends ObjectExpression {\n  properties: SlotsObjectProperty[]\n}\n\nexport interface SlotsObjectProperty extends Property {\n  value: SlotFunctionExpression\n}\n\nexport interface SlotFunctionExpression extends FunctionExpression {\n  returns: TemplateChildNode[]\n}\n\n// createSlots({ ... }, [\n//    foo ? () => [] : undefined,\n//    renderList(list, i => () => [i])\n// ])\nexport interface DynamicSlotsExpression extends CallExpression {\n  callee: typeof CREATE_SLOTS\n  arguments: [SlotsObjectExpression, DynamicSlotEntries]\n}\n\nexport interface DynamicSlotEntries extends ArrayExpression {\n  elements: (ConditionalDynamicSlotNode | ListDynamicSlotNode)[]\n}\n\nexport interface ConditionalDynamicSlotNode extends ConditionalExpression {\n  consequent: DynamicSlotNode\n  alternate: DynamicSlotNode | SimpleExpressionNode\n}\n\nexport interface ListDynamicSlotNode extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ListDynamicSlotIterator]\n}\n\nexport interface ListDynamicSlotIterator extends FunctionExpression {\n  returns: DynamicSlotNode\n}\n\nexport interface DynamicSlotNode extends ObjectExpression {\n  properties: [Property, DynamicSlotFnProperty]\n}\n\nexport interface DynamicSlotFnProperty extends Property {\n  value: SlotFunctionExpression\n}\n\nexport type BlockCodegenNode = VNodeCall | RenderSlotCall\n\nexport interface IfConditionalExpression extends ConditionalExpression {\n  consequent: BlockCodegenNode | MemoExpression\n  alternate: BlockCodegenNode | IfConditionalExpression | MemoExpression\n}\n\nexport interface ForCodegenNode extends VNodeCall {\n  isBlock: true\n  tag: typeof FRAGMENT\n  props: undefined\n  children: ForRenderListExpression\n  patchFlag: string\n  disableTracking: boolean\n}\n\nexport interface ForRenderListExpression extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ForIteratorExpression]\n}\n\nexport interface ForIteratorExpression extends FunctionExpression {\n  returns: BlockCodegenNode\n}\n\n// AST Utilities ---------------------------------------------------------------\n\n// Some expressions, e.g. sequence and conditional expressions, are never\n// associated with template nodes, so their source locations are just a stub.\n// Container types like CompoundExpression also don't need a real location.\nexport const locStub: SourceLocation = {\n  source: '',\n  start: { line: 1, column: 1, offset: 0 },\n  end: { line: 1, column: 1, offset: 0 }\n}\n\nexport function createRoot(\n  children: TemplateChildNode[],\n  loc = locStub\n): RootNode {\n  return {\n    type: NodeTypes.ROOT,\n    children,\n    helpers: [],\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: 0,\n    temps: 0,\n    codegenNode: undefined,\n    loc\n  }\n}\n\nexport function createVNodeCall(\n  context: TransformContext | null,\n  tag: VNodeCall['tag'],\n  props?: VNodeCall['props'],\n  children?: VNodeCall['children'],\n  patchFlag?: VNodeCall['patchFlag'],\n  dynamicProps?: VNodeCall['dynamicProps'],\n  directives?: VNodeCall['directives'],\n  isBlock: VNodeCall['isBlock'] = false,\n  disableTracking: VNodeCall['disableTracking'] = false,\n  isComponent: VNodeCall['isComponent'] = false,\n  loc = locStub\n): VNodeCall {\n  if (context) {\n    if (isBlock) {\n      context.helper(OPEN_BLOCK)\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))\n    } else {\n      context.helper(getVNodeHelper(context.inSSR, isComponent))\n    }\n    if (directives) {\n      context.helper(WITH_DIRECTIVES)\n    }\n  }\n\n  return {\n    type: NodeTypes.VNODE_CALL,\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent,\n    loc\n  }\n}\n\nexport function createArrayExpression(\n  elements: ArrayExpression['elements'],\n  loc: SourceLocation = locStub\n): ArrayExpression {\n  return {\n    type: NodeTypes.JS_ARRAY_EXPRESSION,\n    loc,\n    elements\n  }\n}\n\nexport function createObjectExpression(\n  properties: ObjectExpression['properties'],\n  loc: SourceLocation = locStub\n): ObjectExpression {\n  return {\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\n    loc,\n    properties\n  }\n}\n\nexport function createObjectProperty(\n  key: Property['key'] | string,\n  value: Property['value']\n): Property {\n  return {\n    type: NodeTypes.JS_PROPERTY,\n    loc: locStub,\n    key: isString(key) ? createSimpleExpression(key, true) : key,\n    value\n  }\n}\n\nexport function createSimpleExpression(\n  content: SimpleExpressionNode['content'],\n  isStatic: SimpleExpressionNode['isStatic'] = false,\n  loc: SourceLocation = locStub,\n  constType: ConstantTypes = ConstantTypes.NOT_CONSTANT\n): SimpleExpressionNode {\n  return {\n    type: NodeTypes.SIMPLE_EXPRESSION,\n    loc,\n    content,\n    isStatic,\n    constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType\n  }\n}\n\nexport function createInterpolation(\n  content: InterpolationNode['content'] | string,\n  loc: SourceLocation\n): InterpolationNode {\n  return {\n    type: NodeTypes.INTERPOLATION,\n    loc,\n    content: isString(content)\n      ? createSimpleExpression(content, false, loc)\n      : content\n  }\n}\n\nexport function createCompoundExpression(\n  children: CompoundExpressionNode['children'],\n  loc: SourceLocation = locStub\n): CompoundExpressionNode {\n  return {\n    type: NodeTypes.COMPOUND_EXPRESSION,\n    loc,\n    children\n  }\n}\n\ntype InferCodegenNodeType<T> = T extends typeof RENDER_SLOT\n  ? RenderSlotCall\n  : CallExpression\n\nexport function createCallExpression<T extends CallExpression['callee']>(\n  callee: T,\n  args: CallExpression['arguments'] = [],\n  loc: SourceLocation = locStub\n): InferCodegenNodeType<T> {\n  return {\n    type: NodeTypes.JS_CALL_EXPRESSION,\n    loc,\n    callee,\n    arguments: args\n  } as InferCodegenNodeType<T>\n}\n\nexport function createFunctionExpression(\n  params: FunctionExpression['params'],\n  returns: FunctionExpression['returns'] = undefined,\n  newline: boolean = false,\n  isSlot: boolean = false,\n  loc: SourceLocation = locStub\n): FunctionExpression {\n  return {\n    type: NodeTypes.JS_FUNCTION_EXPRESSION,\n    params,\n    returns,\n    newline,\n    isSlot,\n    loc\n  }\n}\n\nexport function createConditionalExpression(\n  test: ConditionalExpression['test'],\n  consequent: ConditionalExpression['consequent'],\n  alternate: ConditionalExpression['alternate'],\n  newline = true\n): ConditionalExpression {\n  return {\n    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n    test,\n    consequent,\n    alternate,\n    newline,\n    loc: locStub\n  }\n}\n\nexport function createCacheExpression(\n  index: number,\n  value: JSChildNode,\n  isVNode: boolean = false\n): CacheExpression {\n  return {\n    type: NodeTypes.JS_CACHE_EXPRESSION,\n    index,\n    value,\n    isVNode,\n    loc: locStub\n  }\n}\n\nexport function createBlockStatement(\n  body: BlockStatement['body']\n): BlockStatement {\n  return {\n    type: NodeTypes.JS_BLOCK_STATEMENT,\n    body,\n    loc: locStub\n  }\n}\n\nexport function createTemplateLiteral(\n  elements: TemplateLiteral['elements']\n): TemplateLiteral {\n  return {\n    type: NodeTypes.JS_TEMPLATE_LITERAL,\n    elements,\n    loc: locStub\n  }\n}\n\nexport function createIfStatement(\n  test: IfStatement['test'],\n  consequent: IfStatement['consequent'],\n  alternate?: IfStatement['alternate']\n): IfStatement {\n  return {\n    type: NodeTypes.JS_IF_STATEMENT,\n    test,\n    consequent,\n    alternate,\n    loc: locStub\n  }\n}\n\nexport function createAssignmentExpression(\n  left: AssignmentExpression['left'],\n  right: AssignmentExpression['right']\n): AssignmentExpression {\n  return {\n    type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,\n    left,\n    right,\n    loc: locStub\n  }\n}\n\nexport function createSequenceExpression(\n  expressions: SequenceExpression['expressions']\n): SequenceExpression {\n  return {\n    type: NodeTypes.JS_SEQUENCE_EXPRESSION,\n    expressions,\n    loc: locStub\n  }\n}\n\nexport function createReturnStatement(\n  returns: ReturnStatement['returns']\n): ReturnStatement {\n  return {\n    type: NodeTypes.JS_RETURN_STATEMENT,\n    returns,\n    loc: locStub\n  }\n}\n","import {\n  SourceLocation,\n  Position,\n  ElementNode,\n  NodeTypes,\n  CallExpression,\n  createCallExpression,\n  DirectiveNode,\n  ElementTypes,\n  TemplateChildNode,\n  RootNode,\n  ObjectExpression,\n  Property,\n  JSChildNode,\n  createObjectExpression,\n  SlotOutletNode,\n  TemplateNode,\n  RenderSlotCall,\n  ExpressionNode,\n  IfBranchNode,\n  TextNode,\n  InterpolationNode,\n  VNodeCall,\n  SimpleExpressionNode,\n  BlockCodegenNode,\n  MemoExpression\n} from './ast'\nimport { TransformContext } from './transform'\nimport {\n  MERGE_PROPS,\n  TELEPORT,\n  SUSPENSE,\n  KEEP_ALIVE,\n  BASE_TRANSITION,\n  TO_HANDLERS,\n  NORMALIZE_PROPS,\n  GUARD_REACTIVE_PROPS,\n  CREATE_BLOCK,\n  CREATE_ELEMENT_BLOCK,\n  CREATE_VNODE,\n  CREATE_ELEMENT_VNODE,\n  WITH_MEMO,\n  OPEN_BLOCK\n} from './runtimeHelpers'\nimport { isString, isObject, hyphenate, extend, NOOP } from '@vue/shared'\nimport { PropsExpression } from './transforms/transformElement'\nimport { parseExpression } from '@babel/parser'\nimport { Expression } from '@babel/types'\n\nexport const isStaticExp = (p: JSChildNode): p is SimpleExpressionNode =>\n  p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic\n\nexport const isBuiltInType = (tag: string, expected: string): boolean =>\n  tag === expected || tag === hyphenate(expected)\n\nexport function isCoreComponent(tag: string): symbol | void {\n  if (isBuiltInType(tag, 'Teleport')) {\n    return TELEPORT\n  } else if (isBuiltInType(tag, 'Suspense')) {\n    return SUSPENSE\n  } else if (isBuiltInType(tag, 'KeepAlive')) {\n    return KEEP_ALIVE\n  } else if (isBuiltInType(tag, 'BaseTransition')) {\n    return BASE_TRANSITION\n  }\n}\n\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/\nexport const isSimpleIdentifier = (name: string): boolean =>\n  !nonIdentifierRE.test(name)\n\nconst enum MemberExpLexState {\n  inMemberExp,\n  inBrackets,\n  inParens,\n  inString\n}\n\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g\n\n/**\n * Simple lexer to check if an expression is a member expression. This is\n * lax and only checks validity at the root level (i.e. does not validate exps\n * inside square brackets), but it's ok since these are only used on template\n * expressions and false positives are invalid expressions in the first place.\n */\nexport const isMemberExpressionBrowser = (path: string): boolean => {\n  // remove whitespaces around . or [ first\n  path = path.trim().replace(whitespaceRE, s => s.trim())\n\n  let state = MemberExpLexState.inMemberExp\n  let stateStack: MemberExpLexState[] = []\n  let currentOpenBracketCount = 0\n  let currentOpenParensCount = 0\n  let currentStringType: \"'\" | '\"' | '`' | null = null\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path.charAt(i)\n    switch (state) {\n      case MemberExpLexState.inMemberExp:\n        if (char === '[') {\n          stateStack.push(state)\n          state = MemberExpLexState.inBrackets\n          currentOpenBracketCount++\n        } else if (char === '(') {\n          stateStack.push(state)\n          state = MemberExpLexState.inParens\n          currentOpenParensCount++\n        } else if (\n          !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)\n        ) {\n          return false\n        }\n        break\n      case MemberExpLexState.inBrackets:\n        if (char === `'` || char === `\"` || char === '`') {\n          stateStack.push(state)\n          state = MemberExpLexState.inString\n          currentStringType = char\n        } else if (char === `[`) {\n          currentOpenBracketCount++\n        } else if (char === `]`) {\n          if (!--currentOpenBracketCount) {\n            state = stateStack.pop()!\n          }\n        }\n        break\n      case MemberExpLexState.inParens:\n        if (char === `'` || char === `\"` || char === '`') {\n          stateStack.push(state)\n          state = MemberExpLexState.inString\n          currentStringType = char\n        } else if (char === `(`) {\n          currentOpenParensCount++\n        } else if (char === `)`) {\n          // if the exp ends as a call then it should not be considered valid\n          if (i === path.length - 1) {\n            return false\n          }\n          if (!--currentOpenParensCount) {\n            state = stateStack.pop()!\n          }\n        }\n        break\n      case MemberExpLexState.inString:\n        if (char === currentStringType) {\n          state = stateStack.pop()!\n          currentStringType = null\n        }\n        break\n    }\n  }\n  return !currentOpenBracketCount && !currentOpenParensCount\n}\n\nexport const isMemberExpressionNode = __BROWSER__\n  ? (NOOP as any as (path: string, context: TransformContext) => boolean)\n  : (path: string, context: TransformContext): boolean => {\n      try {\n        let ret: Expression = parseExpression(path, {\n          plugins: context.expressionPlugins\n        })\n        if (ret.type === 'TSAsExpression' || ret.type === 'TSTypeAssertion') {\n          ret = ret.expression\n        }\n        return (\n          ret.type === 'MemberExpression' ||\n          ret.type === 'OptionalMemberExpression' ||\n          ret.type === 'Identifier'\n        )\n      } catch (e) {\n        return false\n      }\n    }\n\nexport const isMemberExpression = __BROWSER__\n  ? isMemberExpressionBrowser\n  : isMemberExpressionNode\n\nexport function getInnerRange(\n  loc: SourceLocation,\n  offset: number,\n  length: number\n): SourceLocation {\n  __TEST__ && assert(offset <= loc.source.length)\n  const source = loc.source.slice(offset, offset + length)\n  const newLoc: SourceLocation = {\n    source,\n    start: advancePositionWithClone(loc.start, loc.source, offset),\n    end: loc.end\n  }\n\n  if (length != null) {\n    __TEST__ && assert(offset + length <= loc.source.length)\n    newLoc.end = advancePositionWithClone(\n      loc.start,\n      loc.source,\n      offset + length\n    )\n  }\n\n  return newLoc\n}\n\nexport function advancePositionWithClone(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  return advancePositionWithMutation(\n    extend({}, pos),\n    source,\n    numberOfCharacters\n  )\n}\n\n// advance by mutation without cloning (for performance reasons), since this\n// gets called a lot in the parser\nexport function advancePositionWithMutation(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  let linesCount = 0\n  let lastNewLinePos = -1\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\n      linesCount++\n      lastNewLinePos = i\n    }\n  }\n\n  pos.offset += numberOfCharacters\n  pos.line += linesCount\n  pos.column =\n    lastNewLinePos === -1\n      ? pos.column + numberOfCharacters\n      : numberOfCharacters - lastNewLinePos\n\n  return pos\n}\n\nexport function assert(condition: boolean, msg?: string) {\n  /* istanbul ignore if */\n  if (!condition) {\n    throw new Error(msg || `unexpected compiler condition`)\n  }\n}\n\nexport function findDir(\n  node: ElementNode,\n  name: string | RegExp,\n  allowEmpty: boolean = false\n): DirectiveNode | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (\n      p.type === NodeTypes.DIRECTIVE &&\n      (allowEmpty || p.exp) &&\n      (isString(name) ? p.name === name : name.test(p.name))\n    ) {\n      return p\n    }\n  }\n}\n\nexport function findProp(\n  node: ElementNode,\n  name: string,\n  dynamicOnly: boolean = false,\n  allowEmpty: boolean = false\n): ElementNode['props'][0] | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (dynamicOnly) continue\n      if (p.name === name && (p.value || allowEmpty)) {\n        return p\n      }\n    } else if (\n      p.name === 'bind' &&\n      (p.exp || allowEmpty) &&\n      isStaticArgOf(p.arg, name)\n    ) {\n      return p\n    }\n  }\n}\n\nexport function isStaticArgOf(\n  arg: DirectiveNode['arg'],\n  name: string\n): boolean {\n  return !!(arg && isStaticExp(arg) && arg.content === name)\n}\n\nexport function hasDynamicKeyVBind(node: ElementNode): boolean {\n  return node.props.some(\n    p =>\n      p.type === NodeTypes.DIRECTIVE &&\n      p.name === 'bind' &&\n      (!p.arg || // v-bind=\"obj\"\n        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]\n        !p.arg.isStatic) // v-bind:[foo]\n  )\n}\n\nexport function isText(\n  node: TemplateChildNode\n): node is TextNode | InterpolationNode {\n  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT\n}\n\nexport function isVSlot(p: ElementNode['props'][0]): p is DirectiveNode {\n  return p.type === NodeTypes.DIRECTIVE && p.name === 'slot'\n}\n\nexport function isTemplateNode(\n  node: RootNode | TemplateChildNode\n): node is TemplateNode {\n  return (\n    node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE\n  )\n}\n\nexport function isSlotOutlet(\n  node: RootNode | TemplateChildNode\n): node is SlotOutletNode {\n  return node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT\n}\n\nexport function getVNodeHelper(ssr: boolean, isComponent: boolean) {\n  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE\n}\n\nexport function getVNodeBlockHelper(ssr: boolean, isComponent: boolean) {\n  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK\n}\n\nconst propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])\n\nfunction getUnnormalizedProps(\n  props: PropsExpression | '{}',\n  callPath: CallExpression[] = []\n): [PropsExpression | '{}', CallExpression[]] {\n  if (\n    props &&\n    !isString(props) &&\n    props.type === NodeTypes.JS_CALL_EXPRESSION\n  ) {\n    const callee = props.callee\n    if (!isString(callee) && propsHelperSet.has(callee)) {\n      return getUnnormalizedProps(\n        props.arguments[0] as PropsExpression,\n        callPath.concat(props)\n      )\n    }\n  }\n  return [props, callPath]\n}\nexport function injectProp(\n  node: VNodeCall | RenderSlotCall,\n  prop: Property,\n  context: TransformContext\n) {\n  let propsWithInjection: ObjectExpression | CallExpression | undefined\n  /**\n   * 1. mergeProps(...)\n   * 2. toHandlers(...)\n   * 3. normalizeProps(...)\n   * 4. normalizeProps(guardReactiveProps(...))\n   *\n   * we need to get the real props before normalization\n   */\n  let props =\n    node.type === NodeTypes.VNODE_CALL ? node.props : node.arguments[2]\n  let callPath: CallExpression[] = []\n  let parentCall: CallExpression | undefined\n  if (\n    props &&\n    !isString(props) &&\n    props.type === NodeTypes.JS_CALL_EXPRESSION\n  ) {\n    const ret = getUnnormalizedProps(props)\n    props = ret[0]\n    callPath = ret[1]\n    parentCall = callPath[callPath.length - 1]\n  }\n\n  if (props == null || isString(props)) {\n    propsWithInjection = createObjectExpression([prop])\n  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\n    // merged props... add ours\n    // only inject key to object literal if it's the first argument so that\n    // if doesn't override user provided keys\n    const first = props.arguments[0] as string | JSChildNode\n    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n      first.properties.unshift(prop)\n    } else {\n      if (props.callee === TO_HANDLERS) {\n        // #2366\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n          createObjectExpression([prop]),\n          props\n        ])\n      } else {\n        props.arguments.unshift(createObjectExpression([prop]))\n      }\n    }\n    !propsWithInjection && (propsWithInjection = props)\n  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n    let alreadyExists = false\n    // check existing key to avoid overriding user provided keys\n    if (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {\n      const propKeyName = prop.key.content\n      alreadyExists = props.properties.some(\n        p =>\n          p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\n          p.key.content === propKeyName\n      )\n    }\n    if (!alreadyExists) {\n      props.properties.unshift(prop)\n    }\n    propsWithInjection = props\n  } else {\n    // single v-bind with expression, return a merged replacement\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n      createObjectExpression([prop]),\n      props\n    ])\n    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,\n    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,\n    // the `guardReactiveProps` will no longer be needed\n    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\n      parentCall = callPath[callPath.length - 2]\n    }\n  }\n  if (node.type === NodeTypes.VNODE_CALL) {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection\n    } else {\n      node.props = propsWithInjection\n    }\n  } else {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection\n    } else {\n      node.arguments[2] = propsWithInjection\n    }\n  }\n}\n\nexport function toValidAssetId(\n  name: string,\n  type: 'component' | 'directive' | 'filter'\n): string {\n  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character\n  return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\n    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()\n  })}`\n}\n\n// Check if a node contains expressions that reference current context scope ids\nexport function hasScopeRef(\n  node: TemplateChildNode | IfBranchNode | ExpressionNode | undefined,\n  ids: TransformContext['identifiers']\n): boolean {\n  if (!node || Object.keys(ids).length === 0) {\n    return false\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i]\n        if (\n          p.type === NodeTypes.DIRECTIVE &&\n          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))\n        ) {\n          return true\n        }\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.FOR:\n      if (hasScopeRef(node.source, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.IF:\n      return node.branches.some(b => hasScopeRef(b, ids))\n    case NodeTypes.IF_BRANCH:\n      if (hasScopeRef(node.condition, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return (\n        !node.isStatic &&\n        isSimpleIdentifier(node.content) &&\n        !!ids[node.content]\n      )\n    case NodeTypes.COMPOUND_EXPRESSION:\n      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return hasScopeRef(node.content, ids)\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return false\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return false\n  }\n}\n\nexport function getMemoedVNodeCall(node: BlockCodegenNode | MemoExpression) {\n  if (node.type === NodeTypes.JS_CALL_EXPRESSION && node.callee === WITH_MEMO) {\n    return node.arguments[1].returns as VNodeCall\n  } else {\n    return node\n  }\n}\n\nexport function makeBlock(\n  node: VNodeCall,\n  { helper, removeHelper, inSSR }: TransformContext\n) {\n  if (!node.isBlock) {\n    node.isBlock = true\n    removeHelper(getVNodeHelper(inSSR, node.isComponent))\n    helper(OPEN_BLOCK)\n    helper(getVNodeBlockHelper(inSSR, node.isComponent))\n  }\n}\n","import { SourceLocation } from '../ast'\nimport { CompilerError } from '../errors'\nimport { ParserContext } from '../parse'\nimport { TransformContext } from '../transform'\n\nexport type CompilerCompatConfig = Partial<\n  Record<CompilerDeprecationTypes, boolean | 'suppress-warning'>\n> & {\n  MODE?: 2 | 3\n}\n\nexport interface CompilerCompatOptions {\n  compatConfig?: CompilerCompatConfig\n}\n\nexport const enum CompilerDeprecationTypes {\n  COMPILER_IS_ON_ELEMENT = 'COMPILER_IS_ON_ELEMENT',\n  COMPILER_V_BIND_SYNC = 'COMPILER_V_BIND_SYNC',\n  COMPILER_V_BIND_PROP = 'COMPILER_V_BIND_PROP',\n  COMPILER_V_BIND_OBJECT_ORDER = 'COMPILER_V_BIND_OBJECT_ORDER',\n  COMPILER_V_ON_NATIVE = 'COMPILER_V_ON_NATIVE',\n  COMPILER_V_IF_V_FOR_PRECEDENCE = 'COMPILER_V_IF_V_FOR_PRECEDENCE',\n  COMPILER_NATIVE_TEMPLATE = 'COMPILER_NATIVE_TEMPLATE',\n  COMPILER_INLINE_TEMPLATE = 'COMPILER_INLINE_TEMPLATE',\n  COMPILER_FILTERS = 'COMPILER_FILTER'\n}\n\ntype DeprecationData = {\n  message: string | ((...args: any[]) => string)\n  link?: string\n}\n\nconst deprecationData: Record<CompilerDeprecationTypes, DeprecationData> = {\n  [CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT]: {\n    message:\n      `Platform-native elements with \"is\" prop will no longer be ` +\n      `treated as components in Vue 3 unless the \"is\" value is explicitly ` +\n      `prefixed with \"vue:\".`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_BIND_SYNC]: {\n    message: key =>\n      `.sync modifier for v-bind has been removed. Use v-model with ` +\n      `argument instead. \\`v-bind:${key}.sync\\` should be changed to ` +\n      `\\`v-model:${key}\\`.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_BIND_PROP]: {\n    message:\n      `.prop modifier for v-bind has been removed and no longer necessary. ` +\n      `Vue 3 will automatically set a binding as DOM property when appropriate.`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER]: {\n    message:\n      `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript ` +\n      `object spread: it will now overwrite an existing non-mergeable attribute ` +\n      `that appears before v-bind in the case of conflict. ` +\n      `To retain 2.x behavior, move v-bind to make it the first attribute. ` +\n      `You can also suppress this warning if the usage is intended.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_ON_NATIVE]: {\n    message: `.native modifier for v-on has been removed as is no longer necessary.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE]: {\n    message:\n      `v-if / v-for precedence when used on the same element has changed ` +\n      `in Vue 3: v-if now takes higher precedence and will no longer have ` +\n      `access to v-for scope variables. It is best to avoid the ambiguity ` +\n      `with <template> tags or use a computed property that filters v-for ` +\n      `data source.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE]: {\n    message:\n      `<template> with no special directives will render as a native template ` +\n      `element instead of its inner content in Vue 3.`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE]: {\n    message: `\"inline-template\" has been removed in Vue 3.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_FILTERS]: {\n    message:\n      `filters have been removed in Vue 3. ` +\n      `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` +\n      `Use method calls or computed properties instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\n  }\n}\n\nfunction getCompatValue(\n  key: CompilerDeprecationTypes | 'MODE',\n  context: ParserContext | TransformContext\n) {\n  const config = (context as ParserContext).options\n    ? (context as ParserContext).options.compatConfig\n    : (context as TransformContext).compatConfig\n  const value = config && config[key]\n  if (key === 'MODE') {\n    return value || 3 // compiler defaults to v3 behavior\n  } else {\n    return value\n  }\n}\n\nexport function isCompatEnabled(\n  key: CompilerDeprecationTypes,\n  context: ParserContext | TransformContext\n) {\n  const mode = getCompatValue('MODE', context)\n  const value = getCompatValue(key, context)\n  // in v3 mode, only enable if explicitly set to true\n  // otherwise enable for any non-false value\n  return mode === 3 ? value === true : value !== false\n}\n\nexport function checkCompatEnabled(\n  key: CompilerDeprecationTypes,\n  context: ParserContext | TransformContext,\n  loc: SourceLocation | null,\n  ...args: any[]\n): boolean {\n  const enabled = isCompatEnabled(key, context)\n  if (__DEV__ && enabled) {\n    warnDeprecation(key, context, loc, ...args)\n  }\n  return enabled\n}\n\nexport function warnDeprecation(\n  key: CompilerDeprecationTypes,\n  context: ParserContext | TransformContext,\n  loc: SourceLocation | null,\n  ...args: any[]\n) {\n  const val = getCompatValue(key, context)\n  if (val === 'suppress-warning') {\n    return\n  }\n  const { message, link } = deprecationData[key]\n  const msg = `(deprecation ${key}) ${\n    typeof message === 'function' ? message(...args) : message\n  }${link ? `\\n  Details: ${link}` : ``}`\n\n  const err = new SyntaxError(msg) as CompilerError\n  err.code = key\n  if (loc) err.loc = loc\n  context.onWarn(err)\n}\n","import { ErrorHandlingOptions, ParserOptions } from './options'\nimport { NO, isArray, makeMap, extend } from '@vue/shared'\nimport {\n  ErrorCodes,\n  createCompilerError,\n  defaultOnError,\n  defaultOnWarn\n} from './errors'\nimport {\n  assert,\n  advancePositionWithMutation,\n  advancePositionWithClone,\n  isCoreComponent,\n  isStaticArgOf\n} from './utils'\nimport {\n  Namespaces,\n  AttributeNode,\n  CommentNode,\n  DirectiveNode,\n  ElementNode,\n  ElementTypes,\n  ExpressionNode,\n  NodeTypes,\n  Position,\n  RootNode,\n  SourceLocation,\n  TextNode,\n  TemplateChildNode,\n  InterpolationNode,\n  createRoot,\n  ConstantTypes\n} from './ast'\nimport {\n  checkCompatEnabled,\n  CompilerCompatOptions,\n  CompilerDeprecationTypes,\n  isCompatEnabled,\n  warnDeprecation\n} from './compat/compatConfig'\n\ntype OptionalOptions =\n  | 'whitespace'\n  | 'isNativeTag'\n  | 'isBuiltInComponent'\n  | keyof CompilerCompatOptions\ntype MergedParserOptions = Omit<Required<ParserOptions>, OptionalOptions> &\n  Pick<ParserOptions, OptionalOptions>\ntype AttributeValue =\n  | {\n      content: string\n      isQuoted: boolean\n      loc: SourceLocation\n    }\n  | undefined\n\n// The default decoder only provides escapes for characters reserved as part of\n// the template syntax, and is only used if the custom renderer did not provide\n// a platform-specific decoder.\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g\nconst decodeMap: Record<string, string> = {\n  gt: '>',\n  lt: '<',\n  amp: '&',\n  apos: \"'\",\n  quot: '\"'\n}\n\nexport const defaultParserOptions: MergedParserOptions = {\n  delimiters: [`{{`, `}}`],\n  getNamespace: () => Namespaces.HTML,\n  getTextMode: () => TextModes.DATA,\n  isVoidTag: NO,\n  isPreTag: NO,\n  isCustomElement: NO,\n  decodeEntities: (rawText: string): string =>\n    rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\n  onError: defaultOnError,\n  onWarn: defaultOnWarn,\n  comments: __DEV__\n}\n\nexport const enum TextModes {\n  //          | Elements | Entities | End sign              | Inside of\n  DATA, //    |         |         | End tags of ancestors |\n  RCDATA, //  |         |         | End tag of the parent | <textarea>\n  RAWTEXT, // |         |         | End tag of the parent | <style>,<script>\n  CDATA,\n  ATTRIBUTE_VALUE\n}\n\nexport interface ParserContext {\n  options: MergedParserOptions\n  readonly originalSource: string\n  source: string\n  offset: number\n  line: number\n  column: number\n  inPre: boolean // HTML <pre> tag, preserve whitespaces\n  inVPre: boolean // v-pre, do not process directives and interpolations\n  onWarn: NonNullable<ErrorHandlingOptions['onWarn']>\n}\n\nexport function baseParse(\n  content: string,\n  options: ParserOptions = {}\n): RootNode {\n  const context = createParserContext(content, options)\n  const start = getCursor(context)\n  return createRoot(\n    parseChildren(context, TextModes.DATA, []),\n    getSelection(context, start)\n  )\n}\n\nfunction createParserContext(\n  content: string,\n  rawOptions: ParserOptions\n): ParserContext {\n  const options = extend({}, defaultParserOptions)\n\n  let key: keyof ParserOptions\n  for (key in rawOptions) {\n    // @ts-ignore\n    options[key] =\n      rawOptions[key] === undefined\n        ? defaultParserOptions[key]\n        : rawOptions[key]\n  }\n  return {\n    options,\n    column: 1,\n    line: 1,\n    offset: 0,\n    originalSource: content,\n    source: content,\n    inPre: false,\n    inVPre: false,\n    onWarn: options.onWarn\n  }\n}\n\nfunction parseChildren(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  const parent = last(ancestors)\n  const ns = parent ? parent.ns : Namespaces.HTML\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context, mode, ancestors)) {\n    __TEST__ && assert(context.source.length > 0)\n    const s = context.source\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\n\n    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\n      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\n        // '{{'\n        node = parseInterpolation(context, mode)\n      } else if (mode === TextModes.DATA && s[0] === '<') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\n        if (s.length === 1) {\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\n        } else if (s[1] === '!') {\n          // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\n          if (startsWith(s, '<!--')) {\n            node = parseComment(context)\n          } else if (startsWith(s, '<!DOCTYPE')) {\n            // Ignore DOCTYPE by a limitation.\n            node = parseBogusComment(context)\n          } else if (startsWith(s, '<![CDATA[')) {\n            if (ns !== Namespaces.HTML) {\n              node = parseCDATA(context, ancestors)\n            } else {\n              emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)\n              node = parseBogusComment(context)\n            }\n          } else {\n            emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)\n            node = parseBogusComment(context)\n          }\n        } else if (s[1] === '/') {\n          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n          if (s.length === 2) {\n            emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)\n          } else if (s[2] === '>') {\n            emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)\n            advanceBy(context, 3)\n            continue\n          } else if (/[a-z]/i.test(s[2])) {\n            emitError(context, ErrorCodes.X_INVALID_END_TAG)\n            parseTag(context, TagType.End, parent)\n            continue\n          } else {\n            emitError(\n              context,\n              ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,\n              2\n            )\n            node = parseBogusComment(context)\n          }\n        } else if (/[a-z]/i.test(s[1])) {\n          node = parseElement(context, ancestors)\n\n          // 2.x <template> with no directive compat\n          if (\n            __COMPAT__ &&\n            isCompatEnabled(\n              CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\n              context\n            ) &&\n            node &&\n            node.tag === 'template' &&\n            !node.props.some(\n              p =>\n                p.type === NodeTypes.DIRECTIVE &&\n                isSpecialTemplateDirective(p.name)\n            )\n          ) {\n            __DEV__ &&\n              warnDeprecation(\n                CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\n                context,\n                node.loc\n              )\n            node = node.children\n          }\n        } else if (s[1] === '?') {\n          emitError(\n            context,\n            ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n            1\n          )\n          node = parseBogusComment(context)\n        } else {\n          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)\n        }\n      }\n    }\n    if (!node) {\n      node = parseText(context, mode)\n    }\n\n    if (isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        pushNode(nodes, node[i])\n      }\n    } else {\n      pushNode(nodes, node)\n    }\n  }\n\n  // Whitespace handling strategy like v2\n  let removedWhitespace = false\n  if (mode !== TextModes.RAWTEXT && mode !== TextModes.RCDATA) {\n    const shouldCondense = context.options.whitespace !== 'preserve'\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i]\n      if (!context.inPre && node.type === NodeTypes.TEXT) {\n        if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\n          const prev = nodes[i - 1]\n          const next = nodes[i + 1]\n          // Remove if:\n          // - the whitespace is the first or last node, or:\n          // - (condense mode) the whitespace is adjacent to a comment, or:\n          // - (condense mode) the whitespace is between two elements AND contains newline\n          if (\n            !prev ||\n            !next ||\n            (shouldCondense &&\n              (prev.type === NodeTypes.COMMENT ||\n                next.type === NodeTypes.COMMENT ||\n                (prev.type === NodeTypes.ELEMENT &&\n                  next.type === NodeTypes.ELEMENT &&\n                  /[\\r\\n]/.test(node.content))))\n          ) {\n            removedWhitespace = true\n            nodes[i] = null as any\n          } else {\n            // Otherwise, the whitespace is condensed into a single space\n            node.content = ' '\n          }\n        } else if (shouldCondense) {\n          // in condense mode, consecutive whitespaces in text are condensed\n          // down to a single space.\n          node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ')\n        }\n      }\n      // Remove comment nodes if desired by configuration.\n      else if (node.type === NodeTypes.COMMENT && !context.options.comments) {\n        removedWhitespace = true\n        nodes[i] = null as any\n      }\n    }\n    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\n      // remove leading newline per html spec\n      // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\n      const first = nodes[0]\n      if (first && first.type === NodeTypes.TEXT) {\n        first.content = first.content.replace(/^\\r?\\n/, '')\n      }\n    }\n  }\n\n  return removedWhitespace ? nodes.filter(Boolean) : nodes\n}\n\nfunction pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void {\n  if (node.type === NodeTypes.TEXT) {\n    const prev = last(nodes)\n    // Merge if both this and the previous node are text and those are\n    // consecutive. This happens for cases like \"a < b\".\n    if (\n      prev &&\n      prev.type === NodeTypes.TEXT &&\n      prev.loc.end.offset === node.loc.start.offset\n    ) {\n      prev.content += node.content\n      prev.loc.end = node.loc.end\n      prev.loc.source += node.loc.source\n      return\n    }\n  }\n\n  nodes.push(node)\n}\n\nfunction parseCDATA(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  __TEST__ &&\n    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)\n  __TEST__ && assert(startsWith(context.source, '<![CDATA['))\n\n  advanceBy(context, 9)\n  const nodes = parseChildren(context, TextModes.CDATA, ancestors)\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_CDATA)\n  } else {\n    __TEST__ && assert(startsWith(context.source, ']]>'))\n    advanceBy(context, 3)\n  }\n\n  return nodes\n}\n\nfunction parseComment(context: ParserContext): CommentNode {\n  __TEST__ && assert(startsWith(context.source, '<!--'))\n\n  const start = getCursor(context)\n  let content: string\n\n  // Regular comment.\n  const match = /--(\\!)?>/.exec(context.source)\n  if (!match) {\n    content = context.source.slice(4)\n    advanceBy(context, context.source.length)\n    emitError(context, ErrorCodes.EOF_IN_COMMENT)\n  } else {\n    if (match.index <= 3) {\n      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)\n    }\n    if (match[1]) {\n      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)\n    }\n    content = context.source.slice(4, match.index)\n\n    // Advancing with reporting nested comments.\n    const s = context.source.slice(0, match.index)\n    let prevIndex = 1,\n      nestedIndex = 0\n    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\n      advanceBy(context, nestedIndex - prevIndex + 1)\n      if (nestedIndex + 4 < s.length) {\n        emitError(context, ErrorCodes.NESTED_COMMENT)\n      }\n      prevIndex = nestedIndex + 1\n    }\n    advanceBy(context, match.index + match[0].length - prevIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseBogusComment(context: ParserContext): CommentNode | undefined {\n  __TEST__ && assert(/^<(?:[\\!\\?]|\\/[^a-z>])/i.test(context.source))\n\n  const start = getCursor(context)\n  const contentStart = context.source[1] === '?' ? 1 : 2\n  let content: string\n\n  const closeIndex = context.source.indexOf('>')\n  if (closeIndex === -1) {\n    content = context.source.slice(contentStart)\n    advanceBy(context, context.source.length)\n  } else {\n    content = context.source.slice(contentStart, closeIndex)\n    advanceBy(context, closeIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): ElementNode | undefined {\n  __TEST__ && assert(/^<[a-z]/i.test(context.source))\n\n  // Start tag.\n  const wasInPre = context.inPre\n  const wasInVPre = context.inVPre\n  const parent = last(ancestors)\n  const element = parseTag(context, TagType.Start, parent)\n  const isPreBoundary = context.inPre && !wasInPre\n  const isVPreBoundary = context.inVPre && !wasInVPre\n\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    // #4030 self-closing <pre> tag\n    if (isPreBoundary) {\n      context.inPre = false\n    }\n    if (isVPreBoundary) {\n      context.inVPre = false\n    }\n    return element\n  }\n\n  // Children.\n  ancestors.push(element)\n  const mode = context.options.getTextMode(element, parent)\n  const children = parseChildren(context, mode, ancestors)\n  ancestors.pop()\n\n  // 2.x inline-template compat\n  if (__COMPAT__) {\n    const inlineTemplateProp = element.props.find(\n      p => p.type === NodeTypes.ATTRIBUTE && p.name === 'inline-template'\n    ) as AttributeNode\n    if (\n      inlineTemplateProp &&\n      checkCompatEnabled(\n        CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE,\n        context,\n        inlineTemplateProp.loc\n      )\n    ) {\n      const loc = getSelection(context, element.loc.end)\n      inlineTemplateProp.value = {\n        type: NodeTypes.TEXT,\n        content: loc.source,\n        loc\n      }\n    }\n  }\n\n  element.children = children\n\n  // End tag.\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, TagType.End, parent)\n  } else {\n    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)\n    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\n      const first = children[0]\n      if (first && startsWith(first.loc.source, '<!--')) {\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\n      }\n    }\n  }\n\n  element.loc = getSelection(context, element.loc.start)\n\n  if (isPreBoundary) {\n    context.inPre = false\n  }\n  if (isVPreBoundary) {\n    context.inVPre = false\n  }\n  return element\n}\n\nconst enum TagType {\n  Start,\n  End\n}\n\nconst isSpecialTemplateDirective = /*#__PURE__*/ makeMap(\n  `if,else,else-if,for,slot`\n)\n\n/**\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\n */\nfunction parseTag(\n  context: ParserContext,\n  type: TagType.Start,\n  parent: ElementNode | undefined\n): ElementNode\nfunction parseTag(\n  context: ParserContext,\n  type: TagType.End,\n  parent: ElementNode | undefined\n): void\nfunction parseTag(\n  context: ParserContext,\n  type: TagType,\n  parent: ElementNode | undefined\n): ElementNode | undefined {\n  __TEST__ && assert(/^<\\/?[a-z]/i.test(context.source))\n  __TEST__ &&\n    assert(\n      type === (startsWith(context.source, '</') ? TagType.End : TagType.Start)\n    )\n\n  // Tag open.\n  const start = getCursor(context)\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)!\n  const tag = match[1]\n  const ns = context.options.getNamespace(tag, parent)\n\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n\n  // save current state in case we need to re-parse attributes with v-pre\n  const cursor = getCursor(context)\n  const currentSource = context.source\n\n  // check <pre> tag\n  if (context.options.isPreTag(tag)) {\n    context.inPre = true\n  }\n\n  // Attributes.\n  let props = parseAttributes(context, type)\n\n  // check v-pre\n  if (\n    type === TagType.Start &&\n    !context.inVPre &&\n    props.some(p => p.type === NodeTypes.DIRECTIVE && p.name === 'pre')\n  ) {\n    context.inVPre = true\n    // reset context\n    extend(context, cursor)\n    context.source = currentSource\n    // re-parse attrs and filter out v-pre itself\n    props = parseAttributes(context, type).filter(p => p.name !== 'v-pre')\n  }\n\n  // Tag close.\n  let isSelfClosing = false\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_TAG)\n  } else {\n    isSelfClosing = startsWith(context.source, '/>')\n    if (type === TagType.End && isSelfClosing) {\n      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)\n    }\n    advanceBy(context, isSelfClosing ? 2 : 1)\n  }\n\n  if (type === TagType.End) {\n    return\n  }\n\n  // 2.x deprecation checks\n  if (\n    __COMPAT__ &&\n    __DEV__ &&\n    isCompatEnabled(\n      CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\n      context\n    )\n  ) {\n    let hasIf = false\n    let hasFor = false\n    for (let i = 0; i < props.length; i++) {\n      const p = props[i]\n      if (p.type === NodeTypes.DIRECTIVE) {\n        if (p.name === 'if') {\n          hasIf = true\n        } else if (p.name === 'for') {\n          hasFor = true\n        }\n      }\n      if (hasIf && hasFor) {\n        warnDeprecation(\n          CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\n          context,\n          getSelection(context, start)\n        )\n        break\n      }\n    }\n  }\n\n  let tagType = ElementTypes.ELEMENT\n  if (!context.inVPre) {\n    if (tag === 'slot') {\n      tagType = ElementTypes.SLOT\n    } else if (tag === 'template') {\n      if (\n        props.some(\n          p =>\n            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)\n        )\n      ) {\n        tagType = ElementTypes.TEMPLATE\n      }\n    } else if (isComponent(tag, props, context)) {\n      tagType = ElementTypes.COMPONENT\n    }\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  }\n}\n\nfunction isComponent(\n  tag: string,\n  props: (AttributeNode | DirectiveNode)[],\n  context: ParserContext\n) {\n  const options = context.options\n  if (options.isCustomElement(tag)) {\n    return false\n  }\n  if (\n    tag === 'component' ||\n    /^[A-Z]/.test(tag) ||\n    isCoreComponent(tag) ||\n    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\n    (options.isNativeTag && !options.isNativeTag(tag))\n  ) {\n    return true\n  }\n  // at this point the tag should be a native tag, but check for potential \"is\"\n  // casting\n  for (let i = 0; i < props.length; i++) {\n    const p = props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (p.name === 'is' && p.value) {\n        if (p.value.content.startsWith('vue:')) {\n          return true\n        } else if (\n          __COMPAT__ &&\n          checkCompatEnabled(\n            CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n            context,\n            p.loc\n          )\n        ) {\n          return true\n        }\n      }\n    } else {\n      // directive\n      // v-is (TODO Deprecate)\n      if (p.name === 'is') {\n        return true\n      } else if (\n        // :is on plain element - only treat as component in compat mode\n        p.name === 'bind' &&\n        isStaticArgOf(p.arg, 'is') &&\n        __COMPAT__ &&\n        checkCompatEnabled(\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n          context,\n          p.loc\n        )\n      ) {\n        return true\n      }\n    }\n  }\n}\n\nfunction parseAttributes(\n  context: ParserContext,\n  type: TagType\n): (AttributeNode | DirectiveNode)[] {\n  const props = []\n  const attributeNames = new Set<string>()\n  while (\n    context.source.length > 0 &&\n    !startsWith(context.source, '>') &&\n    !startsWith(context.source, '/>')\n  ) {\n    if (startsWith(context.source, '/')) {\n      emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG)\n      advanceBy(context, 1)\n      advanceSpaces(context)\n      continue\n    }\n    if (type === TagType.End) {\n      emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES)\n    }\n\n    const attr = parseAttribute(context, attributeNames)\n\n    // Trim whitespace between class\n    // https://github.com/vuejs/core/issues/4251\n    if (\n      attr.type === NodeTypes.ATTRIBUTE &&\n      attr.value &&\n      attr.name === 'class'\n    ) {\n      attr.value.content = attr.value.content.replace(/\\s+/g, ' ').trim()\n    }\n\n    if (type === TagType.Start) {\n      props.push(attr)\n    }\n\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n      emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES)\n    }\n    advanceSpaces(context)\n  }\n  return props\n}\n\nfunction parseAttribute(\n  context: ParserContext,\n  nameSet: Set<string>\n): AttributeNode | DirectiveNode {\n  __TEST__ && assert(/^[^\\t\\r\\n\\f />]/.test(context.source))\n\n  // Name.\n  const start = getCursor(context)\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source)!\n  const name = match[0]\n\n  if (nameSet.has(name)) {\n    emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)\n  }\n  nameSet.add(name)\n\n  if (name[0] === '=') {\n    emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)\n  }\n  {\n    const pattern = /[\"'<]/g\n    let m: RegExpExecArray | null\n    while ((m = pattern.exec(name))) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n        m.index\n      )\n    }\n  }\n\n  advanceBy(context, name.length)\n\n  // Value\n  let value: AttributeValue = undefined\n\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n    advanceSpaces(context)\n    advanceBy(context, 1)\n    advanceSpaces(context)\n    value = parseAttributeValue(context)\n    if (!value) {\n      emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)\n    }\n  }\n  const loc = getSelection(context, start)\n\n  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\n    const match =\n      /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(\n        name\n      )!\n\n    let isPropShorthand = startsWith(name, '.')\n    let dirName =\n      match[1] ||\n      (isPropShorthand || startsWith(name, ':')\n        ? 'bind'\n        : startsWith(name, '@')\n        ? 'on'\n        : 'slot')\n    let arg: ExpressionNode | undefined\n\n    if (match[2]) {\n      const isSlot = dirName === 'slot'\n      const startOffset = name.lastIndexOf(match[2])\n      const loc = getSelection(\n        context,\n        getNewPosition(context, start, startOffset),\n        getNewPosition(\n          context,\n          start,\n          startOffset + match[2].length + ((isSlot && match[3]) || '').length\n        )\n      )\n      let content = match[2]\n      let isStatic = true\n\n      if (content.startsWith('[')) {\n        isStatic = false\n\n        if (!content.endsWith(']')) {\n          emitError(\n            context,\n            ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\n          )\n          content = content.slice(1)\n        } else {\n          content = content.slice(1, content.length - 1)\n        }\n      } else if (isSlot) {\n        // #1241 special case for v-slot: vuetify relies extensively on slot\n        // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\n        // supports such usage so we are keeping it consistent with 2.x.\n        content += match[3] || ''\n      }\n\n      arg = {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content,\n        isStatic,\n        constType: isStatic\n          ? ConstantTypes.CAN_STRINGIFY\n          : ConstantTypes.NOT_CONSTANT,\n        loc\n      }\n    }\n\n    if (value && value.isQuoted) {\n      const valueLoc = value.loc\n      valueLoc.start.offset++\n      valueLoc.start.column++\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)\n      valueLoc.source = valueLoc.source.slice(1, -1)\n    }\n\n    const modifiers = match[3] ? match[3].slice(1).split('.') : []\n    if (isPropShorthand) modifiers.push('prop')\n\n    // 2.x compat v-bind:foo.sync -> v-model:foo\n    if (__COMPAT__ && dirName === 'bind' && arg) {\n      if (\n        modifiers.includes('sync') &&\n        checkCompatEnabled(\n          CompilerDeprecationTypes.COMPILER_V_BIND_SYNC,\n          context,\n          loc,\n          arg.loc.source\n        )\n      ) {\n        dirName = 'model'\n        modifiers.splice(modifiers.indexOf('sync'), 1)\n      }\n\n      if (__DEV__ && modifiers.includes('prop')) {\n        checkCompatEnabled(\n          CompilerDeprecationTypes.COMPILER_V_BIND_PROP,\n          context,\n          loc\n        )\n      }\n    }\n\n    return {\n      type: NodeTypes.DIRECTIVE,\n      name: dirName,\n      exp: value && {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: value.content,\n        isStatic: false,\n        // Treat as non-constant by default. This can be potentially set to\n        // other values by `transformExpression` to make it eligible for hoisting.\n        constType: ConstantTypes.NOT_CONSTANT,\n        loc: value.loc\n      },\n      arg,\n      modifiers,\n      loc\n    }\n  }\n\n  // missing directive name or illegal directive name\n  if (!context.inVPre && startsWith(name, 'v-')) {\n    emitError(context, ErrorCodes.X_MISSING_DIRECTIVE_NAME)\n  }\n\n  return {\n    type: NodeTypes.ATTRIBUTE,\n    name,\n    value: value && {\n      type: NodeTypes.TEXT,\n      content: value.content,\n      loc: value.loc\n    },\n    loc\n  }\n}\n\nfunction parseAttributeValue(context: ParserContext): AttributeValue {\n  const start = getCursor(context)\n  let content: string\n\n  const quote = context.source[0]\n  const isQuoted = quote === `\"` || quote === `'`\n  if (isQuoted) {\n    // Quoted value.\n    advanceBy(context, 1)\n\n    const endIndex = context.source.indexOf(quote)\n    if (endIndex === -1) {\n      content = parseTextData(\n        context,\n        context.source.length,\n        TextModes.ATTRIBUTE_VALUE\n      )\n    } else {\n      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)\n      advanceBy(context, 1)\n    }\n  } else {\n    // Unquoted\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source)\n    if (!match) {\n      return undefined\n    }\n    const unexpectedChars = /[\"'<=`]/g\n    let m: RegExpExecArray | null\n    while ((m = unexpectedChars.exec(match[0]))) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n        m.index\n      )\n    }\n    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)\n  }\n\n  return { content, isQuoted, loc: getSelection(context, start) }\n}\n\nfunction parseInterpolation(\n  context: ParserContext,\n  mode: TextModes\n): InterpolationNode | undefined {\n  const [open, close] = context.options.delimiters\n  __TEST__ && assert(startsWith(context.source, open))\n\n  const closeIndex = context.source.indexOf(close, open.length)\n  if (closeIndex === -1) {\n    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)\n    return undefined\n  }\n\n  const start = getCursor(context)\n  advanceBy(context, open.length)\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  const rawContentLength = closeIndex - open.length\n  const rawContent = context.source.slice(0, rawContentLength)\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\n  const content = preTrimContent.trim()\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  const endOffset =\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      // Set `isConstant` to false by default and will decide in transformExpression\n      constType: ConstantTypes.NOT_CONSTANT,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseText(context: ParserContext, mode: TextModes): TextNode {\n  __TEST__ && assert(context.source.length > 0)\n\n  const endTokens =\n    mode === TextModes.CDATA ? [']]>'] : ['<', context.options.delimiters[0]]\n\n  let endIndex = context.source.length\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1)\n    if (index !== -1 && endIndex > index) {\n      endIndex = index\n    }\n  }\n\n  __TEST__ && assert(endIndex > 0)\n\n  const start = getCursor(context)\n  const content = parseTextData(context, endIndex, mode)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\n/**\n * Get text data with a given length from the current location.\n * This translates HTML entities in the text data.\n */\nfunction parseTextData(\n  context: ParserContext,\n  length: number,\n  mode: TextModes\n): string {\n  const rawText = context.source.slice(0, length)\n  advanceBy(context, length)\n  if (\n    mode === TextModes.RAWTEXT ||\n    mode === TextModes.CDATA ||\n    !rawText.includes('&')\n  ) {\n    return rawText\n  } else {\n    // DATA or RCDATA containing \"&\"\". Entity decoding required.\n    return context.options.decodeEntities(\n      rawText,\n      mode === TextModes.ATTRIBUTE_VALUE\n    )\n  }\n}\n\nfunction getCursor(context: ParserContext): Position {\n  const { column, line, offset } = context\n  return { column, line, offset }\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position,\n  end?: Position\n): SourceLocation {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction last<T>(xs: T[]): T | undefined {\n  return xs[xs.length - 1]\n}\n\nfunction startsWith(source: string, searchString: string): boolean {\n  return source.startsWith(searchString)\n}\n\nfunction advanceBy(context: ParserContext, numberOfCharacters: number): void {\n  const { source } = context\n  __TEST__ && assert(numberOfCharacters <= source.length)\n  advancePositionWithMutation(context, source, numberOfCharacters)\n  context.source = source.slice(numberOfCharacters)\n}\n\nfunction advanceSpaces(context: ParserContext): void {\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}\n\nfunction getNewPosition(\n  context: ParserContext,\n  start: Position,\n  numberOfCharacters: number\n): Position {\n  return advancePositionWithClone(\n    start,\n    context.originalSource.slice(start.offset, numberOfCharacters),\n    numberOfCharacters\n  )\n}\n\nfunction emitError(\n  context: ParserContext,\n  code: ErrorCodes,\n  offset?: number,\n  loc: Position = getCursor(context)\n): void {\n  if (offset) {\n    loc.offset += offset\n    loc.column += offset\n  }\n  context.options.onError(\n    createCompilerError(code, {\n      start: loc,\n      end: loc,\n      source: ''\n    })\n  )\n}\n\nfunction isEnd(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): boolean {\n  const s = context.source\n\n  switch (mode) {\n    case TextModes.DATA:\n      if (startsWith(s, '</')) {\n        // TODO: probably bad performance\n        for (let i = ancestors.length - 1; i >= 0; --i) {\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n            return true\n          }\n        }\n      }\n      break\n\n    case TextModes.RCDATA:\n    case TextModes.RAWTEXT: {\n      const parent = last(ancestors)\n      if (parent && startsWithEndTagOpen(s, parent.tag)) {\n        return true\n      }\n      break\n    }\n\n    case TextModes.CDATA:\n      if (startsWith(s, ']]>')) {\n        return true\n      }\n      break\n  }\n\n  return !s\n}\n\nfunction startsWithEndTagOpen(source: string, tag: string): boolean {\n  return (\n    startsWith(source, '</') &&\n    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&\n    /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>')\n  )\n}\n","import {\n  ConstantTypes,\n  RootNode,\n  NodeTypes,\n  TemplateChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  PlainElementNode,\n  ComponentNode,\n  TemplateNode,\n  VNodeCall,\n  ParentNode,\n  JSChildNode,\n  CallExpression,\n  createArrayExpression\n} from '../ast'\nimport { TransformContext } from '../transform'\nimport { PatchFlags, isString, isSymbol, isArray } from '@vue/shared'\nimport { getVNodeBlockHelper, getVNodeHelper, isSlotOutlet } from '../utils'\nimport {\n  OPEN_BLOCK,\n  GUARD_REACTIVE_PROPS,\n  NORMALIZE_CLASS,\n  NORMALIZE_PROPS,\n  NORMALIZE_STYLE\n} from '../runtimeHelpers'\n\nexport function hoistStatic(root: RootNode, context: TransformContext) {\n  walk(\n    root,\n    context,\n    // Root node is unfortunately non-hoistable due to potential parent\n    // fallthrough attributes.\n    isSingleElementRoot(root, root.children[0])\n  )\n}\n\nexport function isSingleElementRoot(\n  root: RootNode,\n  child: TemplateChildNode\n): child is PlainElementNode | ComponentNode | TemplateNode {\n  const { children } = root\n  return (\n    children.length === 1 &&\n    child.type === NodeTypes.ELEMENT &&\n    !isSlotOutlet(child)\n  )\n}\n\nfunction walk(\n  node: ParentNode,\n  context: TransformContext,\n  doNotHoistNode: boolean = false\n) {\n  const { children } = node\n  const originalCount = children.length\n  let hoistedCount = 0\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    // only plain elements & text calls are eligible for hoisting.\n    if (\n      child.type === NodeTypes.ELEMENT &&\n      child.tagType === ElementTypes.ELEMENT\n    ) {\n      const constantType = doNotHoistNode\n        ? ConstantTypes.NOT_CONSTANT\n        : getConstantType(child, context)\n      if (constantType > ConstantTypes.NOT_CONSTANT) {\n        if (constantType >= ConstantTypes.CAN_HOIST) {\n          ;(child.codegenNode as VNodeCall).patchFlag =\n            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)\n          child.codegenNode = context.hoist(child.codegenNode!)\n          hoistedCount++\n          continue\n        }\n      } else {\n        // node may contain dynamic children, but its props may be eligible for\n        // hoisting.\n        const codegenNode = child.codegenNode!\n        if (codegenNode.type === NodeTypes.VNODE_CALL) {\n          const flag = getPatchFlag(codegenNode)\n          if (\n            (!flag ||\n              flag === PatchFlags.NEED_PATCH ||\n              flag === PatchFlags.TEXT) &&\n            getGeneratedPropsConstantType(child, context) >=\n              ConstantTypes.CAN_HOIST\n          ) {\n            const props = getNodeProps(child)\n            if (props) {\n              codegenNode.props = context.hoist(props)\n            }\n          }\n          if (codegenNode.dynamicProps) {\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)\n          }\n        }\n      }\n    } else if (\n      child.type === NodeTypes.TEXT_CALL &&\n      getConstantType(child.content, context) >= ConstantTypes.CAN_HOIST\n    ) {\n      child.codegenNode = context.hoist(child.codegenNode)\n      hoistedCount++\n    }\n\n    // walk further\n    if (child.type === NodeTypes.ELEMENT) {\n      const isComponent = child.tagType === ElementTypes.COMPONENT\n      if (isComponent) {\n        context.scopes.vSlot++\n      }\n      walk(child, context)\n      if (isComponent) {\n        context.scopes.vSlot--\n      }\n    } else if (child.type === NodeTypes.FOR) {\n      // Do not hoist v-for single child because it has to be a block\n      walk(child, context, child.children.length === 1)\n    } else if (child.type === NodeTypes.IF) {\n      for (let i = 0; i < child.branches.length; i++) {\n        // Do not hoist v-if single child because it has to be a block\n        walk(\n          child.branches[i],\n          context,\n          child.branches[i].children.length === 1\n        )\n      }\n    }\n  }\n\n  if (hoistedCount && context.transformHoist) {\n    context.transformHoist(children, context, node)\n  }\n\n  // all children were hoisted - the entire children array is hoistable.\n  if (\n    hoistedCount &&\n    hoistedCount === originalCount &&\n    node.type === NodeTypes.ELEMENT &&\n    node.tagType === ElementTypes.ELEMENT &&\n    node.codegenNode &&\n    node.codegenNode.type === NodeTypes.VNODE_CALL &&\n    isArray(node.codegenNode.children)\n  ) {\n    node.codegenNode.children = context.hoist(\n      createArrayExpression(node.codegenNode.children)\n    )\n  }\n}\n\nexport function getConstantType(\n  node: TemplateChildNode | SimpleExpressionNode,\n  context: TransformContext\n): ConstantTypes {\n  const { constantCache } = context\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      if (node.tagType !== ElementTypes.ELEMENT) {\n        return ConstantTypes.NOT_CONSTANT\n      }\n      const cached = constantCache.get(node)\n      if (cached !== undefined) {\n        return cached\n      }\n      const codegenNode = node.codegenNode!\n      if (codegenNode.type !== NodeTypes.VNODE_CALL) {\n        return ConstantTypes.NOT_CONSTANT\n      }\n      if (\n        codegenNode.isBlock &&\n        node.tag !== 'svg' &&\n        node.tag !== 'foreignObject'\n      ) {\n        return ConstantTypes.NOT_CONSTANT\n      }\n      const flag = getPatchFlag(codegenNode)\n      if (!flag) {\n        let returnType = ConstantTypes.CAN_STRINGIFY\n\n        // Element itself has no patch flag. However we still need to check:\n\n        // 1. Even for a node with no patch flag, it is possible for it to contain\n        // non-hoistable expressions that refers to scope variables, e.g. compiler\n        // injected keys or cached event handlers. Therefore we need to always\n        // check the codegenNode's props to be sure.\n        const generatedPropsType = getGeneratedPropsConstantType(node, context)\n        if (generatedPropsType === ConstantTypes.NOT_CONSTANT) {\n          constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n          return ConstantTypes.NOT_CONSTANT\n        }\n        if (generatedPropsType < returnType) {\n          returnType = generatedPropsType\n        }\n\n        // 2. its children.\n        for (let i = 0; i < node.children.length; i++) {\n          const childType = getConstantType(node.children[i], context)\n          if (childType === ConstantTypes.NOT_CONSTANT) {\n            constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n            return ConstantTypes.NOT_CONSTANT\n          }\n          if (childType < returnType) {\n            returnType = childType\n          }\n        }\n\n        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\n        // type, check if any of the props can cause the type to be lowered\n        // we can skip can_patch because it's guaranteed by the absence of a\n        // patchFlag.\n        if (returnType > ConstantTypes.CAN_SKIP_PATCH) {\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i]\n            if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind' && p.exp) {\n              const expType = getConstantType(p.exp, context)\n              if (expType === ConstantTypes.NOT_CONSTANT) {\n                constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n                return ConstantTypes.NOT_CONSTANT\n              }\n              if (expType < returnType) {\n                returnType = expType\n              }\n            }\n          }\n        }\n\n        // only svg/foreignObject could be block here, however if they are\n        // static then they don't need to be blocks since there will be no\n        // nested updates.\n        if (codegenNode.isBlock) {\n          // except set custom directives.\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i]\n            if (p.type === NodeTypes.DIRECTIVE) {\n              constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n              return ConstantTypes.NOT_CONSTANT\n            }\n          }\n\n          context.removeHelper(OPEN_BLOCK)\n          context.removeHelper(\n            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)\n          )\n          codegenNode.isBlock = false\n          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))\n        }\n\n        constantCache.set(node, returnType)\n        return returnType\n      } else {\n        constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n        return ConstantTypes.NOT_CONSTANT\n      }\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return ConstantTypes.CAN_STRINGIFY\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n    case NodeTypes.IF_BRANCH:\n      return ConstantTypes.NOT_CONSTANT\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return getConstantType(node.content, context)\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return node.constType\n    case NodeTypes.COMPOUND_EXPRESSION:\n      let returnType = ConstantTypes.CAN_STRINGIFY\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i]\n        if (isString(child) || isSymbol(child)) {\n          continue\n        }\n        const childType = getConstantType(child, context)\n        if (childType === ConstantTypes.NOT_CONSTANT) {\n          return ConstantTypes.NOT_CONSTANT\n        } else if (childType < returnType) {\n          returnType = childType\n        }\n      }\n      return returnType\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return ConstantTypes.NOT_CONSTANT\n  }\n}\n\nconst allowHoistedHelperSet = new Set([\n  NORMALIZE_CLASS,\n  NORMALIZE_STYLE,\n  NORMALIZE_PROPS,\n  GUARD_REACTIVE_PROPS\n])\n\nfunction getConstantTypeOfHelperCall(\n  value: CallExpression,\n  context: TransformContext\n): ConstantTypes {\n  if (\n    value.type === NodeTypes.JS_CALL_EXPRESSION &&\n    !isString(value.callee) &&\n    allowHoistedHelperSet.has(value.callee)\n  ) {\n    const arg = value.arguments[0] as JSChildNode\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n      return getConstantType(arg, context)\n    } else if (arg.type === NodeTypes.JS_CALL_EXPRESSION) {\n      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`\n      return getConstantTypeOfHelperCall(arg, context)\n    }\n  }\n  return ConstantTypes.NOT_CONSTANT\n}\n\nfunction getGeneratedPropsConstantType(\n  node: PlainElementNode,\n  context: TransformContext\n): ConstantTypes {\n  let returnType = ConstantTypes.CAN_STRINGIFY\n  const props = getNodeProps(node)\n  if (props && props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n    const { properties } = props\n    for (let i = 0; i < properties.length; i++) {\n      const { key, value } = properties[i]\n      const keyType = getConstantType(key, context)\n      if (keyType === ConstantTypes.NOT_CONSTANT) {\n        return keyType\n      }\n      if (keyType < returnType) {\n        returnType = keyType\n      }\n      let valueType: ConstantTypes\n      if (value.type === NodeTypes.SIMPLE_EXPRESSION) {\n        valueType = getConstantType(value, context)\n      } else if (value.type === NodeTypes.JS_CALL_EXPRESSION) {\n        // some helper calls can be hoisted,\n        // such as the `normalizeProps` generated by the compiler for pre-normalize class,\n        // in this case we need to respect the ConstantType of the helper's arguments\n        valueType = getConstantTypeOfHelperCall(value, context)\n      } else {\n        valueType = ConstantTypes.NOT_CONSTANT\n      }\n      if (valueType === ConstantTypes.NOT_CONSTANT) {\n        return valueType\n      }\n      if (valueType < returnType) {\n        returnType = valueType\n      }\n    }\n  }\n  return returnType\n}\n\nfunction getNodeProps(node: PlainElementNode) {\n  const codegenNode = node.codegenNode!\n  if (codegenNode.type === NodeTypes.VNODE_CALL) {\n    return codegenNode.props\n  }\n}\n\nfunction getPatchFlag(node: VNodeCall): number | undefined {\n  const flag = node.patchFlag\n  return flag ? parseInt(flag, 10) : undefined\n}\n","import { TransformOptions } from './options'\nimport {\n  RootNode,\n  NodeTypes,\n  ParentNode,\n  TemplateChildNode,\n  ElementNode,\n  DirectiveNode,\n  Property,\n  ExpressionNode,\n  createSimpleExpression,\n  JSChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  CacheExpression,\n  createCacheExpression,\n  TemplateLiteral,\n  createVNodeCall,\n  ConstantTypes,\n  ArrayExpression\n} from './ast'\nimport {\n  isString,\n  isArray,\n  NOOP,\n  PatchFlags,\n  PatchFlagNames,\n  EMPTY_OBJ,\n  capitalize,\n  camelize\n} from '@vue/shared'\nimport { defaultOnError, defaultOnWarn } from './errors'\nimport {\n  TO_DISPLAY_STRING,\n  FRAGMENT,\n  helperNameMap,\n  CREATE_COMMENT\n} from './runtimeHelpers'\nimport { isVSlot, makeBlock } from './utils'\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic'\nimport { CompilerCompatOptions } from './compat/compatConfig'\n\n// There are two types of transforms:\n//\n// - NodeTransform:\n//   Transforms that operate directly on a ChildNode. NodeTransforms may mutate,\n//   replace or remove the node being processed.\nexport type NodeTransform = (\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) => void | (() => void) | (() => void)[]\n\n// - DirectiveTransform:\n//   Transforms that handles a single directive attribute on an element.\n//   It translates the raw directive into actual props for the VNode.\nexport type DirectiveTransform = (\n  dir: DirectiveNode,\n  node: ElementNode,\n  context: TransformContext,\n  // a platform specific compiler can import the base transform and augment\n  // it by passing in this optional argument.\n  augmentor?: (ret: DirectiveTransformResult) => DirectiveTransformResult\n) => DirectiveTransformResult\n\nexport interface DirectiveTransformResult {\n  props: Property[]\n  needRuntime?: boolean | symbol\n  ssrTagParts?: TemplateLiteral['elements']\n}\n\n// A structural directive transform is technically also a NodeTransform;\n// Only v-if and v-for fall into this category.\nexport type StructuralDirectiveTransform = (\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext\n) => void | (() => void)\n\nexport interface ImportItem {\n  exp: string | ExpressionNode\n  path: string\n}\n\nexport interface TransformContext\n  extends Required<\n      Omit<TransformOptions, 'filename' | keyof CompilerCompatOptions>\n    >,\n    CompilerCompatOptions {\n  selfName: string | null\n  root: RootNode\n  helpers: Map<symbol, number>\n  components: Set<string>\n  directives: Set<string>\n  hoists: (JSChildNode | null)[]\n  imports: ImportItem[]\n  temps: number\n  cached: number\n  identifiers: { [name: string]: number | undefined }\n  scopes: {\n    vFor: number\n    vSlot: number\n    vPre: number\n    vOnce: number\n  }\n  parent: ParentNode | null\n  childIndex: number\n  currentNode: RootNode | TemplateChildNode | null\n  inVOnce: boolean\n  helper<T extends symbol>(name: T): T\n  removeHelper<T extends symbol>(name: T): void\n  helperString(name: symbol): string\n  replaceNode(node: TemplateChildNode): void\n  removeNode(node?: TemplateChildNode): void\n  onNodeRemoved(): void\n  addIdentifiers(exp: ExpressionNode | string): void\n  removeIdentifiers(exp: ExpressionNode | string): void\n  hoist(exp: string | JSChildNode | ArrayExpression): SimpleExpressionNode\n  cache<T extends JSChildNode>(exp: T, isVNode?: boolean): CacheExpression | T\n  constantCache: Map<TemplateChildNode, ConstantTypes>\n\n  // 2.x Compat only\n  filters?: Set<string>\n}\n\nexport function createTransformContext(\n  root: RootNode,\n  {\n    filename = '',\n    prefixIdentifiers = false,\n    hoistStatic = false,\n    cacheHandlers = false,\n    nodeTransforms = [],\n    directiveTransforms = {},\n    transformHoist = null,\n    isBuiltInComponent = NOOP,\n    isCustomElement = NOOP,\n    expressionPlugins = [],\n    scopeId = null,\n    slotted = true,\n    ssr = false,\n    inSSR = false,\n    ssrCssVars = ``,\n    bindingMetadata = EMPTY_OBJ,\n    inline = false,\n    isTS = false,\n    onError = defaultOnError,\n    onWarn = defaultOnWarn,\n    compatConfig\n  }: TransformOptions\n): TransformContext {\n  const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/)\n  const context: TransformContext = {\n    // options\n    selfName: nameMatch && capitalize(camelize(nameMatch[1])),\n    prefixIdentifiers,\n    hoistStatic,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    transformHoist,\n    isBuiltInComponent,\n    isCustomElement,\n    expressionPlugins,\n    scopeId,\n    slotted,\n    ssr,\n    inSSR,\n    ssrCssVars,\n    bindingMetadata,\n    inline,\n    isTS,\n    onError,\n    onWarn,\n    compatConfig,\n\n    // state\n    root,\n    helpers: new Map(),\n    components: new Set(),\n    directives: new Set(),\n    hoists: [],\n    imports: [],\n    constantCache: new Map(),\n    temps: 0,\n    cached: 0,\n    identifiers: Object.create(null),\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    parent: null,\n    currentNode: root,\n    childIndex: 0,\n    inVOnce: false,\n\n    // methods\n    helper(name) {\n      const count = context.helpers.get(name) || 0\n      context.helpers.set(name, count + 1)\n      return name\n    },\n    removeHelper(name) {\n      const count = context.helpers.get(name)\n      if (count) {\n        const currentCount = count - 1\n        if (!currentCount) {\n          context.helpers.delete(name)\n        } else {\n          context.helpers.set(name, currentCount)\n        }\n      }\n    },\n    helperString(name) {\n      return `_${helperNameMap[context.helper(name)]}`\n    },\n    replaceNode(node) {\n      /* istanbul ignore if */\n      if (__DEV__) {\n        if (!context.currentNode) {\n          throw new Error(`Node being replaced is already removed.`)\n        }\n        if (!context.parent) {\n          throw new Error(`Cannot replace root node.`)\n        }\n      }\n      context.parent!.children[context.childIndex] = context.currentNode = node\n    },\n    removeNode(node) {\n      if (__DEV__ && !context.parent) {\n        throw new Error(`Cannot remove root node.`)\n      }\n      const list = context.parent!.children\n      const removalIndex = node\n        ? list.indexOf(node)\n        : context.currentNode\n        ? context.childIndex\n        : -1\n      /* istanbul ignore if */\n      if (__DEV__ && removalIndex < 0) {\n        throw new Error(`node being removed is not a child of current parent`)\n      }\n      if (!node || node === context.currentNode) {\n        // current node removed\n        context.currentNode = null\n        context.onNodeRemoved()\n      } else {\n        // sibling node removed\n        if (context.childIndex > removalIndex) {\n          context.childIndex--\n          context.onNodeRemoved()\n        }\n      }\n      context.parent!.children.splice(removalIndex, 1)\n    },\n    onNodeRemoved: () => {},\n    addIdentifiers(exp) {\n      // identifier tracking only happens in non-browser builds.\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          addId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(addId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          addId(exp.content)\n        }\n      }\n    },\n    removeIdentifiers(exp) {\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          removeId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(removeId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          removeId(exp.content)\n        }\n      }\n    },\n    hoist(exp) {\n      if (isString(exp)) exp = createSimpleExpression(exp)\n      context.hoists.push(exp)\n      const identifier = createSimpleExpression(\n        `_hoisted_${context.hoists.length}`,\n        false,\n        exp.loc,\n        ConstantTypes.CAN_HOIST\n      )\n      identifier.hoisted = exp\n      return identifier\n    },\n    cache(exp, isVNode = false) {\n      return createCacheExpression(context.cached++, exp, isVNode)\n    }\n  }\n\n  if (__COMPAT__) {\n    context.filters = new Set()\n  }\n\n  function addId(id: string) {\n    const { identifiers } = context\n    if (identifiers[id] === undefined) {\n      identifiers[id] = 0\n    }\n    identifiers[id]!++\n  }\n\n  function removeId(id: string) {\n    context.identifiers[id]!--\n  }\n\n  return context\n}\n\nexport function transform(root: RootNode, options: TransformOptions) {\n  const context = createTransformContext(root, options)\n  traverseNode(root, context)\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }\n  if (!options.ssr) {\n    createRootCodegen(root, context)\n  }\n  // finalize meta information\n  root.helpers = [...context.helpers.keys()]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.imports = context.imports\n  root.hoists = context.hoists\n  root.temps = context.temps\n  root.cached = context.cached\n\n  if (__COMPAT__) {\n    root.filters = [...context.filters!]\n  }\n}\n\nfunction createRootCodegen(root: RootNode, context: TransformContext) {\n  const { helper } = context\n  const { children } = root\n  if (children.length === 1) {\n    const child = children[0]\n    // if the single child is an element, turn it into a block.\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\n      // single element root is never hoisted so codegenNode will never be\n      // SimpleExpressionNode\n      const codegenNode = child.codegenNode\n      if (codegenNode.type === NodeTypes.VNODE_CALL) {\n        makeBlock(codegenNode, context)\n      }\n      root.codegenNode = codegenNode\n    } else {\n      // - single <slot/>, IfNode, ForNode: already blocks.\n      // - single text node: always patched.\n      // root codegen falls through via genNode()\n      root.codegenNode = child\n    }\n  } else if (children.length > 1) {\n    // root has multiple nodes - return a fragment block.\n    let patchFlag = PatchFlags.STABLE_FRAGMENT\n    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\n    // check if the fragment actually contains a single valid child with\n    // the rest being comments\n    if (\n      __DEV__ &&\n      children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\n    ) {\n      patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\n      patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\n    }\n    root.codegenNode = createVNodeCall(\n      context,\n      helper(FRAGMENT),\n      undefined,\n      root.children,\n      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\n      undefined,\n      undefined,\n      true,\n      undefined,\n      false /* isComponent */\n    )\n  } else {\n    // no children = noop. codegen will return null.\n  }\n}\n\nexport function traverseChildren(\n  parent: ParentNode,\n  context: TransformContext\n) {\n  let i = 0\n  const nodeRemoved = () => {\n    i--\n  }\n  for (; i < parent.children.length; i++) {\n    const child = parent.children[i]\n    if (isString(child)) continue\n    context.parent = parent\n    context.childIndex = i\n    context.onNodeRemoved = nodeRemoved\n    traverseNode(child, context)\n  }\n}\n\nexport function traverseNode(\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) {\n  context.currentNode = node\n  // apply transform plugins\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    const onExit = nodeTransforms[i](node, context)\n    if (onExit) {\n      if (isArray(onExit)) {\n        exitFns.push(...onExit)\n      } else {\n        exitFns.push(onExit)\n      }\n    }\n    if (!context.currentNode) {\n      // node was removed\n      return\n    } else {\n      // node may have been replaced\n      node = context.currentNode\n    }\n  }\n\n  switch (node.type) {\n    case NodeTypes.COMMENT:\n      if (!context.ssr) {\n        // inject import for the Comment symbol, which is needed for creating\n        // comment nodes with `createVNode`\n        context.helper(CREATE_COMMENT)\n      }\n      break\n    case NodeTypes.INTERPOLATION:\n      // no need to traverse, but we need to inject toString helper\n      if (!context.ssr) {\n        context.helper(TO_DISPLAY_STRING)\n      }\n      break\n\n    // for container types, further traverse downwards\n    case NodeTypes.IF:\n      for (let i = 0; i < node.branches.length; i++) {\n        traverseNode(node.branches[i], context)\n      }\n      break\n    case NodeTypes.IF_BRANCH:\n    case NodeTypes.FOR:\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      traverseChildren(node, context)\n      break\n  }\n\n  // exit transforms\n  context.currentNode = node\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n\nexport function createStructuralDirectiveTransform(\n  name: string | RegExp,\n  fn: StructuralDirectiveTransform\n): NodeTransform {\n  const matches = isString(name)\n    ? (n: string) => n === name\n    : (n: string) => name.test(n)\n\n  return (node, context) => {\n    if (node.type === NodeTypes.ELEMENT) {\n      const { props } = node\n      // structural directive transforms are not concerned with slots\n      // as they are handled separately in vSlot.ts\n      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {\n        return\n      }\n      const exitFns = []\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i]\n        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {\n          // structural directives are removed to avoid infinite recursion\n          // also we remove them *before* applying so that it can further\n          // traverse itself in case it moves the node around\n          props.splice(i, 1)\n          i--\n          const onExit = fn(node, prop, context)\n          if (onExit) exitFns.push(onExit)\n        }\n      }\n      return exitFns\n    }\n  }\n}\n","import { CodegenOptions } from './options'\nimport {\n  RootNode,\n  TemplateChildNode,\n  TextNode,\n  CommentNode,\n  ExpressionNode,\n  NodeTypes,\n  JSChildNode,\n  CallExpression,\n  ArrayExpression,\n  ObjectExpression,\n  Position,\n  InterpolationNode,\n  CompoundExpressionNode,\n  SimpleExpressionNode,\n  FunctionExpression,\n  ConditionalExpression,\n  CacheExpression,\n  locStub,\n  SSRCodegenNode,\n  TemplateLiteral,\n  IfStatement,\n  AssignmentExpression,\n  ReturnStatement,\n  VNodeCall,\n  SequenceExpression\n} from './ast'\nimport { SourceMapGenerator, RawSourceMap } from 'source-map'\nimport {\n  advancePositionWithMutation,\n  assert,\n  getVNodeBlockHelper,\n  getVNodeHelper,\n  isSimpleIdentifier,\n  toValidAssetId\n} from './utils'\nimport { isString, isArray, isSymbol } from '@vue/shared'\nimport {\n  helperNameMap,\n  TO_DISPLAY_STRING,\n  CREATE_VNODE,\n  RESOLVE_COMPONENT,\n  RESOLVE_DIRECTIVE,\n  SET_BLOCK_TRACKING,\n  CREATE_COMMENT,\n  CREATE_TEXT,\n  PUSH_SCOPE_ID,\n  POP_SCOPE_ID,\n  WITH_DIRECTIVES,\n  CREATE_ELEMENT_VNODE,\n  OPEN_BLOCK,\n  CREATE_STATIC,\n  WITH_CTX,\n  RESOLVE_FILTER\n} from './runtimeHelpers'\nimport { ImportItem } from './transform'\n\nconst PURE_ANNOTATION = `/*#__PURE__*/`\n\nconst aliasHelper = (s: symbol) => `${helperNameMap[s]}: _${helperNameMap[s]}`\n\ntype CodegenNode = TemplateChildNode | JSChildNode | SSRCodegenNode\n\nexport interface CodegenResult {\n  code: string\n  preamble: string\n  ast: RootNode\n  map?: RawSourceMap\n}\n\nexport interface CodegenContext\n  extends Omit<Required<CodegenOptions>, 'bindingMetadata' | 'inline'> {\n  source: string\n  code: string\n  line: number\n  column: number\n  offset: number\n  indentLevel: number\n  pure: boolean\n  map?: SourceMapGenerator\n  helper(key: symbol): string\n  push(code: string, node?: CodegenNode): void\n  indent(): void\n  deindent(withoutNewLine?: boolean): void\n  newline(): void\n}\n\nfunction createCodegenContext(\n  ast: RootNode,\n  {\n    mode = 'function',\n    prefixIdentifiers = mode === 'module',\n    sourceMap = false,\n    filename = `template.vue.html`,\n    scopeId = null,\n    optimizeImports = false,\n    runtimeGlobalName = `Vue`,\n    runtimeModuleName = `vue`,\n    ssrRuntimeModuleName = 'vue/server-renderer',\n    ssr = false,\n    isTS = false,\n    inSSR = false\n  }: CodegenOptions\n): CodegenContext {\n  const context: CodegenContext = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    scopeId,\n    optimizeImports,\n    runtimeGlobalName,\n    runtimeModuleName,\n    ssrRuntimeModuleName,\n    ssr,\n    isTS,\n    inSSR,\n    source: ast.loc.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n    pure: false,\n    map: undefined,\n    helper(key) {\n      return `_${helperNameMap[key]}`\n    },\n    push(code, node) {\n      context.code += code\n      if (!__BROWSER__ && context.map) {\n        if (node) {\n          let name\n          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {\n            const content = node.content.replace(/^_ctx\\./, '')\n            if (content !== node.content && isSimpleIdentifier(content)) {\n              name = content\n            }\n          }\n          addMapping(node.loc.start, name)\n        }\n        advancePositionWithMutation(context, code)\n        if (node && node.loc !== locStub) {\n          addMapping(node.loc.end)\n        }\n      }\n    },\n    indent() {\n      newline(++context.indentLevel)\n    },\n    deindent(withoutNewLine = false) {\n      if (withoutNewLine) {\n        --context.indentLevel\n      } else {\n        newline(--context.indentLevel)\n      }\n    },\n    newline() {\n      newline(context.indentLevel)\n    }\n  }\n\n  function newline(n: number) {\n    context.push('\\n' + `  `.repeat(n))\n  }\n\n  function addMapping(loc: Position, name?: string) {\n    context.map!.addMapping({\n      name,\n      source: context.filename,\n      original: {\n        line: loc.line,\n        column: loc.column - 1 // source-map column is 0 based\n      },\n      generated: {\n        line: context.line,\n        column: context.column - 1\n      }\n    })\n  }\n\n  if (!__BROWSER__ && sourceMap) {\n    // lazy require source-map implementation, only in non-browser builds\n    context.map = new SourceMapGenerator()\n    context.map!.setSourceContent(filename, context.source)\n  }\n\n  return context\n}\n\nexport function generate(\n  ast: RootNode,\n  options: CodegenOptions & {\n    onContextCreated?: (context: CodegenContext) => void\n  } = {}\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  if (options.onContextCreated) options.onContextCreated(context)\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context\n\n  const hasHelpers = ast.helpers.length > 0\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\n  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'\n  const isSetupInlined = !__BROWSER__ && !!options.inline\n\n  // preambles\n  // in setup() inline mode, the preamble is generated in a sub context\n  // and returned separately.\n  const preambleContext = isSetupInlined\n    ? createCodegenContext(ast, options)\n    : context\n  if (!__BROWSER__ && mode === 'module') {\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\n  } else {\n    genFunctionPreamble(ast, preambleContext)\n  }\n  // enter render function\n  const functionName = ssr ? `ssrRender` : `render`\n  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']\n  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {\n    // binding optimization args\n    args.push('$props', '$setup', '$data', '$options')\n  }\n  const signature =\n    !__BROWSER__ && options.isTS\n      ? args.map(arg => `${arg}: any`).join(',')\n      : args.join(', ')\n\n  if (isSetupInlined) {\n    push(`(${signature}) => {`)\n  } else {\n    push(`function ${functionName}(${signature}) {`)\n  }\n  indent()\n\n  if (useWithBlock) {\n    push(`with (_ctx) {`)\n    indent()\n    // function mode const declarations should be inside with block\n    // also they should be renamed to avoid collision with user properties\n    if (hasHelpers) {\n      push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`)\n      push(`\\n`)\n      newline()\n    }\n  }\n\n  // generate asset resolution statements\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context)\n    if (ast.directives.length || ast.temps > 0) {\n      newline()\n    }\n  }\n  if (ast.directives.length) {\n    genAssets(ast.directives, 'directive', context)\n    if (ast.temps > 0) {\n      newline()\n    }\n  }\n  if (__COMPAT__ && ast.filters && ast.filters.length) {\n    newline()\n    genAssets(ast.filters, 'filter', context)\n    newline()\n  }\n\n  if (ast.temps > 0) {\n    push(`let `)\n    for (let i = 0; i < ast.temps; i++) {\n      push(`${i > 0 ? `, ` : ``}_temp${i}`)\n    }\n  }\n  if (ast.components.length || ast.directives.length || ast.temps) {\n    push(`\\n`)\n    newline()\n  }\n\n  // generate the VNode tree expression\n  if (!ssr) {\n    push(`return `)\n  }\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context)\n  } else {\n    push(`null`)\n  }\n\n  if (useWithBlock) {\n    deindent()\n    push(`}`)\n  }\n\n  deindent()\n  push(`}`)\n\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    // SourceMapGenerator does have toJSON() method but it's not in the types\n    map: context.map ? (context.map as any).toJSON() : undefined\n  }\n}\n\nfunction genFunctionPreamble(ast: RootNode, context: CodegenContext) {\n  const {\n    ssr,\n    prefixIdentifiers,\n    push,\n    newline,\n    runtimeModuleName,\n    runtimeGlobalName,\n    ssrRuntimeModuleName\n  } = context\n  const VueBinding =\n    !__BROWSER__ && ssr\n      ? `require(${JSON.stringify(runtimeModuleName)})`\n      : runtimeGlobalName\n  // Generate const declaration for helpers\n  // In prefix mode, we place the const declaration at top so it's done\n  // only once; But if we not prefixing, we place the declaration inside the\n  // with block so it doesn't incur the `in` check cost for every helper access.\n  if (ast.helpers.length > 0) {\n    if (!__BROWSER__ && prefixIdentifiers) {\n      push(\n        `const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\\n`\n      )\n    } else {\n      // \"with\" mode.\n      // save Vue in a separate variable to avoid collision\n      push(`const _Vue = ${VueBinding}\\n`)\n      // in \"with\" mode, helpers are declared inside the with block to avoid\n      // has check cost, but hoists are lifted out of the function - we need\n      // to provide the helper here.\n      if (ast.hoists.length) {\n        const staticHelpers = [\n          CREATE_VNODE,\n          CREATE_ELEMENT_VNODE,\n          CREATE_COMMENT,\n          CREATE_TEXT,\n          CREATE_STATIC\n        ]\n          .filter(helper => ast.helpers.includes(helper))\n          .map(aliasHelper)\n          .join(', ')\n        push(`const { ${staticHelpers} } = _Vue\\n`)\n      }\n    }\n  }\n  // generate variables for ssr helpers\n  if (!__BROWSER__ && ast.ssrHelpers && ast.ssrHelpers.length) {\n    // ssr guarantees prefixIdentifier: true\n    push(\n      `const { ${ast.ssrHelpers\n        .map(aliasHelper)\n        .join(', ')} } = require(\"${ssrRuntimeModuleName}\")\\n`\n    )\n  }\n  genHoists(ast.hoists, context)\n  newline()\n  push(`return `)\n}\n\nfunction genModulePreamble(\n  ast: RootNode,\n  context: CodegenContext,\n  genScopeId: boolean,\n  inline?: boolean\n) {\n  const {\n    push,\n    newline,\n    optimizeImports,\n    runtimeModuleName,\n    ssrRuntimeModuleName\n  } = context\n\n  if (genScopeId && ast.hoists.length) {\n    ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)\n  }\n\n  // generate import statements for helpers\n  if (ast.helpers.length) {\n    if (optimizeImports) {\n      // when bundled with webpack with code-split, calling an import binding\n      // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,\n      // incurring both payload size increase and potential perf overhead.\n      // therefore we assign the imports to variables (which is a constant ~50b\n      // cost per-component instead of scaling with template size)\n      push(\n        `import { ${ast.helpers\n          .map(s => helperNameMap[s])\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\n      )\n      push(\n        `\\n// Binding optimization for webpack code-split\\nconst ${ast.helpers\n          .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)\n          .join(', ')}\\n`\n      )\n    } else {\n      push(\n        `import { ${ast.helpers\n          .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\n      )\n    }\n  }\n\n  if (ast.ssrHelpers && ast.ssrHelpers.length) {\n    push(\n      `import { ${ast.ssrHelpers\n        .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\n        .join(', ')} } from \"${ssrRuntimeModuleName}\"\\n`\n    )\n  }\n\n  if (ast.imports.length) {\n    genImports(ast.imports, context)\n    newline()\n  }\n\n  genHoists(ast.hoists, context)\n  newline()\n\n  if (!inline) {\n    push(`export `)\n  }\n}\n\nfunction genAssets(\n  assets: string[],\n  type: 'component' | 'directive' | 'filter',\n  { helper, push, newline, isTS }: CodegenContext\n) {\n  const resolver = helper(\n    __COMPAT__ && type === 'filter'\n      ? RESOLVE_FILTER\n      : type === 'component'\n      ? RESOLVE_COMPONENT\n      : RESOLVE_DIRECTIVE\n  )\n  for (let i = 0; i < assets.length; i++) {\n    let id = assets[i]\n    // potential component implicit self-reference inferred from SFC filename\n    const maybeSelfReference = id.endsWith('__self')\n    if (maybeSelfReference) {\n      id = id.slice(0, -6)\n    }\n    push(\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${\n        maybeSelfReference ? `, true` : ``\n      })${isTS ? `!` : ``}`\n    )\n    if (i < assets.length - 1) {\n      newline()\n    }\n  }\n}\n\nfunction genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) {\n  if (!hoists.length) {\n    return\n  }\n  context.pure = true\n  const { push, newline, helper, scopeId, mode } = context\n  const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'\n  newline()\n\n  // generate inlined withScopeId helper\n  if (genScopeId) {\n    push(\n      `const _withScopeId = n => (${helper(\n        PUSH_SCOPE_ID\n      )}(\"${scopeId}\"),n=n(),${helper(POP_SCOPE_ID)}(),n)`\n    )\n    newline()\n  }\n\n  for (let i = 0; i < hoists.length; i++) {\n    const exp = hoists[i]\n    if (exp) {\n      const needScopeIdWrapper = genScopeId && exp.type === NodeTypes.VNODE_CALL\n      push(\n        `const _hoisted_${i + 1} = ${\n          needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``\n        }`\n      )\n      genNode(exp, context)\n      if (needScopeIdWrapper) {\n        push(`)`)\n      }\n      newline()\n    }\n  }\n\n  context.pure = false\n}\n\nfunction genImports(importsOptions: ImportItem[], context: CodegenContext) {\n  if (!importsOptions.length) {\n    return\n  }\n  importsOptions.forEach(imports => {\n    context.push(`import `)\n    genNode(imports.exp, context)\n    context.push(` from '${imports.path}'`)\n    context.newline()\n  })\n}\n\nfunction isText(n: string | CodegenNode) {\n  return (\n    isString(n) ||\n    n.type === NodeTypes.SIMPLE_EXPRESSION ||\n    n.type === NodeTypes.TEXT ||\n    n.type === NodeTypes.INTERPOLATION ||\n    n.type === NodeTypes.COMPOUND_EXPRESSION\n  )\n}\n\nfunction genNodeListAsArray(\n  nodes: (string | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext\n) {\n  const multilines =\n    nodes.length > 3 ||\n    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))\n  context.push(`[`)\n  multilines && context.indent()\n  genNodeList(nodes, context, multilines)\n  multilines && context.deindent()\n  context.push(`]`)\n}\n\nfunction genNodeList(\n  nodes: (string | symbol | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext,\n  multilines: boolean = false,\n  comma: boolean = true\n) {\n  const { push, newline } = context\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]\n    if (isString(node)) {\n      push(node)\n    } else if (isArray(node)) {\n      genNodeListAsArray(node, context)\n    } else {\n      genNode(node, context)\n    }\n    if (i < nodes.length - 1) {\n      if (multilines) {\n        comma && push(',')\n        newline()\n      } else {\n        comma && push(', ')\n      }\n    }\n  }\n}\n\nfunction genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\n  if (isString(node)) {\n    context.push(node)\n    return\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node))\n    return\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      __DEV__ &&\n        assert(\n          node.codegenNode != null,\n          `Codegen node is missing for element/if/for node. ` +\n            `Apply appropriate transforms first.`\n        )\n      genNode(node.codegenNode!, context)\n      break\n    case NodeTypes.TEXT:\n      genText(node, context)\n      break\n    case NodeTypes.SIMPLE_EXPRESSION:\n      genExpression(node, context)\n      break\n    case NodeTypes.INTERPOLATION:\n      genInterpolation(node, context)\n      break\n    case NodeTypes.TEXT_CALL:\n      genNode(node.codegenNode, context)\n      break\n    case NodeTypes.COMPOUND_EXPRESSION:\n      genCompoundExpression(node, context)\n      break\n    case NodeTypes.COMMENT:\n      genComment(node, context)\n      break\n    case NodeTypes.VNODE_CALL:\n      genVNodeCall(node, context)\n      break\n\n    case NodeTypes.JS_CALL_EXPRESSION:\n      genCallExpression(node, context)\n      break\n    case NodeTypes.JS_OBJECT_EXPRESSION:\n      genObjectExpression(node, context)\n      break\n    case NodeTypes.JS_ARRAY_EXPRESSION:\n      genArrayExpression(node, context)\n      break\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\n      genFunctionExpression(node, context)\n      break\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\n      genConditionalExpression(node, context)\n      break\n    case NodeTypes.JS_CACHE_EXPRESSION:\n      genCacheExpression(node, context)\n      break\n    case NodeTypes.JS_BLOCK_STATEMENT:\n      genNodeList(node.body, context, true, false)\n      break\n\n    // SSR only types\n    case NodeTypes.JS_TEMPLATE_LITERAL:\n      !__BROWSER__ && genTemplateLiteral(node, context)\n      break\n    case NodeTypes.JS_IF_STATEMENT:\n      !__BROWSER__ && genIfStatement(node, context)\n      break\n    case NodeTypes.JS_ASSIGNMENT_EXPRESSION:\n      !__BROWSER__ && genAssignmentExpression(node, context)\n      break\n    case NodeTypes.JS_SEQUENCE_EXPRESSION:\n      !__BROWSER__ && genSequenceExpression(node, context)\n      break\n    case NodeTypes.JS_RETURN_STATEMENT:\n      !__BROWSER__ && genReturnStatement(node, context)\n      break\n\n    /* istanbul ignore next */\n    case NodeTypes.IF_BRANCH:\n      // noop\n      break\n    default:\n      if (__DEV__) {\n        assert(false, `unhandled codegen node type: ${(node as any).type}`)\n        // make sure we exhaust all possible types\n        const exhaustiveCheck: never = node\n        return exhaustiveCheck\n      }\n  }\n}\n\nfunction genText(\n  node: TextNode | SimpleExpressionNode,\n  context: CodegenContext\n) {\n  context.push(JSON.stringify(node.content), node)\n}\n\nfunction genExpression(node: SimpleExpressionNode, context: CodegenContext) {\n  const { content, isStatic } = node\n  context.push(isStatic ? JSON.stringify(content) : content, node)\n}\n\nfunction genInterpolation(node: InterpolationNode, context: CodegenContext) {\n  const { push, helper, pure } = context\n  if (pure) push(PURE_ANNOTATION)\n  push(`${helper(TO_DISPLAY_STRING)}(`)\n  genNode(node.content, context)\n  push(`)`)\n}\n\nfunction genCompoundExpression(\n  node: CompoundExpressionNode,\n  context: CodegenContext\n) {\n  for (let i = 0; i < node.children!.length; i++) {\n    const child = node.children![i]\n    if (isString(child)) {\n      context.push(child)\n    } else {\n      genNode(child, context)\n    }\n  }\n}\n\nfunction genExpressionAsPropertyKey(\n  node: ExpressionNode,\n  context: CodegenContext\n) {\n  const { push } = context\n  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {\n    push(`[`)\n    genCompoundExpression(node, context)\n    push(`]`)\n  } else if (node.isStatic) {\n    // only quote keys if necessary\n    const text = isSimpleIdentifier(node.content)\n      ? node.content\n      : JSON.stringify(node.content)\n    push(text, node)\n  } else {\n    push(`[${node.content}]`, node)\n  }\n}\n\nfunction genComment(node: CommentNode, context: CodegenContext) {\n  const { push, helper, pure } = context\n  if (pure) {\n    push(PURE_ANNOTATION)\n  }\n  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node)\n}\n\nfunction genVNodeCall(node: VNodeCall, context: CodegenContext) {\n  const { push, helper, pure } = context\n  const {\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent\n  } = node\n  if (directives) {\n    push(helper(WITH_DIRECTIVES) + `(`)\n  }\n  if (isBlock) {\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)\n  }\n  if (pure) {\n    push(PURE_ANNOTATION)\n  }\n  const callHelper: symbol = isBlock\n    ? getVNodeBlockHelper(context.inSSR, isComponent)\n    : getVNodeHelper(context.inSSR, isComponent)\n  push(helper(callHelper) + `(`, node)\n  genNodeList(\n    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),\n    context\n  )\n  push(`)`)\n  if (isBlock) {\n    push(`)`)\n  }\n  if (directives) {\n    push(`, `)\n    genNode(directives, context)\n    push(`)`)\n  }\n}\n\nfunction genNullableArgs(args: any[]): CallExpression['arguments'] {\n  let i = args.length\n  while (i--) {\n    if (args[i] != null) break\n  }\n  return args.slice(0, i + 1).map(arg => arg || `null`)\n}\n\n// JavaScript\nfunction genCallExpression(node: CallExpression, context: CodegenContext) {\n  const { push, helper, pure } = context\n  const callee = isString(node.callee) ? node.callee : helper(node.callee)\n  if (pure) {\n    push(PURE_ANNOTATION)\n  }\n  push(callee + `(`, node)\n  genNodeList(node.arguments, context)\n  push(`)`)\n}\n\nfunction genObjectExpression(node: ObjectExpression, context: CodegenContext) {\n  const { push, indent, deindent, newline } = context\n  const { properties } = node\n  if (!properties.length) {\n    push(`{}`, node)\n    return\n  }\n  const multilines =\n    properties.length > 1 ||\n    ((!__BROWSER__ || __DEV__) &&\n      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))\n  push(multilines ? `{` : `{ `)\n  multilines && indent()\n  for (let i = 0; i < properties.length; i++) {\n    const { key, value } = properties[i]\n    // key\n    genExpressionAsPropertyKey(key, context)\n    push(`: `)\n    // value\n    genNode(value, context)\n    if (i < properties.length - 1) {\n      // will only reach this if it's multilines\n      push(`,`)\n      newline()\n    }\n  }\n  multilines && deindent()\n  push(multilines ? `}` : ` }`)\n}\n\nfunction genArrayExpression(node: ArrayExpression, context: CodegenContext) {\n  genNodeListAsArray(node.elements as CodegenNode[], context)\n}\n\nfunction genFunctionExpression(\n  node: FunctionExpression,\n  context: CodegenContext\n) {\n  const { push, indent, deindent } = context\n  const { params, returns, body, newline, isSlot } = node\n  if (isSlot) {\n    // wrap slot functions with owner context\n    push(`_${helperNameMap[WITH_CTX]}(`)\n  }\n  push(`(`, node)\n  if (isArray(params)) {\n    genNodeList(params, context)\n  } else if (params) {\n    genNode(params, context)\n  }\n  push(`) => `)\n  if (newline || body) {\n    push(`{`)\n    indent()\n  }\n  if (returns) {\n    if (newline) {\n      push(`return `)\n    }\n    if (isArray(returns)) {\n      genNodeListAsArray(returns, context)\n    } else {\n      genNode(returns, context)\n    }\n  } else if (body) {\n    genNode(body, context)\n  }\n  if (newline || body) {\n    deindent()\n    push(`}`)\n  }\n  if (isSlot) {\n    if (__COMPAT__ && node.isNonScopedSlot) {\n      push(`, undefined, true`)\n    }\n    push(`)`)\n  }\n}\n\nfunction genConditionalExpression(\n  node: ConditionalExpression,\n  context: CodegenContext\n) {\n  const { test, consequent, alternate, newline: needNewline } = node\n  const { push, indent, deindent, newline } = context\n  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {\n    const needsParens = !isSimpleIdentifier(test.content)\n    needsParens && push(`(`)\n    genExpression(test, context)\n    needsParens && push(`)`)\n  } else {\n    push(`(`)\n    genNode(test, context)\n    push(`)`)\n  }\n  needNewline && indent()\n  context.indentLevel++\n  needNewline || push(` `)\n  push(`? `)\n  genNode(consequent, context)\n  context.indentLevel--\n  needNewline && newline()\n  needNewline || push(` `)\n  push(`: `)\n  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n  if (!isNested) {\n    context.indentLevel++\n  }\n  genNode(alternate, context)\n  if (!isNested) {\n    context.indentLevel--\n  }\n  needNewline && deindent(true /* without newline */)\n}\n\nfunction genCacheExpression(node: CacheExpression, context: CodegenContext) {\n  const { push, helper, indent, deindent, newline } = context\n  push(`_cache[${node.index}] || (`)\n  if (node.isVNode) {\n    indent()\n    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)\n    newline()\n  }\n  push(`_cache[${node.index}] = `)\n  genNode(node.value, context)\n  if (node.isVNode) {\n    push(`,`)\n    newline()\n    push(`${helper(SET_BLOCK_TRACKING)}(1),`)\n    newline()\n    push(`_cache[${node.index}]`)\n    deindent()\n  }\n  push(`)`)\n}\n\nfunction genTemplateLiteral(node: TemplateLiteral, context: CodegenContext) {\n  const { push, indent, deindent } = context\n  push('`')\n  const l = node.elements.length\n  const multilines = l > 3\n  for (let i = 0; i < l; i++) {\n    const e = node.elements[i]\n    if (isString(e)) {\n      push(e.replace(/(`|\\$|\\\\)/g, '\\\\$1'))\n    } else {\n      push('${')\n      if (multilines) indent()\n      genNode(e, context)\n      if (multilines) deindent()\n      push('}')\n    }\n  }\n  push('`')\n}\n\nfunction genIfStatement(node: IfStatement, context: CodegenContext) {\n  const { push, indent, deindent } = context\n  const { test, consequent, alternate } = node\n  push(`if (`)\n  genNode(test, context)\n  push(`) {`)\n  indent()\n  genNode(consequent, context)\n  deindent()\n  push(`}`)\n  if (alternate) {\n    push(` else `)\n    if (alternate.type === NodeTypes.JS_IF_STATEMENT) {\n      genIfStatement(alternate, context)\n    } else {\n      push(`{`)\n      indent()\n      genNode(alternate, context)\n      deindent()\n      push(`}`)\n    }\n  }\n}\n\nfunction genAssignmentExpression(\n  node: AssignmentExpression,\n  context: CodegenContext\n) {\n  genNode(node.left, context)\n  context.push(` = `)\n  genNode(node.right, context)\n}\n\nfunction genSequenceExpression(\n  node: SequenceExpression,\n  context: CodegenContext\n) {\n  context.push(`(`)\n  genNodeList(node.expressions, context)\n  context.push(`)`)\n}\n\nfunction genReturnStatement(\n  { returns }: ReturnStatement,\n  context: CodegenContext\n) {\n  context.push(`return `)\n  if (isArray(returns)) {\n    genNodeListAsArray(returns, context)\n  } else {\n    genNode(returns, context)\n  }\n}\n","// should only use types from @babel/types\n// do not import runtime methods\nimport type {\n  Identifier,\n  Node,\n  Function,\n  ObjectProperty,\n  BlockStatement,\n  Program\n} from '@babel/types'\nimport { walk } from 'estree-walker'\n\nexport function walkIdentifiers(\n  root: Node,\n  onIdentifier: (\n    node: Identifier,\n    parent: Node,\n    parentStack: Node[],\n    isReference: boolean,\n    isLocal: boolean\n  ) => void,\n  includeAll = false,\n  parentStack: Node[] = [],\n  knownIds: Record<string, number> = Object.create(null)\n) {\n  if (__BROWSER__) {\n    return\n  }\n\n  const rootExp =\n    root.type === 'Program' &&\n    root.body[0].type === 'ExpressionStatement' &&\n    root.body[0].expression\n\n  ;(walk as any)(root, {\n    enter(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\n      parent && parentStack.push(parent)\n      if (\n        parent &&\n        parent.type.startsWith('TS') &&\n        parent.type !== 'TSAsExpression' &&\n        parent.type !== 'TSNonNullExpression' &&\n        parent.type !== 'TSTypeAssertion'\n      ) {\n        return this.skip()\n      }\n      if (node.type === 'Identifier') {\n        const isLocal = !!knownIds[node.name]\n        const isRefed = isReferencedIdentifier(node, parent!, parentStack)\n        if (includeAll || (isRefed && !isLocal)) {\n          onIdentifier(node, parent!, parentStack, isRefed, isLocal)\n        }\n      } else if (\n        node.type === 'ObjectProperty' &&\n        parent!.type === 'ObjectPattern'\n      ) {\n        // mark property in destructure pattern\n        ;(node as any).inPattern = true\n      } else if (isFunctionType(node)) {\n        // walk function expressions and add its arguments to known identifiers\n        // so that we don't prefix them\n        walkFunctionParams(node, id => markScopeIdentifier(node, id, knownIds))\n      } else if (node.type === 'BlockStatement') {\n        // #3445 record block-level local variables\n        walkBlockDeclarations(node, id =>\n          markScopeIdentifier(node, id, knownIds)\n        )\n      }\n    },\n    leave(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\n      parent && parentStack.pop()\n      if (node !== rootExp && node.scopeIds) {\n        for (const id of node.scopeIds) {\n          knownIds[id]--\n          if (knownIds[id] === 0) {\n            delete knownIds[id]\n          }\n        }\n      }\n    }\n  })\n}\n\nexport function isReferencedIdentifier(\n  id: Identifier,\n  parent: Node | null,\n  parentStack: Node[]\n) {\n  if (__BROWSER__) {\n    return false\n  }\n\n  if (!parent) {\n    return true\n  }\n\n  // is a special keyword but parsed as identifier\n  if (id.name === 'arguments') {\n    return false\n  }\n\n  if (isReferenced(id, parent)) {\n    return true\n  }\n\n  // babel's isReferenced check returns false for ids being assigned to, so we\n  // need to cover those cases here\n  switch (parent.type) {\n    case 'AssignmentExpression':\n    case 'AssignmentPattern':\n      return true\n    case 'ObjectPattern':\n    case 'ArrayPattern':\n      return isInDestructureAssignment(parent, parentStack)\n  }\n\n  return false\n}\n\nexport function isInDestructureAssignment(\n  parent: Node,\n  parentStack: Node[]\n): boolean {\n  if (\n    parent &&\n    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')\n  ) {\n    let i = parentStack.length\n    while (i--) {\n      const p = parentStack[i]\n      if (p.type === 'AssignmentExpression') {\n        return true\n      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\n        break\n      }\n    }\n  }\n  return false\n}\n\nexport function walkFunctionParams(\n  node: Function,\n  onIdent: (id: Identifier) => void\n) {\n  for (const p of node.params) {\n    for (const id of extractIdentifiers(p)) {\n      onIdent(id)\n    }\n  }\n}\n\nexport function walkBlockDeclarations(\n  block: BlockStatement | Program,\n  onIdent: (node: Identifier) => void\n) {\n  for (const stmt of block.body) {\n    if (stmt.type === 'VariableDeclaration') {\n      if (stmt.declare) continue\n      for (const decl of stmt.declarations) {\n        for (const id of extractIdentifiers(decl.id)) {\n          onIdent(id)\n        }\n      }\n    } else if (\n      stmt.type === 'FunctionDeclaration' ||\n      stmt.type === 'ClassDeclaration'\n    ) {\n      if (stmt.declare || !stmt.id) continue\n      onIdent(stmt.id)\n    }\n  }\n}\n\nexport function extractIdentifiers(\n  param: Node,\n  nodes: Identifier[] = []\n): Identifier[] {\n  switch (param.type) {\n    case 'Identifier':\n      nodes.push(param)\n      break\n\n    case 'MemberExpression':\n      let object: any = param\n      while (object.type === 'MemberExpression') {\n        object = object.object\n      }\n      nodes.push(object)\n      break\n\n    case 'ObjectPattern':\n      for (const prop of param.properties) {\n        if (prop.type === 'RestElement') {\n          extractIdentifiers(prop.argument, nodes)\n        } else {\n          extractIdentifiers(prop.value, nodes)\n        }\n      }\n      break\n\n    case 'ArrayPattern':\n      param.elements.forEach(element => {\n        if (element) extractIdentifiers(element, nodes)\n      })\n      break\n\n    case 'RestElement':\n      extractIdentifiers(param.argument, nodes)\n      break\n\n    case 'AssignmentPattern':\n      extractIdentifiers(param.left, nodes)\n      break\n  }\n\n  return nodes\n}\n\nfunction markScopeIdentifier(\n  node: Node & { scopeIds?: Set<string> },\n  child: Identifier,\n  knownIds: Record<string, number>\n) {\n  const { name } = child\n  if (node.scopeIds && node.scopeIds.has(name)) {\n    return\n  }\n  if (name in knownIds) {\n    knownIds[name]++\n  } else {\n    knownIds[name] = 1\n  }\n  ;(node.scopeIds || (node.scopeIds = new Set())).add(name)\n}\n\nexport const isFunctionType = (node: Node): node is Function => {\n  return /Function(?:Expression|Declaration)$|Method$/.test(node.type)\n}\n\nexport const isStaticProperty = (node: Node): node is ObjectProperty =>\n  node &&\n  (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\n  !node.computed\n\nexport const isStaticPropertyKey = (node: Node, parent: Node) =>\n  isStaticProperty(parent) && parent.key === node\n\n/**\n * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts\n * To avoid runtime dependency on @babel/types (which includes process references)\n * This file should not change very often in babel but we may need to keep it\n * up-to-date from time to time.\n *\n * https://github.com/babel/babel/blob/main/LICENSE\n *\n */\nfunction isReferenced(node: Node, parent: Node, grandparent?: Node): boolean {\n  switch (parent.type) {\n    // yes: PARENT[NODE]\n    // yes: NODE.child\n    // no: parent.NODE\n    case 'MemberExpression':\n    case 'OptionalMemberExpression':\n      if (parent.property === node) {\n        return !!parent.computed\n      }\n      return parent.object === node\n\n    case 'JSXMemberExpression':\n      return parent.object === node\n    // no: let NODE = init;\n    // yes: let id = NODE;\n    case 'VariableDeclarator':\n      return parent.init === node\n\n    // yes: () => NODE\n    // no: (NODE) => {}\n    case 'ArrowFunctionExpression':\n      return parent.body === node\n\n    // no: class { #NODE; }\n    // no: class { get #NODE() {} }\n    // no: class { #NODE() {} }\n    // no: class { fn() { return this.#NODE; } }\n    case 'PrivateName':\n      return false\n\n    // no: class { NODE() {} }\n    // yes: class { [NODE]() {} }\n    // no: class { foo(NODE) {} }\n    case 'ClassMethod':\n    case 'ClassPrivateMethod':\n    case 'ObjectMethod':\n      if (parent.key === node) {\n        return !!parent.computed\n      }\n      return false\n\n    // yes: { [NODE]: \"\" }\n    // no: { NODE: \"\" }\n    // depends: { NODE }\n    // depends: { key: NODE }\n    case 'ObjectProperty':\n      if (parent.key === node) {\n        return !!parent.computed\n      }\n      // parent.value === node\n      return !grandparent || grandparent.type !== 'ObjectPattern'\n    // no: class { NODE = value; }\n    // yes: class { [NODE] = value; }\n    // yes: class { key = NODE; }\n    case 'ClassProperty':\n      if (parent.key === node) {\n        return !!parent.computed\n      }\n      return true\n    case 'ClassPrivateProperty':\n      return parent.key !== node\n\n    // no: class NODE {}\n    // yes: class Foo extends NODE {}\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      return parent.superClass === node\n\n    // yes: left = NODE;\n    // no: NODE = right;\n    case 'AssignmentExpression':\n      return parent.right === node\n\n    // no: [NODE = foo] = [];\n    // yes: [foo = NODE] = [];\n    case 'AssignmentPattern':\n      return parent.right === node\n\n    // no: NODE: for (;;) {}\n    case 'LabeledStatement':\n      return false\n\n    // no: try {} catch (NODE) {}\n    case 'CatchClause':\n      return false\n\n    // no: function foo(...NODE) {}\n    case 'RestElement':\n      return false\n\n    case 'BreakStatement':\n    case 'ContinueStatement':\n      return false\n\n    // no: function NODE() {}\n    // no: function foo(NODE) {}\n    case 'FunctionDeclaration':\n    case 'FunctionExpression':\n      return false\n\n    // no: export NODE from \"foo\";\n    // no: export * as NODE from \"foo\";\n    case 'ExportNamespaceSpecifier':\n    case 'ExportDefaultSpecifier':\n      return false\n\n    // no: export { foo as NODE };\n    // yes: export { NODE as foo };\n    // no: export { NODE as foo } from \"foo\";\n    case 'ExportSpecifier':\n      // @ts-expect-error\n      if (grandparent?.source) {\n        return false\n      }\n      return parent.local === node\n\n    // no: import NODE from \"foo\";\n    // no: import * as NODE from \"foo\";\n    // no: import { NODE as foo } from \"foo\";\n    // no: import { foo as NODE } from \"foo\";\n    // no: import NODE from \"bar\";\n    case 'ImportDefaultSpecifier':\n    case 'ImportNamespaceSpecifier':\n    case 'ImportSpecifier':\n      return false\n\n    // no: import \"foo\" assert { NODE: \"json\" }\n    case 'ImportAttribute':\n      return false\n\n    // no: <div NODE=\"foo\" />\n    case 'JSXAttribute':\n      return false\n\n    // no: [NODE] = [];\n    // no: ({ NODE }) = [];\n    case 'ObjectPattern':\n    case 'ArrayPattern':\n      return false\n\n    // no: new.NODE\n    // no: NODE.target\n    case 'MetaProperty':\n      return false\n\n    // yes: type X = { someProperty: NODE }\n    // no: type X = { NODE: OtherType }\n    case 'ObjectTypeProperty':\n      return parent.key !== node\n\n    // yes: enum X { Foo = NODE }\n    // no: enum X { NODE }\n    case 'TSEnumMember':\n      return parent.id !== node\n\n    // yes: { [NODE]: value }\n    // no: { NODE: value }\n    case 'TSPropertySignature':\n      if (parent.key === node) {\n        return !!parent.computed\n      }\n\n      return true\n  }\n\n  return true\n}\n","// these keywords should not appear inside expressions, but operators like\n\nimport { SimpleExpressionNode } from './ast'\nimport { TransformContext } from './transform'\nimport { createCompilerError, ErrorCodes } from './errors'\n\n// typeof, instanceof and in are allowed\nconst prohibitedKeywordRE = new RegExp(\n  '\\\\b' +\n    (\n      'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n      'super,throw,while,yield,delete,export,import,return,switch,default,' +\n      'extends,finally,continue,debugger,function,arguments,typeof,void'\n    )\n      .split(',')\n      .join('\\\\b|\\\\b') +\n    '\\\\b'\n)\n\n// strip strings in expressions\nconst stripStringRE =\n  /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g\n\n/**\n * Validate a non-prefixed expression.\n * This is only called when using the in-browser runtime compiler since it\n * doesn't prefix expressions.\n */\nexport function validateBrowserExpression(\n  node: SimpleExpressionNode,\n  context: TransformContext,\n  asParams = false,\n  asRawStatements = false\n) {\n  const exp = node.content\n\n  // empty expressions are validated per-directive since some directives\n  // do allow empty expressions.\n  if (!exp.trim()) {\n    return\n  }\n\n  try {\n    new Function(\n      asRawStatements\n        ? ` ${exp} `\n        : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`\n    )\n  } catch (e: any) {\n    let message = e.message\n    const keywordMatch = exp\n      .replace(stripStringRE, '')\n      .match(prohibitedKeywordRE)\n    if (keywordMatch) {\n      message = `avoid using JavaScript keyword as property name: \"${keywordMatch[0]}\"`\n    }\n    context.onError(\n      createCompilerError(\n        ErrorCodes.X_INVALID_EXPRESSION,\n        node.loc,\n        undefined,\n        message\n      )\n    )\n  }\n}\n","// - Parse expressions in templates into compound expressions so that each\n//   identifier gets more accurate source-map locations.\n//\n// - Prefix identifiers with `_ctx.` or `$xxx` (for known binding types) so that\n//   they are accessed from the right source\n//\n// - This transform is only applied in non-browser builds because it relies on\n//   an additional JavaScript parser. In the browser, there is no source-map\n//   support and the code is wrapped in `with (this) { ... }`.\nimport { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  createSimpleExpression,\n  ExpressionNode,\n  SimpleExpressionNode,\n  CompoundExpressionNode,\n  createCompoundExpression,\n  ConstantTypes\n} from '../ast'\nimport {\n  isInDestructureAssignment,\n  isStaticProperty,\n  isStaticPropertyKey,\n  walkIdentifiers\n} from '../babelUtils'\nimport { advancePositionWithClone, isSimpleIdentifier } from '../utils'\nimport {\n  isGloballyWhitelisted,\n  makeMap,\n  hasOwn,\n  isString,\n  genPropsAccessExp\n} from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  Node,\n  Identifier,\n  AssignmentExpression,\n  UpdateExpression\n} from '@babel/types'\nimport { validateBrowserExpression } from '../validateExpression'\nimport { parse } from '@babel/parser'\nimport { IS_REF, UNREF } from '../runtimeHelpers'\nimport { BindingTypes } from '../options'\n\nconst isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')\n\nexport const transformExpression: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.INTERPOLATION) {\n    node.content = processExpression(\n      node.content as SimpleExpressionNode,\n      context\n    )\n  } else if (node.type === NodeTypes.ELEMENT) {\n    // handle directives on element\n    for (let i = 0; i < node.props.length; i++) {\n      const dir = node.props[i]\n      // do not process for v-on & v-for since they are special handled\n      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {\n        const exp = dir.exp\n        const arg = dir.arg\n        // do not process exp if this is v-on:arg - we need special handling\n        // for wrapping inline statements.\n        if (\n          exp &&\n          exp.type === NodeTypes.SIMPLE_EXPRESSION &&\n          !(dir.name === 'on' && arg)\n        ) {\n          dir.exp = processExpression(\n            exp,\n            context,\n            // slot args must be processed as function params\n            dir.name === 'slot'\n          )\n        }\n        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {\n          dir.arg = processExpression(arg, context)\n        }\n      }\n    }\n  }\n}\n\ninterface PrefixMeta {\n  prefix?: string\n  isConstant: boolean\n  start: number\n  end: number\n  scopeIds?: Set<string>\n}\n\n// Important: since this function uses Node.js only dependencies, it should\n// always be used with a leading !__BROWSER__ check so that it can be\n// tree-shaken from the browser build.\nexport function processExpression(\n  node: SimpleExpressionNode,\n  context: TransformContext,\n  // some expressions like v-slot props & v-for aliases should be parsed as\n  // function params\n  asParams = false,\n  // v-on handler values may contain multiple statements\n  asRawStatements = false,\n  localVars: Record<string, number> = Object.create(context.identifiers)\n): ExpressionNode {\n  if (__BROWSER__) {\n    if (__DEV__) {\n      // simple in-browser validation (same logic in 2.x)\n      validateBrowserExpression(node, context, asParams, asRawStatements)\n    }\n    return node\n  }\n\n  if (!context.prefixIdentifiers || !node.content.trim()) {\n    return node\n  }\n\n  const { inline, bindingMetadata } = context\n  const rewriteIdentifier = (raw: string, parent?: Node, id?: Identifier) => {\n    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]\n    if (inline) {\n      // x = y\n      const isAssignmentLVal =\n        parent && parent.type === 'AssignmentExpression' && parent.left === id\n      // x++\n      const isUpdateArg =\n        parent && parent.type === 'UpdateExpression' && parent.argument === id\n      // ({ x } = y)\n      const isDestructureAssignment =\n        parent && isInDestructureAssignment(parent, parentStack)\n\n      if (\n        type === BindingTypes.SETUP_CONST ||\n        type === BindingTypes.SETUP_REACTIVE_CONST ||\n        localVars[raw]\n      ) {\n        return raw\n      } else if (type === BindingTypes.SETUP_REF) {\n        return `${raw}.value`\n      } else if (type === BindingTypes.SETUP_MAYBE_REF) {\n        // const binding that may or may not be ref\n        // if it's not a ref, then assignments don't make sense -\n        // so we ignore the non-ref assignment case and generate code\n        // that assumes the value to be a ref for more efficiency\n        return isAssignmentLVal || isUpdateArg || isDestructureAssignment\n          ? `${raw}.value`\n          : `${context.helperString(UNREF)}(${raw})`\n      } else if (type === BindingTypes.SETUP_LET) {\n        if (isAssignmentLVal) {\n          // let binding.\n          // this is a bit more tricky as we need to cover the case where\n          // let is a local non-ref value, and we need to replicate the\n          // right hand side value.\n          // x = y --> isRef(x) ? x.value = y : x = y\n          const { right: rVal, operator } = parent as AssignmentExpression\n          const rExp = rawExp.slice(rVal.start! - 1, rVal.end! - 1)\n          const rExpString = stringifyExpression(\n            processExpression(\n              createSimpleExpression(rExp, false),\n              context,\n              false,\n              false,\n              knownIds\n            )\n          )\n          return `${context.helperString(IS_REF)}(${raw})${\n            context.isTS ? ` //@ts-ignore\\n` : ``\n          } ? ${raw}.value ${operator} ${rExpString} : ${raw}`\n        } else if (isUpdateArg) {\n          // make id replace parent in the code range so the raw update operator\n          // is removed\n          id!.start = parent!.start\n          id!.end = parent!.end\n          const { prefix: isPrefix, operator } = parent as UpdateExpression\n          const prefix = isPrefix ? operator : ``\n          const postfix = isPrefix ? `` : operator\n          // let binding.\n          // x++ --> isRef(a) ? a.value++ : a++\n          return `${context.helperString(IS_REF)}(${raw})${\n            context.isTS ? ` //@ts-ignore\\n` : ``\n          } ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`\n        } else if (isDestructureAssignment) {\n          // TODO\n          // let binding in a destructure assignment - it's very tricky to\n          // handle both possible cases here without altering the original\n          // structure of the code, so we just assume it's not a ref here\n          // for now\n          return raw\n        } else {\n          return `${context.helperString(UNREF)}(${raw})`\n        }\n      } else if (type === BindingTypes.PROPS) {\n        // use __props which is generated by compileScript so in ts mode\n        // it gets correct type\n        return genPropsAccessExp(raw)\n      } else if (type === BindingTypes.PROPS_ALIASED) {\n        // prop with a different local alias (from defineProps() destructure)\n        return genPropsAccessExp(bindingMetadata.__propsAliases![raw])\n      }\n    } else {\n      if (type && type.startsWith('setup')) {\n        // setup bindings in non-inline mode\n        return `$setup.${raw}`\n      } else if (type === BindingTypes.PROPS_ALIASED) {\n        return `$props['${bindingMetadata.__propsAliases![raw]}']`\n      } else if (type) {\n        return `$${type}.${raw}`\n      }\n    }\n\n    // fallback to ctx\n    return `_ctx.${raw}`\n  }\n\n  // fast path if expression is a simple identifier.\n  const rawExp = node.content\n  // bail constant on parens (function invocation) and dot (member access)\n  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0\n\n  if (isSimpleIdentifier(rawExp)) {\n    const isScopeVarReference = context.identifiers[rawExp]\n    const isAllowedGlobal = isGloballyWhitelisted(rawExp)\n    const isLiteral = isLiteralWhitelisted(rawExp)\n    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {\n      // const bindings exposed from setup can be skipped for patching but\n      // cannot be hoisted to module scope\n      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {\n        node.constType = ConstantTypes.CAN_SKIP_PATCH\n      }\n      node.content = rewriteIdentifier(rawExp)\n    } else if (!isScopeVarReference) {\n      if (isLiteral) {\n        node.constType = ConstantTypes.CAN_STRINGIFY\n      } else {\n        node.constType = ConstantTypes.CAN_HOIST\n      }\n    }\n    return node\n  }\n\n  let ast: any\n  // exp needs to be parsed differently:\n  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw\n  //    exp, but make sure to pad with spaces for consistent ranges\n  // 2. Expressions: wrap with parens (for e.g. object expressions)\n  // 3. Function arguments (v-for, v-slot): place in a function argument position\n  const source = asRawStatements\n    ? ` ${rawExp} `\n    : `(${rawExp})${asParams ? `=>{}` : ``}`\n  try {\n    ast = parse(source, {\n      plugins: context.expressionPlugins\n    }).program\n  } catch (e: any) {\n    context.onError(\n      createCompilerError(\n        ErrorCodes.X_INVALID_EXPRESSION,\n        node.loc,\n        undefined,\n        e.message\n      )\n    )\n    return node\n  }\n\n  type QualifiedId = Identifier & PrefixMeta\n  const ids: QualifiedId[] = []\n  const parentStack: Node[] = []\n  const knownIds: Record<string, number> = Object.create(context.identifiers)\n\n  walkIdentifiers(\n    ast,\n    (node, parent, _, isReferenced, isLocal) => {\n      if (isStaticPropertyKey(node, parent!)) {\n        return\n      }\n      // v2 wrapped filter call\n      if (__COMPAT__ && node.name.startsWith('_filter_')) {\n        return\n      }\n\n      const needPrefix = isReferenced && canPrefix(node)\n      if (needPrefix && !isLocal) {\n        if (isStaticProperty(parent!) && parent.shorthand) {\n          // property shorthand like { foo }, we need to add the key since\n          // we rewrite the value\n          ;(node as QualifiedId).prefix = `${node.name}: `\n        }\n        node.name = rewriteIdentifier(node.name, parent, node)\n        ids.push(node as QualifiedId)\n      } else {\n        // The identifier is considered constant unless it's pointing to a\n        // local scope variable (a v-for alias, or a v-slot prop)\n        if (!(needPrefix && isLocal) && !bailConstant) {\n          ;(node as QualifiedId).isConstant = true\n        }\n        // also generate sub-expressions for other identifiers for better\n        // source map support. (except for property keys which are static)\n        ids.push(node as QualifiedId)\n      }\n    },\n    true, // invoke on ALL identifiers\n    parentStack,\n    knownIds\n  )\n\n  // We break up the compound expression into an array of strings and sub\n  // expressions (for identifiers that have been prefixed). In codegen, if\n  // an ExpressionNode has the `.children` property, it will be used instead of\n  // `.content`.\n  const children: CompoundExpressionNode['children'] = []\n  ids.sort((a, b) => a.start - b.start)\n  ids.forEach((id, i) => {\n    // range is offset by -1 due to the wrapping parens when parsed\n    const start = id.start - 1\n    const end = id.end - 1\n    const last = ids[i - 1]\n    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)\n    if (leadingText.length || id.prefix) {\n      children.push(leadingText + (id.prefix || ``))\n    }\n    const source = rawExp.slice(start, end)\n    children.push(\n      createSimpleExpression(\n        id.name,\n        false,\n        {\n          source,\n          start: advancePositionWithClone(node.loc.start, source, start),\n          end: advancePositionWithClone(node.loc.start, source, end)\n        },\n        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT\n      )\n    )\n    if (i === ids.length - 1 && end < rawExp.length) {\n      children.push(rawExp.slice(end))\n    }\n  })\n\n  let ret\n  if (children.length) {\n    ret = createCompoundExpression(children, node.loc)\n  } else {\n    ret = node\n    ret.constType = bailConstant\n      ? ConstantTypes.NOT_CONSTANT\n      : ConstantTypes.CAN_STRINGIFY\n  }\n  ret.identifiers = Object.keys(knownIds)\n  return ret\n}\n\nfunction canPrefix(id: Identifier) {\n  // skip whitelisted globals\n  if (isGloballyWhitelisted(id.name)) {\n    return false\n  }\n  // special case for webpack compilation\n  if (id.name === 'require') {\n    return false\n  }\n  return true\n}\n\nfunction stringifyExpression(exp: ExpressionNode | string): string {\n  if (isString(exp)) {\n    return exp\n  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n    return exp.content\n  } else {\n    return (exp.children as (ExpressionNode | string)[])\n      .map(stringifyExpression)\n      .join('')\n  }\n}\n","import {\n  createStructuralDirectiveTransform,\n  TransformContext,\n  traverseNode\n} from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  ElementNode,\n  DirectiveNode,\n  IfBranchNode,\n  SimpleExpressionNode,\n  createCallExpression,\n  createConditionalExpression,\n  createSimpleExpression,\n  createObjectProperty,\n  createObjectExpression,\n  IfConditionalExpression,\n  BlockCodegenNode,\n  IfNode,\n  createVNodeCall,\n  AttributeNode,\n  locStub,\n  CacheExpression,\n  ConstantTypes,\n  MemoExpression\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport { validateBrowserExpression } from '../validateExpression'\nimport { FRAGMENT, CREATE_COMMENT } from '../runtimeHelpers'\nimport {\n  injectProp,\n  findDir,\n  findProp,\n  isBuiltInType,\n  makeBlock\n} from '../utils'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\nimport { getMemoedVNodeCall } from '..'\n\nexport const transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) => {\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\n      // #1587: We need to dynamically increment the key based on the current\n      // node's sibling nodes, since chained v-if/else branches are\n      // rendered at the same depth\n      const siblings = context.parent!.children\n      let i = siblings.indexOf(ifNode)\n      let key = 0\n      while (i-- >= 0) {\n        const sibling = siblings[i]\n        if (sibling && sibling.type === NodeTypes.IF) {\n          key += sibling.branches.length\n        }\n      }\n\n      // Exit callback. Complete the codegenNode when all children have been\n      // transformed.\n      return () => {\n        if (isRoot) {\n          ifNode.codegenNode = createCodegenNodeForBranch(\n            branch,\n            key,\n            context\n          ) as IfConditionalExpression\n        } else {\n          // attach this branch's codegen node to the v-if root.\n          const parentCondition = getParentCondition(ifNode.codegenNode!)\n          parentCondition.alternate = createCodegenNodeForBranch(\n            branch,\n            key + ifNode.branches.length - 1,\n            context\n          )\n        }\n      }\n    })\n  }\n)\n\n// target-agnostic transform used for both Client and SSR\nexport function processIf(\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext,\n  processCodegen?: (\n    node: IfNode,\n    branch: IfBranchNode,\n    isRoot: boolean\n  ) => (() => void) | undefined\n) {\n  if (\n    dir.name !== 'else' &&\n    (!dir.exp || !(dir.exp as SimpleExpressionNode).content.trim())\n  ) {\n    const loc = dir.exp ? dir.exp.loc : node.loc\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_IF_NO_EXPRESSION, dir.loc)\n    )\n    dir.exp = createSimpleExpression(`true`, false, loc)\n  }\n\n  if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\n    // dir.exp can only be simple expression because vIf transform is applied\n    // before expression transform.\n    dir.exp = processExpression(dir.exp as SimpleExpressionNode, context)\n  }\n\n  if (__DEV__ && __BROWSER__ && dir.exp) {\n    validateBrowserExpression(dir.exp as SimpleExpressionNode, context)\n  }\n\n  if (dir.name === 'if') {\n    const branch = createIfBranch(node, dir)\n    const ifNode: IfNode = {\n      type: NodeTypes.IF,\n      loc: node.loc,\n      branches: [branch]\n    }\n    context.replaceNode(ifNode)\n    if (processCodegen) {\n      return processCodegen(ifNode, branch, true)\n    }\n  } else {\n    // locate the adjacent v-if\n    const siblings = context.parent!.children\n    const comments = []\n    let i = siblings.indexOf(node)\n    while (i-- >= -1) {\n      const sibling = siblings[i]\n      if (__DEV__ && sibling && sibling.type === NodeTypes.COMMENT) {\n        context.removeNode(sibling)\n        comments.unshift(sibling)\n        continue\n      }\n\n      if (\n        sibling &&\n        sibling.type === NodeTypes.TEXT &&\n        !sibling.content.trim().length\n      ) {\n        context.removeNode(sibling)\n        continue\n      }\n\n      if (sibling && sibling.type === NodeTypes.IF) {\n        // Check if v-else was followed by v-else-if\n        if (\n          dir.name === 'else-if' &&\n          sibling.branches[sibling.branches.length - 1].condition === undefined\n        ) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\n          )\n        }\n\n        // move the node to the if node's branches\n        context.removeNode()\n        const branch = createIfBranch(node, dir)\n        if (\n          __DEV__ &&\n          comments.length &&\n          // #3619 ignore comments if the v-if is direct child of <transition>\n          !(\n            context.parent &&\n            context.parent.type === NodeTypes.ELEMENT &&\n            isBuiltInType(context.parent.tag, 'transition')\n          )\n        ) {\n          branch.children = [...comments, ...branch.children]\n        }\n\n        // check if user is forcing same key on different branches\n        if (__DEV__ || !__BROWSER__) {\n          const key = branch.userKey\n          if (key) {\n            sibling.branches.forEach(({ userKey }) => {\n              if (isSameKey(userKey, key)) {\n                context.onError(\n                  createCompilerError(\n                    ErrorCodes.X_V_IF_SAME_KEY,\n                    branch.userKey!.loc\n                  )\n                )\n              }\n            })\n          }\n        }\n\n        sibling.branches.push(branch)\n        const onExit = processCodegen && processCodegen(sibling, branch, false)\n        // since the branch was removed, it will not be traversed.\n        // make sure to traverse here.\n        traverseNode(branch, context)\n        // call on exit\n        if (onExit) onExit()\n        // make sure to reset currentNode after traversal to indicate this\n        // node has been removed.\n        context.currentNode = null\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\n        )\n      }\n      break\n    }\n  }\n}\n\nfunction createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {\n  const isTemplateIf = node.tagType === ElementTypes.TEMPLATE\n  return {\n    type: NodeTypes.IF_BRANCH,\n    loc: node.loc,\n    condition: dir.name === 'else' ? undefined : dir.exp,\n    children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],\n    userKey: findProp(node, `key`),\n    isTemplateIf\n  }\n}\n\nfunction createCodegenNodeForBranch(\n  branch: IfBranchNode,\n  keyIndex: number,\n  context: TransformContext\n): IfConditionalExpression | BlockCodegenNode | MemoExpression {\n  if (branch.condition) {\n    return createConditionalExpression(\n      branch.condition,\n      createChildrenCodegenNode(branch, keyIndex, context),\n      // make sure to pass in asBlock: true so that the comment node call\n      // closes the current block.\n      createCallExpression(context.helper(CREATE_COMMENT), [\n        __DEV__ ? '\"v-if\"' : '\"\"',\n        'true'\n      ])\n    ) as IfConditionalExpression\n  } else {\n    return createChildrenCodegenNode(branch, keyIndex, context)\n  }\n}\n\nfunction createChildrenCodegenNode(\n  branch: IfBranchNode,\n  keyIndex: number,\n  context: TransformContext\n): BlockCodegenNode | MemoExpression {\n  const { helper } = context\n  const keyProperty = createObjectProperty(\n    `key`,\n    createSimpleExpression(\n      `${keyIndex}`,\n      false,\n      locStub,\n      ConstantTypes.CAN_HOIST\n    )\n  )\n  const { children } = branch\n  const firstChild = children[0]\n  const needFragmentWrapper =\n    children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT\n  if (needFragmentWrapper) {\n    if (children.length === 1 && firstChild.type === NodeTypes.FOR) {\n      // optimize away nested fragments when child is a ForNode\n      const vnodeCall = firstChild.codegenNode!\n      injectProp(vnodeCall, keyProperty, context)\n      return vnodeCall\n    } else {\n      let patchFlag = PatchFlags.STABLE_FRAGMENT\n      let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\n      // check if the fragment actually contains a single valid child with\n      // the rest being comments\n      if (\n        __DEV__ &&\n        !branch.isTemplateIf &&\n        children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\n      ) {\n        patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\n        patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\n      }\n\n      return createVNodeCall(\n        context,\n        helper(FRAGMENT),\n        createObjectExpression([keyProperty]),\n        children,\n        patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\n        undefined,\n        undefined,\n        true,\n        false,\n        false /* isComponent */,\n        branch.loc\n      )\n    }\n  } else {\n    const ret = (firstChild as ElementNode).codegenNode as\n      | BlockCodegenNode\n      | MemoExpression\n    const vnodeCall = getMemoedVNodeCall(ret)\n    // Change createVNode to createBlock.\n    if (vnodeCall.type === NodeTypes.VNODE_CALL) {\n      makeBlock(vnodeCall, context)\n    }\n    // inject branch key\n    injectProp(vnodeCall, keyProperty, context)\n    return ret\n  }\n}\n\nfunction isSameKey(\n  a: AttributeNode | DirectiveNode | undefined,\n  b: AttributeNode | DirectiveNode\n): boolean {\n  if (!a || a.type !== b.type) {\n    return false\n  }\n  if (a.type === NodeTypes.ATTRIBUTE) {\n    if (a.value!.content !== (b as AttributeNode).value!.content) {\n      return false\n    }\n  } else {\n    // directive\n    const exp = a.exp!\n    const branchExp = (b as DirectiveNode).exp!\n    if (exp.type !== branchExp.type) {\n      return false\n    }\n    if (\n      exp.type !== NodeTypes.SIMPLE_EXPRESSION ||\n      exp.isStatic !== (branchExp as SimpleExpressionNode).isStatic ||\n      exp.content !== (branchExp as SimpleExpressionNode).content\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getParentCondition(\n  node: IfConditionalExpression | CacheExpression\n): IfConditionalExpression {\n  while (true) {\n    if (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\n      if (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\n        node = node.alternate\n      } else {\n        return node\n      }\n    } else if (node.type === NodeTypes.JS_CACHE_EXPRESSION) {\n      node = node.value as IfConditionalExpression\n    }\n  }\n}\n","import {\n  createStructuralDirectiveTransform,\n  TransformContext\n} from '../transform'\nimport {\n  NodeTypes,\n  ExpressionNode,\n  createSimpleExpression,\n  SourceLocation,\n  SimpleExpressionNode,\n  createCallExpression,\n  createFunctionExpression,\n  createObjectExpression,\n  createObjectProperty,\n  ForCodegenNode,\n  RenderSlotCall,\n  SlotOutletNode,\n  ElementNode,\n  DirectiveNode,\n  ForNode,\n  PlainElementNode,\n  createVNodeCall,\n  VNodeCall,\n  ForRenderListExpression,\n  BlockCodegenNode,\n  ForIteratorExpression,\n  ConstantTypes,\n  createBlockStatement,\n  createCompoundExpression\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  getInnerRange,\n  findProp,\n  isTemplateNode,\n  isSlotOutlet,\n  injectProp,\n  getVNodeBlockHelper,\n  getVNodeHelper,\n  findDir\n} from '../utils'\nimport {\n  RENDER_LIST,\n  OPEN_BLOCK,\n  FRAGMENT,\n  IS_MEMO_SAME\n} from '../runtimeHelpers'\nimport { processExpression } from './transformExpression'\nimport { validateBrowserExpression } from '../validateExpression'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\n\nexport const transformFor = createStructuralDirectiveTransform(\n  'for',\n  (node, dir, context) => {\n    const { helper, removeHelper } = context\n    return processFor(node, dir, context, forNode => {\n      // create the loop render function expression now, and add the\n      // iterator on exit after all children have been traversed\n      const renderExp = createCallExpression(helper(RENDER_LIST), [\n        forNode.source\n      ]) as ForRenderListExpression\n      const isTemplate = isTemplateNode(node)\n      const memo = findDir(node, 'memo')\n      const keyProp = findProp(node, `key`)\n      const keyExp =\n        keyProp &&\n        (keyProp.type === NodeTypes.ATTRIBUTE\n          ? createSimpleExpression(keyProp.value!.content, true)\n          : keyProp.exp!)\n      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp!) : null\n\n      if (!__BROWSER__ && isTemplate) {\n        // #2085 / #5288 process :key and v-memo expressions need to be\n        // processed on `<template v-for>`. In this case the node is discarded\n        // and never traversed so its binding expressions won't be processed\n        // by the normal transforms.\n        if (memo) {\n          memo.exp = processExpression(\n            memo.exp! as SimpleExpressionNode,\n            context\n          )\n        }\n        if (keyProperty && keyProp!.type !== NodeTypes.ATTRIBUTE) {\n          keyProperty.value = processExpression(\n            keyProperty.value as SimpleExpressionNode,\n            context\n          )\n        }\n      }\n\n      const isStableFragment =\n        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&\n        forNode.source.constType > ConstantTypes.NOT_CONSTANT\n      const fragmentFlag = isStableFragment\n        ? PatchFlags.STABLE_FRAGMENT\n        : keyProp\n        ? PatchFlags.KEYED_FRAGMENT\n        : PatchFlags.UNKEYED_FRAGMENT\n\n      forNode.codegenNode = createVNodeCall(\n        context,\n        helper(FRAGMENT),\n        undefined,\n        renderExp,\n        fragmentFlag +\n          (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),\n        undefined,\n        undefined,\n        true /* isBlock */,\n        !isStableFragment /* disableTracking */,\n        false /* isComponent */,\n        node.loc\n      ) as ForCodegenNode\n\n      return () => {\n        // finish the codegen now that all children have been traversed\n        let childBlock: BlockCodegenNode\n        const { children } = forNode\n\n        // check <template v-for> key placement\n        if ((__DEV__ || !__BROWSER__) && isTemplate) {\n          node.children.some(c => {\n            if (c.type === NodeTypes.ELEMENT) {\n              const key = findProp(c, 'key')\n              if (key) {\n                context.onError(\n                  createCompilerError(\n                    ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT,\n                    key.loc\n                  )\n                )\n                return true\n              }\n            }\n          })\n        }\n\n        const needFragmentWrapper =\n          children.length !== 1 || children[0].type !== NodeTypes.ELEMENT\n        const slotOutlet = isSlotOutlet(node)\n          ? node\n          : isTemplate &&\n            node.children.length === 1 &&\n            isSlotOutlet(node.children[0])\n          ? (node.children[0] as SlotOutletNode) // api-extractor somehow fails to infer this\n          : null\n\n        if (slotOutlet) {\n          // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\n          childBlock = slotOutlet.codegenNode as RenderSlotCall\n          if (isTemplate && keyProperty) {\n            // <template v-for=\"...\" :key=\"...\"><slot/></template>\n            // we need to inject the key to the renderSlot() call.\n            // the props for renderSlot is passed as the 3rd argument.\n            injectProp(childBlock, keyProperty, context)\n          }\n        } else if (needFragmentWrapper) {\n          // <template v-for=\"...\"> with text or multi-elements\n          // should generate a fragment block for each loop\n          childBlock = createVNodeCall(\n            context,\n            helper(FRAGMENT),\n            keyProperty ? createObjectExpression([keyProperty]) : undefined,\n            node.children,\n            PatchFlags.STABLE_FRAGMENT +\n              (__DEV__\n                ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`\n                : ``),\n            undefined,\n            undefined,\n            true,\n            undefined,\n            false /* isComponent */\n          )\n        } else {\n          // Normal element v-for. Directly use the child's codegenNode\n          // but mark it as a block.\n          childBlock = (children[0] as PlainElementNode)\n            .codegenNode as VNodeCall\n          if (isTemplate && keyProperty) {\n            injectProp(childBlock, keyProperty, context)\n          }\n          if (childBlock.isBlock !== !isStableFragment) {\n            if (childBlock.isBlock) {\n              // switch from block to vnode\n              removeHelper(OPEN_BLOCK)\n              removeHelper(\n                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)\n              )\n            } else {\n              // switch from vnode to block\n              removeHelper(\n                getVNodeHelper(context.inSSR, childBlock.isComponent)\n              )\n            }\n          }\n          childBlock.isBlock = !isStableFragment\n          if (childBlock.isBlock) {\n            helper(OPEN_BLOCK)\n            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))\n          } else {\n            helper(getVNodeHelper(context.inSSR, childBlock.isComponent))\n          }\n        }\n\n        if (memo) {\n          const loop = createFunctionExpression(\n            createForLoopParams(forNode.parseResult, [\n              createSimpleExpression(`_cached`)\n            ])\n          )\n          loop.body = createBlockStatement([\n            createCompoundExpression([`const _memo = (`, memo.exp!, `)`]),\n            createCompoundExpression([\n              `if (_cached`,\n              ...(keyExp ? [` && _cached.key === `, keyExp] : []),\n              ` && ${context.helperString(\n                IS_MEMO_SAME\n              )}(_cached, _memo)) return _cached`\n            ]),\n            createCompoundExpression([`const _item = `, childBlock as any]),\n            createSimpleExpression(`_item.memo = _memo`),\n            createSimpleExpression(`return _item`)\n          ])\n          renderExp.arguments.push(\n            loop as ForIteratorExpression,\n            createSimpleExpression(`_cache`),\n            createSimpleExpression(String(context.cached++))\n          )\n        } else {\n          renderExp.arguments.push(\n            createFunctionExpression(\n              createForLoopParams(forNode.parseResult),\n              childBlock,\n              true /* force newline */\n            ) as ForIteratorExpression\n          )\n        }\n      }\n    })\n  }\n)\n\n// target-agnostic transform used for both Client and SSR\nexport function processFor(\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext,\n  processCodegen?: (forNode: ForNode) => (() => void) | undefined\n) {\n  if (!dir.exp) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_FOR_NO_EXPRESSION, dir.loc)\n    )\n    return\n  }\n\n  const parseResult = parseForExpression(\n    // can only be simple expression because vFor transform is applied\n    // before expression transform.\n    dir.exp as SimpleExpressionNode,\n    context\n  )\n\n  if (!parseResult) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, dir.loc)\n    )\n    return\n  }\n\n  const { addIdentifiers, removeIdentifiers, scopes } = context\n  const { source, value, key, index } = parseResult\n\n  const forNode: ForNode = {\n    type: NodeTypes.FOR,\n    loc: dir.loc,\n    source,\n    valueAlias: value,\n    keyAlias: key,\n    objectIndexAlias: index,\n    parseResult,\n    children: isTemplateNode(node) ? node.children : [node]\n  }\n\n  context.replaceNode(forNode)\n\n  // bookkeeping\n  scopes.vFor++\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    // scope management\n    // inject identifiers to context\n    value && addIdentifiers(value)\n    key && addIdentifiers(key)\n    index && addIdentifiers(index)\n  }\n\n  const onExit = processCodegen && processCodegen(forNode)\n\n  return () => {\n    scopes.vFor--\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      value && removeIdentifiers(value)\n      key && removeIdentifiers(key)\n      index && removeIdentifiers(index)\n    }\n    if (onExit) onExit()\n  }\n}\n\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n// This regex doesn't cover the case if key or index aliases have destructuring,\n// but those do not make sense in the first place, so this works in practice.\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\nconst stripParensRE = /^\\(|\\)$/g\n\nexport interface ForParseResult {\n  source: ExpressionNode\n  value: ExpressionNode | undefined\n  key: ExpressionNode | undefined\n  index: ExpressionNode | undefined\n}\n\nexport function parseForExpression(\n  input: SimpleExpressionNode,\n  context: TransformContext\n): ForParseResult | undefined {\n  const loc = input.loc\n  const exp = input.content\n  const inMatch = exp.match(forAliasRE)\n  if (!inMatch) return\n\n  const [, LHS, RHS] = inMatch\n\n  const result: ForParseResult = {\n    source: createAliasExpression(\n      loc,\n      RHS.trim(),\n      exp.indexOf(RHS, LHS.length)\n    ),\n    value: undefined,\n    key: undefined,\n    index: undefined\n  }\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    result.source = processExpression(\n      result.source as SimpleExpressionNode,\n      context\n    )\n  }\n  if (__DEV__ && __BROWSER__) {\n    validateBrowserExpression(result.source as SimpleExpressionNode, context)\n  }\n\n  let valueContent = LHS.trim().replace(stripParensRE, '').trim()\n  const trimmedOffset = LHS.indexOf(valueContent)\n\n  const iteratorMatch = valueContent.match(forIteratorRE)\n  if (iteratorMatch) {\n    valueContent = valueContent.replace(forIteratorRE, '').trim()\n\n    const keyContent = iteratorMatch[1].trim()\n    let keyOffset: number | undefined\n    if (keyContent) {\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)\n      result.key = createAliasExpression(loc, keyContent, keyOffset)\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        result.key = processExpression(result.key, context, true)\n      }\n      if (__DEV__ && __BROWSER__) {\n        validateBrowserExpression(\n          result.key as SimpleExpressionNode,\n          context,\n          true\n        )\n      }\n    }\n\n    if (iteratorMatch[2]) {\n      const indexContent = iteratorMatch[2].trim()\n\n      if (indexContent) {\n        result.index = createAliasExpression(\n          loc,\n          indexContent,\n          exp.indexOf(\n            indexContent,\n            result.key\n              ? keyOffset! + keyContent.length\n              : trimmedOffset + valueContent.length\n          )\n        )\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          result.index = processExpression(result.index, context, true)\n        }\n        if (__DEV__ && __BROWSER__) {\n          validateBrowserExpression(\n            result.index as SimpleExpressionNode,\n            context,\n            true\n          )\n        }\n      }\n    }\n  }\n\n  if (valueContent) {\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset)\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      result.value = processExpression(result.value, context, true)\n    }\n    if (__DEV__ && __BROWSER__) {\n      validateBrowserExpression(\n        result.value as SimpleExpressionNode,\n        context,\n        true\n      )\n    }\n  }\n\n  return result\n}\n\nfunction createAliasExpression(\n  range: SourceLocation,\n  content: string,\n  offset: number\n): SimpleExpressionNode {\n  return createSimpleExpression(\n    content,\n    false,\n    getInnerRange(range, offset, content.length)\n  )\n}\n\nexport function createForLoopParams(\n  { value, key, index }: ForParseResult,\n  memoArgs: ExpressionNode[] = []\n): ExpressionNode[] {\n  return createParamsList([value, key, index, ...memoArgs])\n}\n\nfunction createParamsList(\n  args: (ExpressionNode | undefined)[]\n): ExpressionNode[] {\n  let i = args.length\n  while (i--) {\n    if (args[i]) break\n  }\n  return args\n    .slice(0, i + 1)\n    .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false))\n}\n","import {\n  ElementNode,\n  ObjectExpression,\n  createObjectExpression,\n  NodeTypes,\n  createObjectProperty,\n  createSimpleExpression,\n  createFunctionExpression,\n  DirectiveNode,\n  ElementTypes,\n  ExpressionNode,\n  Property,\n  TemplateChildNode,\n  SourceLocation,\n  createConditionalExpression,\n  ConditionalExpression,\n  SimpleExpressionNode,\n  FunctionExpression,\n  CallExpression,\n  createCallExpression,\n  createArrayExpression,\n  SlotsExpression\n} from '../ast'\nimport { TransformContext, NodeTransform } from '../transform'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  findDir,\n  isTemplateNode,\n  assert,\n  isVSlot,\n  hasScopeRef,\n  isStaticExp\n} from '../utils'\nimport { CREATE_SLOTS, RENDER_LIST, WITH_CTX } from '../runtimeHelpers'\nimport { parseForExpression, createForLoopParams } from './vFor'\nimport { SlotFlags, slotFlagsText } from '@vue/shared'\n\nconst defaultFallback = createSimpleExpression(`undefined`, false)\n\n// A NodeTransform that:\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\n//    by transformExpression. This is only applied in non-browser builds with\n//    { prefixIdentifiers: true }.\n// 2. Track v-slot depths so that we know a slot is inside another slot.\n//    Note the exit callback is executed before buildSlots() on the same node,\n//    so only nested slots see positive numbers.\nexport const trackSlotScopes: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    (node.tagType === ElementTypes.COMPONENT ||\n      node.tagType === ElementTypes.TEMPLATE)\n  ) {\n    // We are only checking non-empty v-slot here\n    // since we only care about slots that introduce scope variables.\n    const vSlot = findDir(node, 'slot')\n    if (vSlot) {\n      const slotProps = vSlot.exp\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        slotProps && context.addIdentifiers(slotProps)\n      }\n      context.scopes.vSlot++\n      return () => {\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          slotProps && context.removeIdentifiers(slotProps)\n        }\n        context.scopes.vSlot--\n      }\n    }\n  }\n}\n\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\nexport const trackVForSlotScopes: NodeTransform = (node, context) => {\n  let vFor\n  if (\n    isTemplateNode(node) &&\n    node.props.some(isVSlot) &&\n    (vFor = findDir(node, 'for'))\n  ) {\n    const result = (vFor.parseResult = parseForExpression(\n      vFor.exp as SimpleExpressionNode,\n      context\n    ))\n    if (result) {\n      const { value, key, index } = result\n      const { addIdentifiers, removeIdentifiers } = context\n      value && addIdentifiers(value)\n      key && addIdentifiers(key)\n      index && addIdentifiers(index)\n\n      return () => {\n        value && removeIdentifiers(value)\n        key && removeIdentifiers(key)\n        index && removeIdentifiers(index)\n      }\n    }\n  }\n}\n\nexport type SlotFnBuilder = (\n  slotProps: ExpressionNode | undefined,\n  slotChildren: TemplateChildNode[],\n  loc: SourceLocation\n) => FunctionExpression\n\nconst buildClientSlotFn: SlotFnBuilder = (props, children, loc) =>\n  createFunctionExpression(\n    props,\n    children,\n    false /* newline */,\n    true /* isSlot */,\n    children.length ? children[0].loc : loc\n  )\n\n// Instead of being a DirectiveTransform, v-slot processing is called during\n// transformElement to build the slots object for a component.\nexport function buildSlots(\n  node: ElementNode,\n  context: TransformContext,\n  buildSlotFn: SlotFnBuilder = buildClientSlotFn\n): {\n  slots: SlotsExpression\n  hasDynamicSlots: boolean\n} {\n  context.helper(WITH_CTX)\n\n  const { children, loc } = node\n  const slotsProperties: Property[] = []\n  const dynamicSlots: (ConditionalExpression | CallExpression)[] = []\n\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\n  // since it likely uses a scope variable.\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0\n  // with `prefixIdentifiers: true`, this can be further optimized to make\n  // it dynamic only when the slot actually uses the scope variables.\n  if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {\n    hasDynamicSlots = hasScopeRef(node, context.identifiers)\n  }\n\n  // 1. Check for slot with slotProps on component itself.\n  //    <Comp v-slot=\"{ prop }\"/>\n  const onComponentSlot = findDir(node, 'slot', true)\n  if (onComponentSlot) {\n    const { arg, exp } = onComponentSlot\n    if (arg && !isStaticExp(arg)) {\n      hasDynamicSlots = true\n    }\n    slotsProperties.push(\n      createObjectProperty(\n        arg || createSimpleExpression('default', true),\n        buildSlotFn(exp, children, loc)\n      )\n    )\n  }\n\n  // 2. Iterate through children and check for template slots\n  //    <template v-slot:foo=\"{ prop }\">\n  let hasTemplateSlots = false\n  let hasNamedDefaultSlot = false\n  const implicitDefaultChildren: TemplateChildNode[] = []\n  const seenSlotNames = new Set<string>()\n\n  for (let i = 0; i < children.length; i++) {\n    const slotElement = children[i]\n    let slotDir\n\n    if (\n      !isTemplateNode(slotElement) ||\n      !(slotDir = findDir(slotElement, 'slot', true))\n    ) {\n      // not a <template v-slot>, skip.\n      if (slotElement.type !== NodeTypes.COMMENT) {\n        implicitDefaultChildren.push(slotElement)\n      }\n      continue\n    }\n\n    if (onComponentSlot) {\n      // already has on-component slot - this is incorrect usage.\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE, slotDir.loc)\n      )\n      break\n    }\n\n    hasTemplateSlots = true\n    const { children: slotChildren, loc: slotLoc } = slotElement\n    const {\n      arg: slotName = createSimpleExpression(`default`, true),\n      exp: slotProps,\n      loc: dirLoc\n    } = slotDir\n\n    // check if name is dynamic.\n    let staticSlotName: string | undefined\n    if (isStaticExp(slotName)) {\n      staticSlotName = slotName ? slotName.content : `default`\n    } else {\n      hasDynamicSlots = true\n    }\n\n    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc)\n    // check if this slot is conditional (v-if/v-for)\n    let vIf: DirectiveNode | undefined\n    let vElse: DirectiveNode | undefined\n    let vFor: DirectiveNode | undefined\n    if ((vIf = findDir(slotElement, 'if'))) {\n      hasDynamicSlots = true\n      dynamicSlots.push(\n        createConditionalExpression(\n          vIf.exp!,\n          buildDynamicSlot(slotName, slotFunction),\n          defaultFallback\n        )\n      )\n    } else if (\n      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))\n    ) {\n      // find adjacent v-if\n      let j = i\n      let prev\n      while (j--) {\n        prev = children[j]\n        if (prev.type !== NodeTypes.COMMENT) {\n          break\n        }\n      }\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\n        // remove node\n        children.splice(i, 1)\n        i--\n        __TEST__ && assert(dynamicSlots.length > 0)\n        // attach this slot to previous conditional\n        let conditional = dynamicSlots[\n          dynamicSlots.length - 1\n        ] as ConditionalExpression\n        while (\n          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n        ) {\n          conditional = conditional.alternate\n        }\n        conditional.alternate = vElse.exp\n          ? createConditionalExpression(\n              vElse.exp,\n              buildDynamicSlot(slotName, slotFunction),\n              defaultFallback\n            )\n          : buildDynamicSlot(slotName, slotFunction)\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)\n        )\n      }\n    } else if ((vFor = findDir(slotElement, 'for'))) {\n      hasDynamicSlots = true\n      const parseResult =\n        vFor.parseResult ||\n        parseForExpression(vFor.exp as SimpleExpressionNode, context)\n      if (parseResult) {\n        // Render the dynamic slots as an array and add it to the createSlot()\n        // args. The runtime knows how to handle it appropriately.\n        dynamicSlots.push(\n          createCallExpression(context.helper(RENDER_LIST), [\n            parseResult.source,\n            createFunctionExpression(\n              createForLoopParams(parseResult),\n              buildDynamicSlot(slotName, slotFunction),\n              true /* force newline */\n            )\n          ])\n        )\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, vFor.loc)\n        )\n      }\n    } else {\n      // check duplicate static names\n      if (staticSlotName) {\n        if (seenSlotNames.has(staticSlotName)) {\n          context.onError(\n            createCompilerError(\n              ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\n              dirLoc\n            )\n          )\n          continue\n        }\n        seenSlotNames.add(staticSlotName)\n        if (staticSlotName === 'default') {\n          hasNamedDefaultSlot = true\n        }\n      }\n      slotsProperties.push(createObjectProperty(slotName, slotFunction))\n    }\n  }\n\n  if (!onComponentSlot) {\n    const buildDefaultSlotProperty = (\n      props: ExpressionNode | undefined,\n      children: TemplateChildNode[]\n    ) => {\n      const fn = buildSlotFn(props, children, loc)\n      if (__COMPAT__ && context.compatConfig) {\n        fn.isNonScopedSlot = true\n      }\n      return createObjectProperty(`default`, fn)\n    }\n\n    if (!hasTemplateSlots) {\n      // implicit default slot (on component)\n      slotsProperties.push(buildDefaultSlotProperty(undefined, children))\n    } else if (\n      implicitDefaultChildren.length &&\n      // #3766\n      // with whitespace: 'preserve', whitespaces between slots will end up in\n      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\n      implicitDefaultChildren.some(node => isNonWhitespaceContent(node))\n    ) {\n      // implicit default slot (mixed with named slots)\n      if (hasNamedDefaultSlot) {\n        context.onError(\n          createCompilerError(\n            ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\n            implicitDefaultChildren[0].loc\n          )\n        )\n      } else {\n        slotsProperties.push(\n          buildDefaultSlotProperty(undefined, implicitDefaultChildren)\n        )\n      }\n    }\n  }\n\n  const slotFlag = hasDynamicSlots\n    ? SlotFlags.DYNAMIC\n    : hasForwardedSlots(node.children)\n    ? SlotFlags.FORWARDED\n    : SlotFlags.STABLE\n\n  let slots = createObjectExpression(\n    slotsProperties.concat(\n      createObjectProperty(\n        `_`,\n        // 2 = compiled but dynamic = can skip normalization, but must run diff\n        // 1 = compiled and static = can skip normalization AND diff as optimized\n        createSimpleExpression(\n          slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``),\n          false\n        )\n      )\n    ),\n    loc\n  ) as SlotsExpression\n  if (dynamicSlots.length) {\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\n      slots,\n      createArrayExpression(dynamicSlots)\n    ]) as SlotsExpression\n  }\n\n  return {\n    slots,\n    hasDynamicSlots\n  }\n}\n\nfunction buildDynamicSlot(\n  name: ExpressionNode,\n  fn: FunctionExpression\n): ObjectExpression {\n  return createObjectExpression([\n    createObjectProperty(`name`, name),\n    createObjectProperty(`fn`, fn)\n  ])\n}\n\nfunction hasForwardedSlots(children: TemplateChildNode[]): boolean {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    switch (child.type) {\n      case NodeTypes.ELEMENT:\n        if (\n          child.tagType === ElementTypes.SLOT ||\n          hasForwardedSlots(child.children)\n        ) {\n          return true\n        }\n        break\n      case NodeTypes.IF:\n        if (hasForwardedSlots(child.branches)) return true\n        break\n      case NodeTypes.IF_BRANCH:\n      case NodeTypes.FOR:\n        if (hasForwardedSlots(child.children)) return true\n        break\n      default:\n        break\n    }\n  }\n  return false\n}\n\nfunction isNonWhitespaceContent(node: TemplateChildNode): boolean {\n  if (node.type !== NodeTypes.TEXT && node.type !== NodeTypes.TEXT_CALL)\n    return true\n  return node.type === NodeTypes.TEXT\n    ? !!node.content.trim()\n    : isNonWhitespaceContent(node.content)\n}\n","import { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  CallExpression,\n  ObjectExpression,\n  ElementNode,\n  DirectiveNode,\n  ExpressionNode,\n  ArrayExpression,\n  createCallExpression,\n  createArrayExpression,\n  createObjectProperty,\n  createSimpleExpression,\n  createObjectExpression,\n  Property,\n  ComponentNode,\n  VNodeCall,\n  TemplateTextChildNode,\n  DirectiveArguments,\n  createVNodeCall,\n  ConstantTypes\n} from '../ast'\nimport {\n  PatchFlags,\n  PatchFlagNames,\n  isSymbol,\n  isOn,\n  isObject,\n  isReservedProp,\n  capitalize,\n  camelize,\n  isBuiltInDirective\n} from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  RESOLVE_DIRECTIVE,\n  RESOLVE_COMPONENT,\n  RESOLVE_DYNAMIC_COMPONENT,\n  MERGE_PROPS,\n  NORMALIZE_CLASS,\n  NORMALIZE_STYLE,\n  NORMALIZE_PROPS,\n  TO_HANDLERS,\n  TELEPORT,\n  KEEP_ALIVE,\n  SUSPENSE,\n  UNREF,\n  GUARD_REACTIVE_PROPS\n} from '../runtimeHelpers'\nimport {\n  getInnerRange,\n  toValidAssetId,\n  findProp,\n  isCoreComponent,\n  isStaticArgOf,\n  findDir,\n  isStaticExp\n} from '../utils'\nimport { buildSlots } from './vSlot'\nimport { getConstantType } from './hoistStatic'\nimport { BindingTypes } from '../options'\nimport {\n  checkCompatEnabled,\n  CompilerDeprecationTypes,\n  isCompatEnabled\n} from '../compat/compatConfig'\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\n// import, which should be used instead of a resolveDirective call.\nconst directiveImportMap = new WeakMap<DirectiveNode, symbol>()\n\n// generate a JavaScript AST for this element's codegen\nexport const transformElement: NodeTransform = (node, context) => {\n  // perform the work on exit, after all child expressions have been\n  // processed and merged.\n  return function postTransformElement() {\n    node = context.currentNode!\n\n    if (\n      !(\n        node.type === NodeTypes.ELEMENT &&\n        (node.tagType === ElementTypes.ELEMENT ||\n          node.tagType === ElementTypes.COMPONENT)\n      )\n    ) {\n      return\n    }\n\n    const { tag, props } = node\n    const isComponent = node.tagType === ElementTypes.COMPONENT\n\n    // The goal of the transform is to create a codegenNode implementing the\n    // VNodeCall interface.\n    let vnodeTag = isComponent\n      ? resolveComponentType(node as ComponentNode, context)\n      : `\"${tag}\"`\n\n    const isDynamicComponent =\n      isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT\n\n    let vnodeProps: VNodeCall['props']\n    let vnodeChildren: VNodeCall['children']\n    let vnodePatchFlag: VNodeCall['patchFlag']\n    let patchFlag: number = 0\n    let vnodeDynamicProps: VNodeCall['dynamicProps']\n    let dynamicPropNames: string[] | undefined\n    let vnodeDirectives: VNodeCall['directives']\n\n    let shouldUseBlock =\n      // dynamic component may resolve to plain elements\n      isDynamicComponent ||\n      vnodeTag === TELEPORT ||\n      vnodeTag === SUSPENSE ||\n      (!isComponent &&\n        // <svg> and <foreignObject> must be forced into blocks so that block\n        // updates inside get proper isSVG flag at runtime. (#639, #643)\n        // This is technically web-specific, but splitting the logic out of core\n        // leads to too much unnecessary complexity.\n        (tag === 'svg' || tag === 'foreignObject'))\n\n    // props\n    if (props.length > 0) {\n      const propsBuildResult = buildProps(\n        node,\n        context,\n        undefined,\n        isComponent,\n        isDynamicComponent\n      )\n      vnodeProps = propsBuildResult.props\n      patchFlag = propsBuildResult.patchFlag\n      dynamicPropNames = propsBuildResult.dynamicPropNames\n      const directives = propsBuildResult.directives\n      vnodeDirectives =\n        directives && directives.length\n          ? (createArrayExpression(\n              directives.map(dir => buildDirectiveArgs(dir, context))\n            ) as DirectiveArguments)\n          : undefined\n\n      if (propsBuildResult.shouldUseBlock) {\n        shouldUseBlock = true\n      }\n    }\n\n    // children\n    if (node.children.length > 0) {\n      if (vnodeTag === KEEP_ALIVE) {\n        // Although a built-in component, we compile KeepAlive with raw children\n        // instead of slot functions so that it can be used inside Transition\n        // or other Transition-wrapping HOCs.\n        // To ensure correct updates with block optimizations, we need to:\n        // 1. Force keep-alive into a block. This avoids its children being\n        //    collected by a parent block.\n        shouldUseBlock = true\n        // 2. Force keep-alive to always be updated, since it uses raw children.\n        patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        if (__DEV__ && node.children.length > 1) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN, {\n              start: node.children[0].loc.start,\n              end: node.children[node.children.length - 1].loc.end,\n              source: ''\n            })\n          )\n        }\n      }\n\n      const shouldBuildAsSlots =\n        isComponent &&\n        // Teleport is not a real component and has dedicated runtime handling\n        vnodeTag !== TELEPORT &&\n        // explained above.\n        vnodeTag !== KEEP_ALIVE\n\n      if (shouldBuildAsSlots) {\n        const { slots, hasDynamicSlots } = buildSlots(node, context)\n        vnodeChildren = slots\n        if (hasDynamicSlots) {\n          patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        }\n      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\n        const child = node.children[0]\n        const type = child.type\n        // check for dynamic text children\n        const hasDynamicTextChild =\n          type === NodeTypes.INTERPOLATION ||\n          type === NodeTypes.COMPOUND_EXPRESSION\n        if (\n          hasDynamicTextChild &&\n          getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\n        ) {\n          patchFlag |= PatchFlags.TEXT\n        }\n        // pass directly if the only child is a text node\n        // (plain / interpolation / expression)\n        if (hasDynamicTextChild || type === NodeTypes.TEXT) {\n          vnodeChildren = child as TemplateTextChildNode\n        } else {\n          vnodeChildren = node.children\n        }\n      } else {\n        vnodeChildren = node.children\n      }\n    }\n\n    // patchFlag & dynamicPropNames\n    if (patchFlag !== 0) {\n      if (__DEV__) {\n        if (patchFlag < 0) {\n          // special flags (negative and mutually exclusive)\n          vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`\n        } else {\n          // bitwise flags\n          const flagNames = Object.keys(PatchFlagNames)\n            .map(Number)\n            .filter(n => n > 0 && patchFlag & n)\n            .map(n => PatchFlagNames[n])\n            .join(`, `)\n          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`\n        }\n      } else {\n        vnodePatchFlag = String(patchFlag)\n      }\n      if (dynamicPropNames && dynamicPropNames.length) {\n        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)\n      }\n    }\n\n    node.codegenNode = createVNodeCall(\n      context,\n      vnodeTag,\n      vnodeProps,\n      vnodeChildren,\n      vnodePatchFlag,\n      vnodeDynamicProps,\n      vnodeDirectives,\n      !!shouldUseBlock,\n      false /* disableTracking */,\n      isComponent,\n      node.loc\n    )\n  }\n}\n\nexport function resolveComponentType(\n  node: ComponentNode,\n  context: TransformContext,\n  ssr = false\n) {\n  let { tag } = node\n\n  // 1. dynamic component\n  const isExplicitDynamic = isComponentTag(tag)\n  const isProp = findProp(node, 'is')\n  if (isProp) {\n    if (\n      isExplicitDynamic ||\n      (__COMPAT__ &&\n        isCompatEnabled(\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n          context\n        ))\n    ) {\n      const exp =\n        isProp.type === NodeTypes.ATTRIBUTE\n          ? isProp.value && createSimpleExpression(isProp.value.content, true)\n          : isProp.exp\n      if (exp) {\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n          exp\n        ])\n      }\n    } else if (\n      isProp.type === NodeTypes.ATTRIBUTE &&\n      isProp.value!.content.startsWith('vue:')\n    ) {\n      // <button is=\"vue:xxx\">\n      // if not <component>, only is value that starts with \"vue:\" will be\n      // treated as component by the parse phase and reach here, unless it's\n      // compat mode where all is values are considered components\n      tag = isProp.value!.content.slice(4)\n    }\n  }\n\n  // 1.5 v-is (TODO: Deprecate)\n  const isDir = !isExplicitDynamic && findDir(node, 'is')\n  if (isDir && isDir.exp) {\n    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n      isDir.exp\n    ])\n  }\n\n  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\n  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)\n  if (builtIn) {\n    // built-ins are simply fallthroughs / have special handling during ssr\n    // so we don't need to import their runtime equivalents\n    if (!ssr) context.helper(builtIn)\n    return builtIn\n  }\n\n  // 3. user component (from setup bindings)\n  // this is skipped in browser build since browser builds do not perform\n  // binding analysis.\n  if (!__BROWSER__) {\n    const fromSetup = resolveSetupReference(tag, context)\n    if (fromSetup) {\n      return fromSetup\n    }\n    const dotIndex = tag.indexOf('.')\n    if (dotIndex > 0) {\n      const ns = resolveSetupReference(tag.slice(0, dotIndex), context)\n      if (ns) {\n        return ns + tag.slice(dotIndex)\n      }\n    }\n  }\n\n  // 4. Self referencing component (inferred from filename)\n  if (\n    !__BROWSER__ &&\n    context.selfName &&\n    capitalize(camelize(tag)) === context.selfName\n  ) {\n    context.helper(RESOLVE_COMPONENT)\n    // codegen.ts has special check for __self postfix when generating\n    // component imports, which will pass additional `maybeSelfReference` flag\n    // to `resolveComponent`.\n    context.components.add(tag + `__self`)\n    return toValidAssetId(tag, `component`)\n  }\n\n  // 5. user component (resolve)\n  context.helper(RESOLVE_COMPONENT)\n  context.components.add(tag)\n  return toValidAssetId(tag, `component`)\n}\n\nfunction resolveSetupReference(name: string, context: TransformContext) {\n  const bindings = context.bindingMetadata\n  if (!bindings || bindings.__isScriptSetup === false) {\n    return\n  }\n\n  const camelName = camelize(name)\n  const PascalName = capitalize(camelName)\n  const checkType = (type: BindingTypes) => {\n    if (bindings[name] === type) {\n      return name\n    }\n    if (bindings[camelName] === type) {\n      return camelName\n    }\n    if (bindings[PascalName] === type) {\n      return PascalName\n    }\n  }\n\n  const fromConst =\n    checkType(BindingTypes.SETUP_CONST) ||\n    checkType(BindingTypes.SETUP_REACTIVE_CONST)\n  if (fromConst) {\n    return context.inline\n      ? // in inline mode, const setup bindings (e.g. imports) can be used as-is\n        fromConst\n      : `$setup[${JSON.stringify(fromConst)}]`\n  }\n\n  const fromMaybeRef =\n    checkType(BindingTypes.SETUP_LET) ||\n    checkType(BindingTypes.SETUP_REF) ||\n    checkType(BindingTypes.SETUP_MAYBE_REF)\n  if (fromMaybeRef) {\n    return context.inline\n      ? // setup scope bindings that may be refs need to be unrefed\n        `${context.helperString(UNREF)}(${fromMaybeRef})`\n      : `$setup[${JSON.stringify(fromMaybeRef)}]`\n  }\n}\n\nexport type PropsExpression = ObjectExpression | CallExpression | ExpressionNode\n\nexport function buildProps(\n  node: ElementNode,\n  context: TransformContext,\n  props: ElementNode['props'] = node.props,\n  isComponent: boolean,\n  isDynamicComponent: boolean,\n  ssr = false\n): {\n  props: PropsExpression | undefined\n  directives: DirectiveNode[]\n  patchFlag: number\n  dynamicPropNames: string[]\n  shouldUseBlock: boolean\n} {\n  const { tag, loc: elementLoc, children } = node\n  let properties: ObjectExpression['properties'] = []\n  const mergeArgs: PropsExpression[] = []\n  const runtimeDirectives: DirectiveNode[] = []\n  const hasChildren = children.length > 0\n  let shouldUseBlock = false\n\n  // patchFlag analysis\n  let patchFlag = 0\n  let hasRef = false\n  let hasClassBinding = false\n  let hasStyleBinding = false\n  let hasHydrationEventBinding = false\n  let hasDynamicKeys = false\n  let hasVnodeHook = false\n  const dynamicPropNames: string[] = []\n\n  const analyzePatchFlag = ({ key, value }: Property) => {\n    if (isStaticExp(key)) {\n      const name = key.content\n      const isEventHandler = isOn(name)\n      if (\n        isEventHandler &&\n        (!isComponent || isDynamicComponent) &&\n        // omit the flag for click handlers because hydration gives click\n        // dedicated fast path.\n        name.toLowerCase() !== 'onclick' &&\n        // omit v-model handlers\n        name !== 'onUpdate:modelValue' &&\n        // omit onVnodeXXX hooks\n        !isReservedProp(name)\n      ) {\n        hasHydrationEventBinding = true\n      }\n\n      if (isEventHandler && isReservedProp(name)) {\n        hasVnodeHook = true\n      }\n\n      if (\n        value.type === NodeTypes.JS_CACHE_EXPRESSION ||\n        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||\n          value.type === NodeTypes.COMPOUND_EXPRESSION) &&\n          getConstantType(value, context) > 0)\n      ) {\n        // skip if the prop is a cached handler or has constant value\n        return\n      }\n\n      if (name === 'ref') {\n        hasRef = true\n      } else if (name === 'class') {\n        hasClassBinding = true\n      } else if (name === 'style') {\n        hasStyleBinding = true\n      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {\n        dynamicPropNames.push(name)\n      }\n\n      // treat the dynamic class and style binding of the component as dynamic props\n      if (\n        isComponent &&\n        (name === 'class' || name === 'style') &&\n        !dynamicPropNames.includes(name)\n      ) {\n        dynamicPropNames.push(name)\n      }\n    } else {\n      hasDynamicKeys = true\n    }\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    // static attribute\n    const prop = props[i]\n    if (prop.type === NodeTypes.ATTRIBUTE) {\n      const { loc, name, value } = prop\n      let isStatic = true\n      if (name === 'ref') {\n        hasRef = true\n        if (context.scopes.vFor > 0) {\n          properties.push(\n            createObjectProperty(\n              createSimpleExpression('ref_for', true),\n              createSimpleExpression('true')\n            )\n          )\n        }\n        // in inline mode there is no setupState object, so we can't use string\n        // keys to set the ref. Instead, we need to transform it to pass the\n        // actual ref instead.\n        if (\n          !__BROWSER__ &&\n          value &&\n          context.inline &&\n          context.bindingMetadata[value.content]\n        ) {\n          isStatic = false\n          properties.push(\n            createObjectProperty(\n              createSimpleExpression('ref_key', true),\n              createSimpleExpression(value.content, true, value.loc)\n            )\n          )\n        }\n      }\n      // skip is on <component>, or is=\"vue:xxx\"\n      if (\n        name === 'is' &&\n        (isComponentTag(tag) ||\n          (value && value.content.startsWith('vue:')) ||\n          (__COMPAT__ &&\n            isCompatEnabled(\n              CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n              context\n            )))\n      ) {\n        continue\n      }\n      properties.push(\n        createObjectProperty(\n          createSimpleExpression(\n            name,\n            true,\n            getInnerRange(loc, 0, name.length)\n          ),\n          createSimpleExpression(\n            value ? value.content : '',\n            isStatic,\n            value ? value.loc : loc\n          )\n        )\n      )\n    } else {\n      // directives\n      const { name, arg, exp, loc } = prop\n      const isVBind = name === 'bind'\n      const isVOn = name === 'on'\n\n      // skip v-slot - it is handled by its dedicated transform.\n      if (name === 'slot') {\n        if (!isComponent) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, loc)\n          )\n        }\n        continue\n      }\n      // skip v-once/v-memo - they are handled by dedicated transforms.\n      if (name === 'once' || name === 'memo') {\n        continue\n      }\n      // skip v-is and :is on <component>\n      if (\n        name === 'is' ||\n        (isVBind &&\n          isStaticArgOf(arg, 'is') &&\n          (isComponentTag(tag) ||\n            (__COMPAT__ &&\n              isCompatEnabled(\n                CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n                context\n              ))))\n      ) {\n        continue\n      }\n      // skip v-on in SSR compilation\n      if (isVOn && ssr) {\n        continue\n      }\n\n      if (\n        // #938: elements with dynamic keys should be forced into blocks\n        (isVBind && isStaticArgOf(arg, 'key')) ||\n        // inline before-update hooks need to force block so that it is invoked\n        // before children\n        (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))\n      ) {\n        shouldUseBlock = true\n      }\n\n      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {\n        properties.push(\n          createObjectProperty(\n            createSimpleExpression('ref_for', true),\n            createSimpleExpression('true')\n          )\n        )\n      }\n\n      // special case for v-bind and v-on with no argument\n      if (!arg && (isVBind || isVOn)) {\n        hasDynamicKeys = true\n        if (exp) {\n          if (properties.length) {\n            mergeArgs.push(\n              createObjectExpression(dedupeProperties(properties), elementLoc)\n            )\n            properties = []\n          }\n          if (isVBind) {\n            if (__COMPAT__) {\n              // 2.x v-bind object order compat\n              if (__DEV__) {\n                const hasOverridableKeys = mergeArgs.some(arg => {\n                  if (arg.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n                    return arg.properties.some(({ key }) => {\n                      if (\n                        key.type !== NodeTypes.SIMPLE_EXPRESSION ||\n                        !key.isStatic\n                      ) {\n                        return true\n                      }\n                      return (\n                        key.content !== 'class' &&\n                        key.content !== 'style' &&\n                        !isOn(key.content)\n                      )\n                    })\n                  } else {\n                    // dynamic expression\n                    return true\n                  }\n                })\n                if (hasOverridableKeys) {\n                  checkCompatEnabled(\n                    CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\n                    context,\n                    loc\n                  )\n                }\n              }\n\n              if (\n                isCompatEnabled(\n                  CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\n                  context\n                )\n              ) {\n                mergeArgs.unshift(exp)\n                continue\n              }\n            }\n\n            mergeArgs.push(exp)\n          } else {\n            // v-on=\"obj\" -> toHandlers(obj)\n            mergeArgs.push({\n              type: NodeTypes.JS_CALL_EXPRESSION,\n              loc,\n              callee: context.helper(TO_HANDLERS),\n              arguments: [exp]\n            })\n          }\n        } else {\n          context.onError(\n            createCompilerError(\n              isVBind\n                ? ErrorCodes.X_V_BIND_NO_EXPRESSION\n                : ErrorCodes.X_V_ON_NO_EXPRESSION,\n              loc\n            )\n          )\n        }\n        continue\n      }\n\n      const directiveTransform = context.directiveTransforms[name]\n      if (directiveTransform) {\n        // has built-in directive transform.\n        const { props, needRuntime } = directiveTransform(prop, node, context)\n        !ssr && props.forEach(analyzePatchFlag)\n        properties.push(...props)\n        if (needRuntime) {\n          runtimeDirectives.push(prop)\n          if (isSymbol(needRuntime)) {\n            directiveImportMap.set(prop, needRuntime)\n          }\n        }\n      } else if (!isBuiltInDirective(name)) {\n        // no built-in transform, this is a user custom directive.\n        runtimeDirectives.push(prop)\n        // custom dirs may use beforeUpdate so they need to force blocks\n        // to ensure before-update gets called before children update\n        if (hasChildren) {\n          shouldUseBlock = true\n        }\n      }\n    }\n  }\n\n  let propsExpression: PropsExpression | undefined = undefined\n\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\n  if (mergeArgs.length) {\n    if (properties.length) {\n      mergeArgs.push(\n        createObjectExpression(dedupeProperties(properties), elementLoc)\n      )\n    }\n    if (mergeArgs.length > 1) {\n      propsExpression = createCallExpression(\n        context.helper(MERGE_PROPS),\n        mergeArgs,\n        elementLoc\n      )\n    } else {\n      // single v-bind with nothing else - no need for a mergeProps call\n      propsExpression = mergeArgs[0]\n    }\n  } else if (properties.length) {\n    propsExpression = createObjectExpression(\n      dedupeProperties(properties),\n      elementLoc\n    )\n  }\n\n  // patchFlag analysis\n  if (hasDynamicKeys) {\n    patchFlag |= PatchFlags.FULL_PROPS\n  } else {\n    if (hasClassBinding && !isComponent) {\n      patchFlag |= PatchFlags.CLASS\n    }\n    if (hasStyleBinding && !isComponent) {\n      patchFlag |= PatchFlags.STYLE\n    }\n    if (dynamicPropNames.length) {\n      patchFlag |= PatchFlags.PROPS\n    }\n    if (hasHydrationEventBinding) {\n      patchFlag |= PatchFlags.HYDRATE_EVENTS\n    }\n  }\n  if (\n    !shouldUseBlock &&\n    (patchFlag === 0 || patchFlag === PatchFlags.HYDRATE_EVENTS) &&\n    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)\n  ) {\n    patchFlag |= PatchFlags.NEED_PATCH\n  }\n\n  // pre-normalize props, SSR is skipped for now\n  if (!context.inSSR && propsExpression) {\n    switch (propsExpression.type) {\n      case NodeTypes.JS_OBJECT_EXPRESSION:\n        // means that there is no v-bind,\n        // but still need to deal with dynamic key binding\n        let classKeyIndex = -1\n        let styleKeyIndex = -1\n        let hasDynamicKey = false\n\n        for (let i = 0; i < propsExpression.properties.length; i++) {\n          const key = propsExpression.properties[i].key\n          if (isStaticExp(key)) {\n            if (key.content === 'class') {\n              classKeyIndex = i\n            } else if (key.content === 'style') {\n              styleKeyIndex = i\n            }\n          } else if (!key.isHandlerKey) {\n            hasDynamicKey = true\n          }\n        }\n\n        const classProp = propsExpression.properties[classKeyIndex]\n        const styleProp = propsExpression.properties[styleKeyIndex]\n\n        // no dynamic key\n        if (!hasDynamicKey) {\n          if (classProp && !isStaticExp(classProp.value)) {\n            classProp.value = createCallExpression(\n              context.helper(NORMALIZE_CLASS),\n              [classProp.value]\n            )\n          }\n          if (\n            styleProp &&\n            // the static style is compiled into an object,\n            // so use `hasStyleBinding` to ensure that it is a dynamic style binding\n            (hasStyleBinding ||\n              (styleProp.value.type === NodeTypes.SIMPLE_EXPRESSION &&\n                styleProp.value.content.trim()[0] === `[`) ||\n              // v-bind:style and style both exist,\n              // v-bind:style with static literal object\n              styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)\n          ) {\n            styleProp.value = createCallExpression(\n              context.helper(NORMALIZE_STYLE),\n              [styleProp.value]\n            )\n          }\n        } else {\n          // dynamic key binding, wrap with `normalizeProps`\n          propsExpression = createCallExpression(\n            context.helper(NORMALIZE_PROPS),\n            [propsExpression]\n          )\n        }\n        break\n      case NodeTypes.JS_CALL_EXPRESSION:\n        // mergeProps call, do nothing\n        break\n      default:\n        // single v-bind\n        propsExpression = createCallExpression(\n          context.helper(NORMALIZE_PROPS),\n          [\n            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\n              propsExpression\n            ])\n          ]\n        )\n        break\n    }\n  }\n\n  return {\n    props: propsExpression,\n    directives: runtimeDirectives,\n    patchFlag,\n    dynamicPropNames,\n    shouldUseBlock\n  }\n}\n\n// Dedupe props in an object literal.\n// Literal duplicated attributes would have been warned during the parse phase,\n// however, it's possible to encounter duplicated `onXXX` handlers with different\n// modifiers. We also need to merge static and dynamic class / style attributes.\n// - onXXX handlers / style: merge into array\n// - class: merge into single expression with concatenation\nfunction dedupeProperties(properties: Property[]): Property[] {\n  const knownProps: Map<string, Property> = new Map()\n  const deduped: Property[] = []\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    // dynamic keys are always allowed\n    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {\n      deduped.push(prop)\n      continue\n    }\n    const name = prop.key.content\n    const existing = knownProps.get(name)\n    if (existing) {\n      if (name === 'style' || name === 'class' || isOn(name)) {\n        mergeAsArray(existing, prop)\n      }\n      // unexpected duplicate, should have emitted error during parse\n    } else {\n      knownProps.set(name, prop)\n      deduped.push(prop)\n    }\n  }\n  return deduped\n}\n\nfunction mergeAsArray(existing: Property, incoming: Property) {\n  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {\n    existing.value.elements.push(incoming.value)\n  } else {\n    existing.value = createArrayExpression(\n      [existing.value, incoming.value],\n      existing.loc\n    )\n  }\n}\n\nexport function buildDirectiveArgs(\n  dir: DirectiveNode,\n  context: TransformContext\n): ArrayExpression {\n  const dirArgs: ArrayExpression['elements'] = []\n  const runtime = directiveImportMap.get(dir)\n  if (runtime) {\n    // built-in directive with runtime\n    dirArgs.push(context.helperString(runtime))\n  } else {\n    // user directive.\n    // see if we have directives exposed via <script setup>\n    const fromSetup =\n      !__BROWSER__ && resolveSetupReference('v-' + dir.name, context)\n    if (fromSetup) {\n      dirArgs.push(fromSetup)\n    } else {\n      // inject statement for resolving directive\n      context.helper(RESOLVE_DIRECTIVE)\n      context.directives.add(dir.name)\n      dirArgs.push(toValidAssetId(dir.name, `directive`))\n    }\n  }\n  const { loc } = dir\n  if (dir.exp) dirArgs.push(dir.exp)\n  if (dir.arg) {\n    if (!dir.exp) {\n      dirArgs.push(`void 0`)\n    }\n    dirArgs.push(dir.arg)\n  }\n  if (Object.keys(dir.modifiers).length) {\n    if (!dir.arg) {\n      if (!dir.exp) {\n        dirArgs.push(`void 0`)\n      }\n      dirArgs.push(`void 0`)\n    }\n    const trueExpression = createSimpleExpression(`true`, false, loc)\n    dirArgs.push(\n      createObjectExpression(\n        dir.modifiers.map(modifier =>\n          createObjectProperty(modifier, trueExpression)\n        ),\n        loc\n      )\n    )\n  }\n  return createArrayExpression(dirArgs, dir.loc)\n}\n\nfunction stringifyDynamicPropNames(props: string[]): string {\n  let propsNamesString = `[`\n  for (let i = 0, l = props.length; i < l; i++) {\n    propsNamesString += JSON.stringify(props[i])\n    if (i < l - 1) propsNamesString += ', '\n  }\n  return propsNamesString + `]`\n}\n\nfunction isComponentTag(tag: string) {\n  return tag === 'component' || tag === 'Component'\n}\n","import { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  CallExpression,\n  createCallExpression,\n  ExpressionNode,\n  SlotOutletNode,\n  createFunctionExpression\n} from '../ast'\nimport { isSlotOutlet, isStaticArgOf, isStaticExp } from '../utils'\nimport { buildProps, PropsExpression } from './transformElement'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { RENDER_SLOT } from '../runtimeHelpers'\nimport { camelize } from '@vue/shared/'\n\nexport const transformSlotOutlet: NodeTransform = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const { children, loc } = node\n    const { slotName, slotProps } = processSlotOutlet(node, context)\n\n    const slotArgs: CallExpression['arguments'] = [\n      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\n      slotName,\n      '{}',\n      'undefined',\n      'true'\n    ]\n    let expectedLen = 2\n\n    if (slotProps) {\n      slotArgs[2] = slotProps\n      expectedLen = 3\n    }\n\n    if (children.length) {\n      slotArgs[3] = createFunctionExpression([], children, false, false, loc)\n      expectedLen = 4\n    }\n\n    if (context.scopeId && !context.slotted) {\n      expectedLen = 5\n    }\n    slotArgs.splice(expectedLen) // remove unused arguments\n\n    node.codegenNode = createCallExpression(\n      context.helper(RENDER_SLOT),\n      slotArgs,\n      loc\n    )\n  }\n}\n\ninterface SlotOutletProcessResult {\n  slotName: string | ExpressionNode\n  slotProps: PropsExpression | undefined\n}\n\nexport function processSlotOutlet(\n  node: SlotOutletNode,\n  context: TransformContext\n): SlotOutletProcessResult {\n  let slotName: string | ExpressionNode = `\"default\"`\n  let slotProps: PropsExpression | undefined = undefined\n\n  const nonNameProps = []\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (p.value) {\n        if (p.name === 'name') {\n          slotName = JSON.stringify(p.value.content)\n        } else {\n          p.name = camelize(p.name)\n          nonNameProps.push(p)\n        }\n      }\n    } else {\n      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {\n        if (p.exp) slotName = p.exp\n      } else {\n        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\n          p.arg.content = camelize(p.arg.content)\n        }\n        nonNameProps.push(p)\n      }\n    }\n  }\n\n  if (nonNameProps.length > 0) {\n    const { props, directives } = buildProps(\n      node,\n      context,\n      nonNameProps,\n      false,\n      false\n    )\n    slotProps = props\n\n    if (directives.length) {\n      context.onError(\n        createCompilerError(\n          ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n          directives[0].loc\n        )\n      )\n    }\n  }\n\n  return {\n    slotName,\n    slotProps\n  }\n}\n","import { DirectiveTransform, DirectiveTransformResult } from '../transform'\nimport {\n  createCompoundExpression,\n  createObjectProperty,\n  createSimpleExpression,\n  DirectiveNode,\n  ElementTypes,\n  ExpressionNode,\n  NodeTypes,\n  SimpleExpressionNode\n} from '../ast'\nimport { camelize, toHandlerKey } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport { validateBrowserExpression } from '../validateExpression'\nimport { hasScopeRef, isMemberExpression } from '../utils'\nimport { TO_HANDLER_KEY } from '../runtimeHelpers'\n\nconst fnExpRE =\n  /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/\n\nexport interface VOnDirectiveNode extends DirectiveNode {\n  // v-on without arg is handled directly in ./transformElements.ts due to it affecting\n  // codegen for the entire props object. This transform here is only for v-on\n  // *with* args.\n  arg: ExpressionNode\n  // exp is guaranteed to be a simple expression here because v-on w/ arg is\n  // skipped by transformExpression as a special case.\n  exp: SimpleExpressionNode | undefined\n}\n\nexport const transformOn: DirectiveTransform = (\n  dir,\n  node,\n  context,\n  augmentor\n) => {\n  const { loc, modifiers, arg } = dir as VOnDirectiveNode\n  if (!dir.exp && !modifiers.length) {\n    context.onError(createCompilerError(ErrorCodes.X_V_ON_NO_EXPRESSION, loc))\n  }\n  let eventName: ExpressionNode\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n    if (arg.isStatic) {\n      let rawName = arg.content\n      // TODO deprecate @vnodeXXX usage\n      if (rawName.startsWith('vue:')) {\n        rawName = `vnode-${rawName.slice(4)}`\n      }\n      // for all event listeners, auto convert it to camelCase. See issue #2249\n      eventName = createSimpleExpression(\n        toHandlerKey(camelize(rawName)),\n        true,\n        arg.loc\n      )\n    } else {\n      // #2388\n      eventName = createCompoundExpression([\n        `${context.helperString(TO_HANDLER_KEY)}(`,\n        arg,\n        `)`\n      ])\n    }\n  } else {\n    // already a compound expression.\n    eventName = arg\n    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`)\n    eventName.children.push(`)`)\n  }\n\n  // handler processing\n  let exp: ExpressionNode | undefined = dir.exp as\n    | SimpleExpressionNode\n    | undefined\n  if (exp && !exp.content.trim()) {\n    exp = undefined\n  }\n  let shouldCache: boolean = context.cacheHandlers && !exp && !context.inVOnce\n  if (exp) {\n    const isMemberExp = isMemberExpression(exp.content, context)\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\n    const hasMultipleStatements = exp.content.includes(`;`)\n\n    // process the expression since it's been skipped\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      isInlineStatement && context.addIdentifiers(`$event`)\n      exp = dir.exp = processExpression(\n        exp,\n        context,\n        false,\n        hasMultipleStatements\n      )\n      isInlineStatement && context.removeIdentifiers(`$event`)\n      // with scope analysis, the function is hoistable if it has no reference\n      // to scope variables.\n      shouldCache =\n        context.cacheHandlers &&\n        // unnecessary to cache inside v-once\n        !context.inVOnce &&\n        // runtime constants don't need to be cached\n        // (this is analyzed by compileScript in SFC <script setup>)\n        !(exp.type === NodeTypes.SIMPLE_EXPRESSION && exp.constType > 0) &&\n        // #1541 bail if this is a member exp handler passed to a component -\n        // we need to use the original function to preserve arity,\n        // e.g. <transition> relies on checking cb.length to determine\n        // transition end handling. Inline function is ok since its arity\n        // is preserved even when cached.\n        !(isMemberExp && node.tagType === ElementTypes.COMPONENT) &&\n        // bail if the function references closure variables (v-for, v-slot)\n        // it must be passed fresh to avoid stale values.\n        !hasScopeRef(exp, context.identifiers)\n      // If the expression is optimizable and is a member expression pointing\n      // to a function, turn it into invocation (and wrap in an arrow function\n      // below) so that it always accesses the latest value when called - thus\n      // avoiding the need to be patched.\n      if (shouldCache && isMemberExp) {\n        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          exp.content = `${exp.content} && ${exp.content}(...args)`\n        } else {\n          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`]\n        }\n      }\n    }\n\n    if (__DEV__ && __BROWSER__) {\n      validateBrowserExpression(\n        exp as SimpleExpressionNode,\n        context,\n        false,\n        hasMultipleStatements\n      )\n    }\n\n    if (isInlineStatement || (shouldCache && isMemberExp)) {\n      // wrap inline statement in a function expression\n      exp = createCompoundExpression([\n        `${\n          isInlineStatement\n            ? !__BROWSER__ && context.isTS\n              ? `($event: any)`\n              : `$event`\n            : `${\n                !__BROWSER__ && context.isTS ? `\\n//@ts-ignore\\n` : ``\n              }(...args)`\n        } => ${hasMultipleStatements ? `{` : `(`}`,\n        exp,\n        hasMultipleStatements ? `}` : `)`\n      ])\n    }\n  }\n\n  let ret: DirectiveTransformResult = {\n    props: [\n      createObjectProperty(\n        eventName,\n        exp || createSimpleExpression(`() => {}`, false, loc)\n      )\n    ]\n  }\n\n  // apply extended compiler augmentor\n  if (augmentor) {\n    ret = augmentor(ret)\n  }\n\n  if (shouldCache) {\n    // cache handlers so that it's always the same handler being passed down.\n    // this avoids unnecessary re-renders when users use inline handlers on\n    // components.\n    ret.props[0].value = context.cache(ret.props[0].value)\n  }\n\n  // mark the key as handler for props normalization check\n  ret.props.forEach(p => (p.key.isHandlerKey = true))\n  return ret\n}\n","import { DirectiveTransform } from '../transform'\nimport {\n  createObjectProperty,\n  createSimpleExpression,\n  ExpressionNode,\n  NodeTypes\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { camelize } from '@vue/shared'\nimport { CAMELIZE } from '../runtimeHelpers'\n\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\n// codegen for the entire props object. This transform here is only for v-bind\n// *with* args.\nexport const transformBind: DirectiveTransform = (dir, _node, context) => {\n  const { exp, modifiers, loc } = dir\n  const arg = dir.arg!\n\n  if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {\n    arg.children.unshift(`(`)\n    arg.children.push(`) || \"\"`)\n  } else if (!arg.isStatic) {\n    arg.content = `${arg.content} || \"\"`\n  }\n\n  // .sync is replaced by v-model:arg\n  if (modifiers.includes('camel')) {\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n      if (arg.isStatic) {\n        arg.content = camelize(arg.content)\n      } else {\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`\n      }\n    } else {\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)\n      arg.children.push(`)`)\n    }\n  }\n\n  if (!context.inSSR) {\n    if (modifiers.includes('prop')) {\n      injectPrefix(arg, '.')\n    }\n    if (modifiers.includes('attr')) {\n      injectPrefix(arg, '^')\n    }\n  }\n\n  if (\n    !exp ||\n    (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())\n  ) {\n    context.onError(createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc))\n    return {\n      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\n    }\n  }\n\n  return {\n    props: [createObjectProperty(arg, exp)]\n  }\n}\n\nconst injectPrefix = (arg: ExpressionNode, prefix: string) => {\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n    if (arg.isStatic) {\n      arg.content = prefix + arg.content\n    } else {\n      arg.content = `\\`${prefix}\\${${arg.content}}\\``\n    }\n  } else {\n    arg.children.unshift(`'${prefix}' + (`)\n    arg.children.push(`)`)\n  }\n}\n","import { NodeTransform } from '../transform'\nimport {\n  NodeTypes,\n  CompoundExpressionNode,\n  createCallExpression,\n  CallExpression,\n  ElementTypes,\n  ConstantTypes,\n  createCompoundExpression\n} from '../ast'\nimport { isText } from '../utils'\nimport { CREATE_TEXT } from '../runtimeHelpers'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\nimport { getConstantType } from './hoistStatic'\n\n// Merge adjacent text nodes and expressions into a single expression\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\nexport const transformText: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ROOT ||\n    node.type === NodeTypes.ELEMENT ||\n    node.type === NodeTypes.FOR ||\n    node.type === NodeTypes.IF_BRANCH\n  ) {\n    // perform the transform on node exit so that all expressions have already\n    // been processed.\n    return () => {\n      const children = node.children\n      let currentContainer: CompoundExpressionNode | undefined = undefined\n      let hasText = false\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        if (isText(child)) {\n          hasText = true\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j]\n            if (isText(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = createCompoundExpression(\n                  [child],\n                  child.loc\n                )\n              }\n              // merge adjacent text node into current\n              currentContainer.children.push(` + `, next)\n              children.splice(j, 1)\n              j--\n            } else {\n              currentContainer = undefined\n              break\n            }\n          }\n        }\n      }\n\n      if (\n        !hasText ||\n        // if this is a plain element with a single text child, leave it\n        // as-is since the runtime has dedicated fast path for this by directly\n        // setting textContent of the element.\n        // for component root it's always normalized anyway.\n        (children.length === 1 &&\n          (node.type === NodeTypes.ROOT ||\n            (node.type === NodeTypes.ELEMENT &&\n              node.tagType === ElementTypes.ELEMENT &&\n              // #3756\n              // custom directives can potentially add DOM elements arbitrarily,\n              // we need to avoid setting textContent of the element at runtime\n              // to avoid accidentally overwriting the DOM elements added\n              // by the user through custom directives.\n              !node.props.find(\n                p =>\n                  p.type === NodeTypes.DIRECTIVE &&\n                  !context.directiveTransforms[p.name]\n              ) &&\n              // in compat mode, <template> tags with no special directives\n              // will be rendered as a fragment so its children must be\n              // converted into vnodes.\n              !(__COMPAT__ && node.tag === 'template'))))\n      ) {\n        return\n      }\n\n      // pre-convert text nodes into createTextVNode(text) calls to avoid\n      // runtime normalization.\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {\n          const callArgs: CallExpression['arguments'] = []\n          // createTextVNode defaults to single whitespace, so if it is a\n          // single space the code could be an empty call to save bytes.\n          if (child.type !== NodeTypes.TEXT || child.content !== ' ') {\n            callArgs.push(child)\n          }\n          // mark dynamic text with flag so it gets patched inside a block\n          if (\n            !context.ssr &&\n            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\n          ) {\n            callArgs.push(\n              PatchFlags.TEXT +\n                (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.TEXT]} */` : ``)\n            )\n          }\n          children[i] = {\n            type: NodeTypes.TEXT_CALL,\n            content: child,\n            loc: child.loc,\n            codegenNode: createCallExpression(\n              context.helper(CREATE_TEXT),\n              callArgs\n            )\n          }\n        }\n      }\n    }\n  }\n}\n","import { NodeTransform } from '../transform'\nimport { findDir } from '../utils'\nimport { ElementNode, ForNode, IfNode, NodeTypes } from '../ast'\nimport { SET_BLOCK_TRACKING } from '../runtimeHelpers'\n\nconst seen = new WeakSet()\n\nexport const transformOnce: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {\n    if (seen.has(node) || context.inVOnce) {\n      return\n    }\n    seen.add(node)\n    context.inVOnce = true\n    context.helper(SET_BLOCK_TRACKING)\n    return () => {\n      context.inVOnce = false\n      const cur = context.currentNode as ElementNode | IfNode | ForNode\n      if (cur.codegenNode) {\n        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)\n      }\n    }\n  }\n}\n","import { DirectiveTransform } from '../transform'\nimport {\n  createSimpleExpression,\n  createObjectProperty,\n  createCompoundExpression,\n  NodeTypes,\n  Property,\n  ElementTypes,\n  ExpressionNode,\n  ConstantTypes\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  isMemberExpression,\n  isSimpleIdentifier,\n  hasScopeRef,\n  isStaticExp\n} from '../utils'\nimport { IS_REF } from '../runtimeHelpers'\nimport { BindingTypes } from '../options'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const { exp, arg } = dir\n  if (!exp) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_NO_EXPRESSION, dir.loc)\n    )\n    return createTransformProps()\n  }\n\n  const rawExp = exp.loc.source\n  const expString =\n    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp\n\n  // im SFC <script setup> inline mode, the exp may have been transformed into\n  // _unref(exp)\n  const bindingType = context.bindingMetadata[rawExp]\n  const maybeRef =\n    !__BROWSER__ &&\n    context.inline &&\n    bindingType &&\n    bindingType !== BindingTypes.SETUP_CONST\n\n  if (\n    !expString.trim() ||\n    (!isMemberExpression(expString, context) && !maybeRef)\n  ) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    isSimpleIdentifier(expString) &&\n    context.identifiers[expString]\n  ) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  const propName = arg ? arg : createSimpleExpression('modelValue', true)\n  const eventName = arg\n    ? isStaticExp(arg)\n      ? `onUpdate:${arg.content}`\n      : createCompoundExpression(['\"onUpdate:\" + ', arg])\n    : `onUpdate:modelValue`\n\n  let assignmentExp: ExpressionNode\n  const eventArg = context.isTS ? `($event: any)` : `$event`\n  if (maybeRef) {\n    if (bindingType === BindingTypes.SETUP_REF) {\n      // v-model used on known ref.\n      assignmentExp = createCompoundExpression([\n        `${eventArg} => ((`,\n        createSimpleExpression(rawExp, false, exp.loc),\n        `).value = $event)`\n      ])\n    } else {\n      // v-model used on a potentially ref binding in <script setup> inline mode.\n      // the assignment needs to check whether the binding is actually a ref.\n      const altAssignment =\n        bindingType === BindingTypes.SETUP_LET ? `${rawExp} = $event` : `null`\n      assignmentExp = createCompoundExpression([\n        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,\n        createSimpleExpression(rawExp, false, exp.loc),\n        `).value = $event : ${altAssignment})`\n      ])\n    }\n  } else {\n    assignmentExp = createCompoundExpression([\n      `${eventArg} => ((`,\n      exp,\n      `) = $event)`\n    ])\n  }\n\n  const props = [\n    // modelValue: foo\n    createObjectProperty(propName, dir.exp!),\n    // \"onUpdate:modelValue\": $event => (foo = $event)\n    createObjectProperty(eventName, assignmentExp)\n  ]\n\n  // cache v-model handler if applicable (when it doesn't refer any scope vars)\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    !context.inVOnce &&\n    context.cacheHandlers &&\n    !hasScopeRef(exp, context.identifiers)\n  ) {\n    props[1].value = context.cache(props[1].value)\n  }\n\n  // modelModifiers: { foo: true, \"bar-baz\": true }\n  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {\n    const modifiers = dir.modifiers\n      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\n      .join(`, `)\n    const modifiersKey = arg\n      ? isStaticExp(arg)\n        ? `${arg.content}Modifiers`\n        : createCompoundExpression([arg, ' + \"Modifiers\"'])\n      : `modelModifiers`\n    props.push(\n      createObjectProperty(\n        modifiersKey,\n        createSimpleExpression(\n          `{ ${modifiers} }`,\n          false,\n          dir.loc,\n          ConstantTypes.CAN_HOIST\n        )\n      )\n    )\n  }\n\n  return createTransformProps(props)\n}\n\nfunction createTransformProps(props: Property[] = []) {\n  return { props }\n}\n","import { RESOLVE_FILTER } from '../runtimeHelpers'\nimport {\n  AttributeNode,\n  DirectiveNode,\n  NodeTransform,\n  NodeTypes,\n  SimpleExpressionNode,\n  toValidAssetId,\n  TransformContext\n} from '@vue/compiler-core'\nimport {\n  CompilerDeprecationTypes,\n  isCompatEnabled,\n  warnDeprecation\n} from './compatConfig'\nimport { ExpressionNode } from '../ast'\n\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/\n\nexport const transformFilter: NodeTransform = (node, context) => {\n  if (!isCompatEnabled(CompilerDeprecationTypes.COMPILER_FILTERS, context)) {\n    return\n  }\n\n  if (node.type === NodeTypes.INTERPOLATION) {\n    // filter rewrite is applied before expression transform so only\n    // simple expressions are possible at this stage\n    rewriteFilter(node.content, context)\n  }\n\n  if (node.type === NodeTypes.ELEMENT) {\n    node.props.forEach((prop: AttributeNode | DirectiveNode) => {\n      if (\n        prop.type === NodeTypes.DIRECTIVE &&\n        prop.name !== 'for' &&\n        prop.exp\n      ) {\n        rewriteFilter(prop.exp, context)\n      }\n    })\n  }\n}\n\nfunction rewriteFilter(node: ExpressionNode, context: TransformContext) {\n  if (node.type === NodeTypes.SIMPLE_EXPRESSION) {\n    parseFilter(node, context)\n  } else {\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i]\n      if (typeof child !== 'object') continue\n      if (child.type === NodeTypes.SIMPLE_EXPRESSION) {\n        parseFilter(child, context)\n      } else if (child.type === NodeTypes.COMPOUND_EXPRESSION) {\n        rewriteFilter(node, context)\n      } else if (child.type === NodeTypes.INTERPOLATION) {\n        rewriteFilter(child.content, context)\n      }\n    }\n  }\n}\n\nfunction parseFilter(node: SimpleExpressionNode, context: TransformContext) {\n  const exp = node.content\n  let inSingle = false\n  let inDouble = false\n  let inTemplateString = false\n  let inRegex = false\n  let curly = 0\n  let square = 0\n  let paren = 0\n  let lastFilterIndex = 0\n  let c,\n    prev,\n    i: number,\n    expression,\n    filters: string[] = []\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c\n    c = exp.charCodeAt(i)\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5c) inSingle = false\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5c) inDouble = false\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5c) inTemplateString = false\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5c) inRegex = false\n    } else if (\n      c === 0x7c && // pipe\n      exp.charCodeAt(i + 1) !== 0x7c &&\n      exp.charCodeAt(i - 1) !== 0x7c &&\n      !curly &&\n      !square &&\n      !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1\n        expression = exp.slice(0, i).trim()\n      } else {\n        pushFilter()\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true\n          break // \"\n        case 0x27:\n          inSingle = true\n          break // '\n        case 0x60:\n          inTemplateString = true\n          break // `\n        case 0x28:\n          paren++\n          break // (\n        case 0x29:\n          paren--\n          break // )\n        case 0x5b:\n          square++\n          break // [\n        case 0x5d:\n          square--\n          break // ]\n        case 0x7b:\n          curly++\n          break // {\n        case 0x7d:\n          curly--\n          break // }\n      }\n      if (c === 0x2f) {\n        // /\n        let j = i - 1\n        let p\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j)\n          if (p !== ' ') break\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim()\n  } else if (lastFilterIndex !== 0) {\n    pushFilter()\n  }\n\n  function pushFilter() {\n    filters.push(exp.slice(lastFilterIndex, i).trim())\n    lastFilterIndex = i + 1\n  }\n\n  if (filters.length) {\n    __DEV__ &&\n      warnDeprecation(\n        CompilerDeprecationTypes.COMPILER_FILTERS,\n        context,\n        node.loc\n      )\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i], context)\n    }\n    node.content = expression\n  }\n}\n\nfunction wrapFilter(\n  exp: string,\n  filter: string,\n  context: TransformContext\n): string {\n  context.helper(RESOLVE_FILTER)\n  const i = filter.indexOf('(')\n  if (i < 0) {\n    context.filters!.add(filter)\n    return `${toValidAssetId(filter, 'filter')}(${exp})`\n  } else {\n    const name = filter.slice(0, i)\n    const args = filter.slice(i + 1)\n    context.filters!.add(name)\n    return `${toValidAssetId(name, 'filter')}(${exp}${\n      args !== ')' ? ',' + args : args\n    }`\n  }\n}\n","import { NodeTransform } from '../transform'\nimport { findDir, makeBlock } from '../utils'\nimport {\n  createCallExpression,\n  createFunctionExpression,\n  ElementTypes,\n  MemoExpression,\n  NodeTypes,\n  PlainElementNode\n} from '../ast'\nimport { WITH_MEMO } from '../runtimeHelpers'\n\nconst seen = new WeakSet()\n\nexport const transformMemo: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ELEMENT) {\n    const dir = findDir(node, 'memo')\n    if (!dir || seen.has(node)) {\n      return\n    }\n    seen.add(node)\n    return () => {\n      const codegenNode =\n        node.codegenNode ||\n        (context.currentNode as PlainElementNode).codegenNode\n      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {\n        // non-component sub tree should be turned into a block\n        if (node.tagType !== ElementTypes.COMPONENT) {\n          makeBlock(codegenNode, context)\n        }\n        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\n          dir.exp!,\n          createFunctionExpression(undefined, codegenNode),\n          `_cache`,\n          String(context.cached++)\n        ]) as MemoExpression\n      }\n    }\n  }\n}\n","import { CompilerOptions } from './options'\nimport { baseParse } from './parse'\nimport { transform, NodeTransform, DirectiveTransform } from './transform'\nimport { generate, CodegenResult } from './codegen'\nimport { RootNode } from './ast'\nimport { isString, extend } from '@vue/shared'\nimport { transformIf } from './transforms/vIf'\nimport { transformFor } from './transforms/vFor'\nimport { transformExpression } from './transforms/transformExpression'\nimport { transformSlotOutlet } from './transforms/transformSlotOutlet'\nimport { transformElement } from './transforms/transformElement'\nimport { transformOn } from './transforms/vOn'\nimport { transformBind } from './transforms/vBind'\nimport { trackSlotScopes, trackVForSlotScopes } from './transforms/vSlot'\nimport { transformText } from './transforms/transformText'\nimport { transformOnce } from './transforms/vOnce'\nimport { transformModel } from './transforms/vModel'\nimport { transformFilter } from './compat/transformFilter'\nimport { defaultOnError, createCompilerError, ErrorCodes } from './errors'\nimport { transformMemo } from './transforms/vMemo'\n\nexport type TransformPreset = [\n  NodeTransform[],\n  Record<string, DirectiveTransform>\n]\n\nexport function getBaseTransformPreset(\n  prefixIdentifiers?: boolean\n): TransformPreset {\n  return [\n    [\n      transformOnce,\n      transformIf,\n      transformMemo,\n      transformFor,\n      ...(__COMPAT__ ? [transformFilter] : []),\n      ...(!__BROWSER__ && prefixIdentifiers\n        ? [\n            // order is important\n            trackVForSlotScopes,\n            transformExpression\n          ]\n        : __BROWSER__ && __DEV__\n        ? [transformExpression]\n        : []),\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText\n    ],\n    {\n      on: transformOn,\n      bind: transformBind,\n      model: transformModel\n    }\n  ]\n}\n\n// we name it `baseCompile` so that higher order compilers like\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\nexport function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  const onError = options.onError || defaultOnError\n  const isModuleMode = options.mode === 'module'\n  /* istanbul ignore if */\n  if (__BROWSER__) {\n    if (options.prefixIdentifiers === true) {\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\n    } else if (isModuleMode) {\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\n    }\n  }\n\n  const prefixIdentifiers =\n    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)\n  if (!prefixIdentifiers && options.cacheHandlers) {\n    onError(createCompilerError(ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED))\n  }\n  if (options.scopeId && !isModuleMode) {\n    onError(createCompilerError(ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED))\n  }\n\n  const ast = isString(template) ? baseParse(template, options) : template\n  const [nodeTransforms, directiveTransforms] =\n    getBaseTransformPreset(prefixIdentifiers)\n\n  if (!__BROWSER__ && options.isTS) {\n    const { expressionPlugins } = options\n    if (!expressionPlugins || !expressionPlugins.includes('typescript')) {\n      options.expressionPlugins = [...(expressionPlugins || []), 'typescript']\n    }\n  }\n\n  transform(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers,\n      nodeTransforms: [\n        ...nodeTransforms,\n        ...(options.nodeTransforms || []) // user transforms\n      ],\n      directiveTransforms: extend(\n        {},\n        directiveTransforms,\n        options.directiveTransforms || {} // user transforms\n      )\n    })\n  )\n\n  return generate(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers\n    })\n  )\n}\n","import { DirectiveTransform } from '../transform'\n\nexport const noopDirectiveTransform: DirectiveTransform = () => ({ props: [] })\n","import { registerRuntimeHelpers } from '@vue/compiler-core'\n\nexport const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)\nexport const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)\nexport const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)\nexport const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)\nexport const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)\n\nexport const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)\nexport const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)\n\nexport const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)\n\nexport const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)\nexport const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)\n\nregisterRuntimeHelpers({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`,\n  [V_SHOW]: `vShow`,\n  [TRANSITION]: `Transition`,\n  [TRANSITION_GROUP]: `TransitionGroup`\n})\n","/* eslint-disable no-restricted-globals */\n\nlet decoder: HTMLDivElement\n\nexport function decodeHtmlBrowser(raw: string, asAttr = false): string {\n  if (!decoder) {\n    decoder = document.createElement('div')\n  }\n  if (asAttr) {\n    decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`\n    return decoder.children[0].getAttribute('foo') as string\n  } else {\n    decoder.innerHTML = raw\n    return decoder.textContent as string\n  }\n}\n","import {\n  TextModes,\n  ParserOptions,\n  ElementNode,\n  Namespaces,\n  NodeTypes,\n  isBuiltInType\n} from '@vue/compiler-core'\nimport { makeMap, isVoidTag, isHTMLTag, isSVGTag } from '@vue/shared'\nimport { TRANSITION, TRANSITION_GROUP } from './runtimeHelpers'\nimport { decodeHtml } from './decodeHtml'\nimport { decodeHtmlBrowser } from './decodeHtmlBrowser'\n\nconst isRawTextContainer = /*#__PURE__*/ makeMap(\n  'style,iframe,script,noscript',\n  true\n)\n\nexport const enum DOMNamespaces {\n  HTML = Namespaces.HTML,\n  SVG,\n  MATH_ML\n}\n\nexport const parserOptions: ParserOptions = {\n  isVoidTag,\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\n  isPreTag: tag => tag === 'pre',\n  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,\n\n  isBuiltInComponent: (tag: string): symbol | undefined => {\n    if (isBuiltInType(tag, `Transition`)) {\n      return TRANSITION\n    } else if (isBuiltInType(tag, `TransitionGroup`)) {\n      return TRANSITION_GROUP\n    }\n  },\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag: string, parent: ElementNode | undefined): DOMNamespaces {\n    let ns = parent ? parent.ns : DOMNamespaces.HTML\n\n    if (parent && ns === DOMNamespaces.MATH_ML) {\n      if (parent.tag === 'annotation-xml') {\n        if (tag === 'svg') {\n          return DOMNamespaces.SVG\n        }\n        if (\n          parent.props.some(\n            a =>\n              a.type === NodeTypes.ATTRIBUTE &&\n              a.name === 'encoding' &&\n              a.value != null &&\n              (a.value.content === 'text/html' ||\n                a.value.content === 'application/xhtml+xml')\n          )\n        ) {\n          ns = DOMNamespaces.HTML\n        }\n      } else if (\n        /^m(?:[ions]|text)$/.test(parent.tag) &&\n        tag !== 'mglyph' &&\n        tag !== 'malignmark'\n      ) {\n        ns = DOMNamespaces.HTML\n      }\n    } else if (parent && ns === DOMNamespaces.SVG) {\n      if (\n        parent.tag === 'foreignObject' ||\n        parent.tag === 'desc' ||\n        parent.tag === 'title'\n      ) {\n        ns = DOMNamespaces.HTML\n      }\n    }\n\n    if (ns === DOMNamespaces.HTML) {\n      if (tag === 'svg') {\n        return DOMNamespaces.SVG\n      }\n      if (tag === 'math') {\n        return DOMNamespaces.MATH_ML\n      }\n    }\n    return ns\n  },\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode({ tag, ns }: ElementNode): TextModes {\n    if (ns === DOMNamespaces.HTML) {\n      if (tag === 'textarea' || tag === 'title') {\n        return TextModes.RCDATA\n      }\n      if (isRawTextContainer(tag)) {\n        return TextModes.RAWTEXT\n      }\n    }\n    return TextModes.DATA\n  }\n}\n","import {\n  NodeTransform,\n  NodeTypes,\n  createSimpleExpression,\n  SimpleExpressionNode,\n  SourceLocation,\n  ConstantTypes\n} from '@vue/compiler-core'\nimport { parseStringStyle } from '@vue/shared'\n\n// Parse inline CSS strings for static style attributes into an object.\n// This is a NodeTransform since it works on the static `style` attribute and\n// converts it into a dynamic equivalent:\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\n// It is then processed by `transformElement` and included in the generated\n// props.\nexport const transformStyle: NodeTransform = node => {\n  if (node.type === NodeTypes.ELEMENT) {\n    node.props.forEach((p, i) => {\n      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {\n        // replace p with an expression node\n        node.props[i] = {\n          type: NodeTypes.DIRECTIVE,\n          name: `bind`,\n          arg: createSimpleExpression(`style`, true, p.loc),\n          exp: parseInlineCSS(p.value.content, p.loc),\n          modifiers: [],\n          loc: p.loc\n        }\n      }\n    })\n  }\n}\n\nconst parseInlineCSS = (\n  cssText: string,\n  loc: SourceLocation\n): SimpleExpressionNode => {\n  const normalized = parseStringStyle(cssText)\n  return createSimpleExpression(\n    JSON.stringify(normalized),\n    false,\n    loc,\n    ConstantTypes.CAN_STRINGIFY\n  )\n}\n","import {\n  SourceLocation,\n  CompilerError,\n  createCompilerError,\n  ErrorCodes\n} from '@vue/compiler-core'\n\nexport interface DOMCompilerError extends CompilerError {\n  code: DOMErrorCodes\n}\n\nexport function createDOMCompilerError(\n  code: DOMErrorCodes,\n  loc?: SourceLocation\n) {\n  return createCompilerError(\n    code,\n    loc,\n    __DEV__ || !__BROWSER__ ? DOMErrorMessages : undefined\n  ) as DOMCompilerError\n}\n\nexport const enum DOMErrorCodes {\n  X_V_HTML_NO_EXPRESSION = ErrorCodes.__EXTEND_POINT__,\n  X_V_HTML_WITH_CHILDREN,\n  X_V_TEXT_NO_EXPRESSION,\n  X_V_TEXT_WITH_CHILDREN,\n  X_V_MODEL_ON_INVALID_ELEMENT,\n  X_V_MODEL_ARG_ON_ELEMENT,\n  X_V_MODEL_ON_FILE_INPUT_ELEMENT,\n  X_V_MODEL_UNNECESSARY_VALUE,\n  X_V_SHOW_NO_EXPRESSION,\n  X_TRANSITION_INVALID_CHILDREN,\n  X_IGNORED_SIDE_EFFECT_TAG,\n  __EXTEND_POINT__\n}\n\nexport const DOMErrorMessages: { [code: number]: string } = {\n  [DOMErrorCodes.X_V_HTML_NO_EXPRESSION]: `v-html is missing expression.`,\n  [DOMErrorCodes.X_V_HTML_WITH_CHILDREN]: `v-html will override element children.`,\n  [DOMErrorCodes.X_V_TEXT_NO_EXPRESSION]: `v-text is missing expression.`,\n  [DOMErrorCodes.X_V_TEXT_WITH_CHILDREN]: `v-text will override element children.`,\n  [DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT]: `v-model argument is not supported on plain elements.`,\n  [DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n  [DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\n  [DOMErrorCodes.X_V_SHOW_NO_EXPRESSION]: `v-show is missing expression.`,\n  [DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN]: `<Transition> expects exactly one child element or component.`,\n  [DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformVHtml: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_NO_EXPRESSION, loc)\n    )\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_WITH_CHILDREN, loc)\n    )\n    node.children.length = 0\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`innerHTML`, true, loc),\n        exp || createSimpleExpression('', true)\n      )\n    ]\n  }\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression,\n  TO_DISPLAY_STRING,\n  createCallExpression,\n  getConstantType\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformVText: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_NO_EXPRESSION, loc)\n    )\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_WITH_CHILDREN, loc)\n    )\n    node.children.length = 0\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`textContent`, true),\n        exp\n          ? getConstantType(exp, context) > 0\n            ? exp\n            : createCallExpression(\n                context.helperString(TO_DISPLAY_STRING),\n                [exp],\n                loc\n              )\n          : createSimpleExpression('', true)\n      )\n    ]\n  }\n}\n","import {\n  transformModel as baseTransform,\n  DirectiveTransform,\n  ElementTypes,\n  findProp,\n  NodeTypes,\n  hasDynamicKeyVBind\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\nimport {\n  V_MODEL_CHECKBOX,\n  V_MODEL_RADIO,\n  V_MODEL_SELECT,\n  V_MODEL_TEXT,\n  V_MODEL_DYNAMIC\n} from '../runtimeHelpers'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const baseResult = baseTransform(dir, node, context)\n  // base transform has errors OR component v-model (only need props)\n  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {\n    return baseResult\n  }\n\n  if (dir.arg) {\n    context.onError(\n      createDOMCompilerError(\n        DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT,\n        dir.arg.loc\n      )\n    )\n  }\n\n  function checkDuplicatedValue() {\n    const value = findProp(node, 'value')\n    if (value) {\n      context.onError(\n        createDOMCompilerError(\n          DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE,\n          value.loc\n        )\n      )\n    }\n  }\n\n  const { tag } = node\n  const isCustomElement = context.isCustomElement(tag)\n  if (\n    tag === 'input' ||\n    tag === 'textarea' ||\n    tag === 'select' ||\n    isCustomElement\n  ) {\n    let directiveToUse = V_MODEL_TEXT\n    let isInvalidType = false\n    if (tag === 'input' || isCustomElement) {\n      const type = findProp(node, `type`)\n      if (type) {\n        if (type.type === NodeTypes.DIRECTIVE) {\n          // :type=\"foo\"\n          directiveToUse = V_MODEL_DYNAMIC\n        } else if (type.value) {\n          switch (type.value.content) {\n            case 'radio':\n              directiveToUse = V_MODEL_RADIO\n              break\n            case 'checkbox':\n              directiveToUse = V_MODEL_CHECKBOX\n              break\n            case 'file':\n              isInvalidType = true\n              context.onError(\n                createDOMCompilerError(\n                  DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\n                  dir.loc\n                )\n              )\n              break\n            default:\n              // text type\n              __DEV__ && checkDuplicatedValue()\n              break\n          }\n        }\n      } else if (hasDynamicKeyVBind(node)) {\n        // element has bindings with dynamic keys, which can possibly contain\n        // \"type\".\n        directiveToUse = V_MODEL_DYNAMIC\n      } else {\n        // text type\n        __DEV__ && checkDuplicatedValue()\n      }\n    } else if (tag === 'select') {\n      directiveToUse = V_MODEL_SELECT\n    } else {\n      // textarea\n      __DEV__ && checkDuplicatedValue()\n    }\n    // inject runtime directive\n    // by returning the helper symbol via needRuntime\n    // the import will replaced a resolveDirective call.\n    if (!isInvalidType) {\n      baseResult.needRuntime = context.helper(directiveToUse)\n    }\n  } else {\n    context.onError(\n      createDOMCompilerError(\n        DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\n        dir.loc\n      )\n    )\n  }\n\n  // native vmodel doesn't need the `modelValue` props since they are also\n  // passed to the runtime as `binding.value`. removing it reduces code size.\n  baseResult.props = baseResult.props.filter(\n    p =>\n      !(\n        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\n        p.key.content === 'modelValue'\n      )\n  )\n\n  return baseResult\n}\n","import {\n  transformOn as baseTransform,\n  DirectiveTransform,\n  createObjectProperty,\n  createCallExpression,\n  createSimpleExpression,\n  NodeTypes,\n  createCompoundExpression,\n  ExpressionNode,\n  SimpleExpressionNode,\n  isStaticExp,\n  CompilerDeprecationTypes,\n  TransformContext,\n  SourceLocation,\n  checkCompatEnabled\n} from '@vue/compiler-core'\nimport { V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS } from '../runtimeHelpers'\nimport { makeMap, capitalize } from '@vue/shared'\n\nconst isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)\nconst isNonKeyModifier = /*#__PURE__*/ makeMap(\n  // event propagation management\n  `stop,prevent,self,` +\n    // system modifiers + exact\n    `ctrl,shift,alt,meta,exact,` +\n    // mouse\n    `middle`\n)\n// left & right could be mouse or key modifiers based on event type\nconst maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')\nconst isKeyboardEvent = /*#__PURE__*/ makeMap(\n  `onkeyup,onkeydown,onkeypress`,\n  true\n)\n\nconst resolveModifiers = (\n  key: ExpressionNode,\n  modifiers: string[],\n  context: TransformContext,\n  loc: SourceLocation\n) => {\n  const keyModifiers = []\n  const nonKeyModifiers = []\n  const eventOptionModifiers = []\n\n  for (let i = 0; i < modifiers.length; i++) {\n    const modifier = modifiers[i]\n\n    if (\n      __COMPAT__ &&\n      modifier === 'native' &&\n      checkCompatEnabled(\n        CompilerDeprecationTypes.COMPILER_V_ON_NATIVE,\n        context,\n        loc\n      )\n    ) {\n      eventOptionModifiers.push(modifier)\n    } else if (isEventOptionModifier(modifier)) {\n      // eventOptionModifiers: modifiers for addEventListener() options,\n      // e.g. .passive & .capture\n      eventOptionModifiers.push(modifier)\n    } else {\n      // runtimeModifiers: modifiers that needs runtime guards\n      if (maybeKeyModifier(modifier)) {\n        if (isStaticExp(key)) {\n          if (isKeyboardEvent((key as SimpleExpressionNode).content)) {\n            keyModifiers.push(modifier)\n          } else {\n            nonKeyModifiers.push(modifier)\n          }\n        } else {\n          keyModifiers.push(modifier)\n          nonKeyModifiers.push(modifier)\n        }\n      } else {\n        if (isNonKeyModifier(modifier)) {\n          nonKeyModifiers.push(modifier)\n        } else {\n          keyModifiers.push(modifier)\n        }\n      }\n    }\n  }\n\n  return {\n    keyModifiers,\n    nonKeyModifiers,\n    eventOptionModifiers\n  }\n}\n\nconst transformClick = (key: ExpressionNode, event: string) => {\n  const isStaticClick =\n    isStaticExp(key) && key.content.toLowerCase() === 'onclick'\n  return isStaticClick\n    ? createSimpleExpression(event, true)\n    : key.type !== NodeTypes.SIMPLE_EXPRESSION\n    ? createCompoundExpression([\n        `(`,\n        key,\n        `) === \"onClick\" ? \"${event}\" : (`,\n        key,\n        `)`\n      ])\n    : key\n}\n\nexport const transformOn: DirectiveTransform = (dir, node, context) => {\n  return baseTransform(dir, node, context, baseResult => {\n    const { modifiers } = dir\n    if (!modifiers.length) return baseResult\n\n    let { key, value: handlerExp } = baseResult.props[0]\n    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =\n      resolveModifiers(key, modifiers, context, dir.loc)\n\n    // normalize click.right and click.middle since they don't actually fire\n    if (nonKeyModifiers.includes('right')) {\n      key = transformClick(key, `onContextmenu`)\n    }\n    if (nonKeyModifiers.includes('middle')) {\n      key = transformClick(key, `onMouseup`)\n    }\n\n    if (nonKeyModifiers.length) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\n        handlerExp,\n        JSON.stringify(nonKeyModifiers)\n      ])\n    }\n\n    if (\n      keyModifiers.length &&\n      // if event name is dynamic, always wrap with keys guard\n      (!isStaticExp(key) || isKeyboardEvent(key.content))\n    ) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\n        handlerExp,\n        JSON.stringify(keyModifiers)\n      ])\n    }\n\n    if (eventOptionModifiers.length) {\n      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')\n      key = isStaticExp(key)\n        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\n        : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`])\n    }\n\n    return {\n      props: [createObjectProperty(key, handlerExp)]\n    }\n  })\n}\n","import { DirectiveTransform } from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\nimport { V_SHOW } from '../runtimeHelpers'\n\nexport const transformShow: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION, loc)\n    )\n  }\n\n  return {\n    props: [],\n    needRuntime: context.helper(V_SHOW)\n  }\n}\n","import {\n  NodeTransform,\n  NodeTypes,\n  ElementTypes,\n  ComponentNode,\n  IfBranchNode\n} from '@vue/compiler-core'\nimport { TRANSITION } from '../runtimeHelpers'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformTransition: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    node.tagType === ElementTypes.COMPONENT\n  ) {\n    const component = context.isBuiltInComponent(node.tag)\n    if (component === TRANSITION) {\n      return () => {\n        if (!node.children.length) {\n          return\n        }\n\n        // warn multiple transition children\n        if (hasMultipleChildren(node)) {\n          context.onError(\n            createDOMCompilerError(\n              DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN,\n              {\n                start: node.children[0].loc.start,\n                end: node.children[node.children.length - 1].loc.end,\n                source: ''\n              }\n            )\n          )\n        }\n\n        // check if it's s single child w/ v-show\n        // if yes, inject \"persisted: true\" to the transition props\n        const child = node.children[0]\n        if (child.type === NodeTypes.ELEMENT) {\n          for (const p of child.props) {\n            if (p.type === NodeTypes.DIRECTIVE && p.name === 'show') {\n              node.props.push({\n                type: NodeTypes.ATTRIBUTE,\n                name: 'persisted',\n                value: undefined,\n                loc: node.loc\n              })\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction hasMultipleChildren(node: ComponentNode | IfBranchNode): boolean {\n  // #1352 filter out potential comment nodes.\n  const children = (node.children = node.children.filter(\n    c =>\n      c.type !== NodeTypes.COMMENT &&\n      !(c.type === NodeTypes.TEXT && !c.content.trim())\n  ))\n  const child = children[0]\n  return (\n    children.length !== 1 ||\n    child.type === NodeTypes.FOR ||\n    (child.type === NodeTypes.IF && child.branches.some(hasMultipleChildren))\n  )\n}\n","import { NodeTransform, NodeTypes, ElementTypes } from '@vue/compiler-core'\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\n\nexport const ignoreSideEffectTags: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    node.tagType === ElementTypes.ELEMENT &&\n    (node.tag === 'script' || node.tag === 'style')\n  ) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG, node.loc)\n    )\n    context.removeNode()\n  }\n}\n","import {\n  baseCompile,\n  baseParse,\n  CompilerOptions,\n  CodegenResult,\n  ParserOptions,\n  RootNode,\n  noopDirectiveTransform,\n  NodeTransform,\n  DirectiveTransform\n} from '@vue/compiler-core'\nimport { parserOptions } from './parserOptions'\nimport { transformStyle } from './transforms/transformStyle'\nimport { transformVHtml } from './transforms/vHtml'\nimport { transformVText } from './transforms/vText'\nimport { transformModel } from './transforms/vModel'\nimport { transformOn } from './transforms/vOn'\nimport { transformShow } from './transforms/vShow'\nimport { transformTransition } from './transforms/Transition'\nimport { stringifyStatic } from './transforms/stringifyStatic'\nimport { ignoreSideEffectTags } from './transforms/ignoreSideEffectTags'\nimport { extend } from '@vue/shared'\n\nexport { parserOptions }\n\nexport const DOMNodeTransforms: NodeTransform[] = [\n  transformStyle,\n  ...(__DEV__ ? [transformTransition] : [])\n]\n\nexport const DOMDirectiveTransforms: Record<string, DirectiveTransform> = {\n  cloak: noopDirectiveTransform,\n  html: transformVHtml,\n  text: transformVText,\n  model: transformModel, // override compiler-core\n  on: transformOn, // override compiler-core\n  show: transformShow\n}\n\nexport function compile(\n  template: string,\n  options: CompilerOptions = {}\n): CodegenResult {\n  return baseCompile(\n    template,\n    extend({}, parserOptions, options, {\n      nodeTransforms: [\n        // ignore <script> and <tag>\n        // this is not put inside DOMNodeTransforms because that list is used\n        // by compiler-ssr to generate vnode fallback branches\n        ignoreSideEffectTags,\n        ...DOMNodeTransforms,\n        ...(options.nodeTransforms || [])\n      ],\n      directiveTransforms: extend(\n        {},\n        DOMDirectiveTransforms,\n        options.directiveTransforms || {}\n      ),\n      transformHoist: __BROWSER__ ? null : stringifyStatic\n    })\n  )\n}\n\nexport function parse(template: string, options: ParserOptions = {}): RootNode {\n  return baseParse(template, extend({}, parserOptions, options))\n}\n\nexport * from './runtimeHelpers'\nexport { transformStyle } from './transforms/transformStyle'\nexport { createDOMCompilerError, DOMErrorCodes } from './errors'\nexport * from '@vue/compiler-core'\n"],"names":["isText","seen","transformModel","baseTransform","transformOn"],"mappings":"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"}