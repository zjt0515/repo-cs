{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/warning.ts","../src/effectScope.ts","../src/dep.ts","../src/effect.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts","../src/deferredComputed.ts"],"sourcesContent":["/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","import { makeMap } from './makeMap'\n\nexport { makeMap }\nexport * from './patchFlags'\nexport * from './shapeFlags'\nexport * from './slotFlags'\nexport * from './globalsWhitelist'\nexport * from './codeframe'\nexport * from './normalizeProp'\nexport * from './domTagConfig'\nexport * from './domAttrConfig'\nexport * from './escapeHtml'\nexport * from './looseEqual'\nexport * from './toDisplayString'\nexport * from './typeUtils'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nconst onRE = /^on[^a-z]/\nexport const isOn = (key: string) => onRE.test(key)\n\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\n\nexport const extend = Object.assign\n\nexport const remove = <T>(arr: T[], el: T) => {\n  const i = arr.indexOf(el)\n  if (i > -1) {\n    arr.splice(i, 1)\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isMap = (val: unknown): val is Map<any, any> =>\n  toTypeString(val) === '[object Map]'\nexport const isSet = (val: unknown): val is Set<any> =>\n  toTypeString(val) === '[object Set]'\n\nexport const isDate = (val: unknown): val is Date => toTypeString(val) === '[object Date]'\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const toRawType = (value: unknown): string => {\n  // extract \"RawType\" from strings like \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isIntegerKey = (key: unknown) =>\n  isString(key) &&\n  key !== 'NaN' &&\n  key[0] !== '-' &&\n  '' + parseInt(key, 10) === key\n\nexport const isReservedProp = /*#__PURE__*/ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  ',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\n)\n\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'\n)\n\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\n  const cache: Record<string, string> = Object.create(null)\n  return ((str: string) => {\n    const hit = cache[str]\n    return hit || (cache[str] = fn(str))\n  }) as any\n}\n\nconst camelizeRE = /-(\\w)/g\n/**\n * @private\n */\nexport const camelize = cacheStringFunction((str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n})\n\nconst hyphenateRE = /\\B([A-Z])/g\n/**\n * @private\n */\nexport const hyphenate = cacheStringFunction((str: string) =>\n  str.replace(hyphenateRE, '-$1').toLowerCase()\n)\n\n/**\n * @private\n */\nexport const capitalize = cacheStringFunction(\n  (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\n)\n\n/**\n * @private\n */\nexport const toHandlerKey = cacheStringFunction((str: string) =>\n  str ? `on${capitalize(str)}` : ``\n)\n\n// compare whether a value has changed, accounting for NaN.\nexport const hasChanged = (value: any, oldValue: any): boolean =>\n  !Object.is(value, oldValue)\n\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg)\n  }\n}\n\nexport const def = (obj: object, key: string | symbol, value: any) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  })\n}\n\nexport const toNumber = (val: any): any => {\n  const n = parseFloat(val)\n  return isNaN(n) ? val : n\n}\n\nlet _globalThis: any\nexport const getGlobalThis = (): any => {\n  return (\n    _globalThis ||\n    (_globalThis =\n      typeof globalThis !== 'undefined'\n        ? globalThis\n        : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n        ? window\n        : typeof global !== 'undefined'\n        ? global\n        : {})\n  )\n}\n\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\n\nexport function genPropsAccessExp(name: string) {\n  return identRE.test(name)\n    ? `__props.${name}`\n    : `__props[${JSON.stringify(name)}]`\n}\n","export function warn(msg: string, ...args: any[]) {\n  console.warn(`[Vue warn] ${msg}`, ...args)\n}\n","import { ReactiveEffect } from './effect'\nimport { warn } from './warning'\n\nlet activeEffectScope: EffectScope | undefined\n\nexport class EffectScope {\n  /**\n   * @internal\n   */\n  active = true\n  /**\n   * @internal\n   */\n  effects: ReactiveEffect[] = []\n  /**\n   * @internal\n   */\n  cleanups: (() => void)[] = []\n\n  /**\n   * only assigned by undetached scope\n   * @internal\n   */\n  parent: EffectScope | undefined\n  /**\n   * record undetached scopes\n   * @internal\n   */\n  scopes: EffectScope[] | undefined\n  /**\n   * track a child scope's index in its parent's scopes array for optimized\n   * removal\n   * @internal\n   */\n  private index: number | undefined\n\n  constructor(detached = false) {\n    if (!detached && activeEffectScope) {\n      this.parent = activeEffectScope\n      this.index =\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n          this\n        ) - 1\n    }\n  }\n\n  run<T>(fn: () => T): T | undefined {\n    if (this.active) {\n      const currentEffectScope = activeEffectScope\n      try {\n        activeEffectScope = this\n        return fn()\n      } finally {\n        activeEffectScope = currentEffectScope\n      }\n    } else if (__DEV__) {\n      warn(`cannot run an inactive effect scope.`)\n    }\n  }\n\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this\n  }\n\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent\n  }\n\n  stop(fromParent?: boolean) {\n    if (this.active) {\n      let i, l\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop()\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]()\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true)\n        }\n      }\n      // nested scope, dereference from parent to avoid memory leaks\n      if (this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes!.pop()\n        if (last && last !== this) {\n          this.parent.scopes![this.index!] = last\n          last.index = this.index!\n        }\n      }\n      this.active = false\n    }\n  }\n}\n\nexport function effectScope(detached?: boolean) {\n  return new EffectScope(detached)\n}\n\nexport function recordEffectScope(\n  effect: ReactiveEffect,\n  scope: EffectScope | undefined = activeEffectScope\n) {\n  if (scope && scope.active) {\n    scope.effects.push(effect)\n  }\n}\n\nexport function getCurrentScope() {\n  return activeEffectScope\n}\n\nexport function onScopeDispose(fn: () => void) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn)\n  } else if (__DEV__) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope` +\n        ` to be associated with.`\n    )\n  }\n}\n","import { ReactiveEffect, trackOpBit } from './effect'\n\nexport type Dep = Set<ReactiveEffect> & TrackedMarkers\n\n/**\n * wasTracked and newTracked maintain the status for several levels of effect\n * tracking recursion. One bit per level is used to define whether the dependency\n * was/is tracked.\n */\ntype TrackedMarkers = {\n  /**\n   * wasTracked\n   */\n  w: number\n  /**\n   * newTracked\n   */\n  n: number\n}\n\nexport const createDep = (effects?: ReactiveEffect[]): Dep => {\n  const dep = new Set<ReactiveEffect>(effects) as Dep\n  dep.w = 0\n  dep.n = 0\n  return dep\n}\n\nexport const wasTracked = (dep: Dep): boolean => (dep.w & trackOpBit) > 0\n\nexport const newTracked = (dep: Dep): boolean => (dep.n & trackOpBit) > 0\n\nexport const initDepMarkers = ({ deps }: ReactiveEffect) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit // set was tracked\n    }\n  }\n}\n\nexport const finalizeDepMarkers = (effect: ReactiveEffect) => {\n  const { deps } = effect\n  if (deps.length) {\n    let ptr = 0\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i]\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect)\n      } else {\n        deps[ptr++] = dep\n      }\n      // clear bits\n      dep.w &= ~trackOpBit\n      dep.n &= ~trackOpBit\n    }\n    deps.length = ptr\n  }\n}\n","import { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { extend, isArray, isIntegerKey, isMap } from '@vue/shared'\nimport { EffectScope, recordEffectScope } from './effectScope'\nimport {\n  createDep,\n  Dep,\n  finalizeDepMarkers,\n  initDepMarkers,\n  newTracked,\n  wasTracked\n} from './dep'\nimport { ComputedRefImpl } from './computed'\n\n// The main WeakMap that stores {target -> key -> dep} connections.\n// Conceptually, it's easier to think of a dependency as a Dep class\n// which maintains a Set of subscribers, but we simply store them as\n// raw Sets to reduce memory overhead.\ntype KeyToDepMap = Map<any, Dep>\nconst targetMap = new WeakMap<any, KeyToDepMap>()\n\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0\n\nexport let trackOpBit = 1\n\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30\n\nexport type EffectScheduler = (...args: any[]) => any\n\nexport type DebuggerEvent = {\n  effect: ReactiveEffect\n} & DebuggerEventExtraInfo\n\nexport type DebuggerEventExtraInfo = {\n  target: object\n  type: TrackOpTypes | TriggerOpTypes\n  key: any\n  newValue?: any\n  oldValue?: any\n  oldTarget?: Map<any, any> | Set<any>\n}\n\nexport let activeEffect: ReactiveEffect | undefined\n\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\n\nexport class ReactiveEffect<T = any> {\n  active = true\n  deps: Dep[] = []\n  parent: ReactiveEffect | undefined = undefined\n\n  /**\n   * Can be attached after creation\n   * @internal\n   */\n  computed?: ComputedRefImpl<T>\n  /**\n   * @internal\n   */\n  allowRecurse?: boolean\n  /**\n   * @internal\n   */\n  private deferStop?: boolean\n\n  onStop?: () => void\n  // dev only\n  onTrack?: (event: DebuggerEvent) => void\n  // dev only\n  onTrigger?: (event: DebuggerEvent) => void\n\n  constructor(\n    public fn: () => T,\n    public scheduler: EffectScheduler | null = null,\n    scope?: EffectScope\n  ) {\n    recordEffectScope(this, scope)\n  }\n\n  run() {\n    if (!this.active) {\n      return this.fn()\n    }\n    let parent: ReactiveEffect | undefined = activeEffect\n    let lastShouldTrack = shouldTrack\n    while (parent) {\n      if (parent === this) {\n        return\n      }\n      parent = parent.parent\n    }\n    try {\n      this.parent = activeEffect\n      activeEffect = this\n      shouldTrack = true\n\n      trackOpBit = 1 << ++effectTrackDepth\n\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this)\n      } else {\n        cleanupEffect(this)\n      }\n      return this.fn()\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this)\n      }\n\n      trackOpBit = 1 << --effectTrackDepth\n\n      activeEffect = this.parent\n      shouldTrack = lastShouldTrack\n      this.parent = undefined\n\n      if (this.deferStop) {\n        this.stop()\n      }\n    }\n  }\n\n  stop() {\n    // stopped while running itself - defer the cleanup\n    if (activeEffect === this) {\n      this.deferStop = true\n    } else if (this.active) {\n      cleanupEffect(this)\n      if (this.onStop) {\n        this.onStop()\n      }\n      this.active = false\n    }\n  }\n}\n\nfunction cleanupEffect(effect: ReactiveEffect) {\n  const { deps } = effect\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect)\n    }\n    deps.length = 0\n  }\n}\n\nexport interface DebuggerOptions {\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\nexport interface ReactiveEffectOptions extends DebuggerOptions {\n  lazy?: boolean\n  scheduler?: EffectScheduler\n  scope?: EffectScope\n  allowRecurse?: boolean\n  onStop?: () => void\n}\n\nexport interface ReactiveEffectRunner<T = any> {\n  (): T\n  effect: ReactiveEffect\n}\n\nexport function effect<T = any>(\n  fn: () => T,\n  options?: ReactiveEffectOptions\n): ReactiveEffectRunner {\n  if ((fn as ReactiveEffectRunner).effect) {\n    fn = (fn as ReactiveEffectRunner).effect.fn\n  }\n\n  const _effect = new ReactiveEffect(fn)\n  if (options) {\n    extend(_effect, options)\n    if (options.scope) recordEffectScope(_effect, options.scope)\n  }\n  if (!options || !options.lazy) {\n    _effect.run()\n  }\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\n  runner.effect = _effect\n  return runner\n}\n\nexport function stop(runner: ReactiveEffectRunner) {\n  runner.effect.stop()\n}\n\nexport let shouldTrack = true\nconst trackStack: boolean[] = []\n\nexport function pauseTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = false\n}\n\nexport function enableTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = true\n}\n\nexport function resetTracking() {\n  const last = trackStack.pop()\n  shouldTrack = last === undefined ? true : last\n}\n\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n      depsMap.set(key, (dep = createDep()))\n    }\n\n    const eventInfo = __DEV__\n      ? { effect: activeEffect, target, type, key }\n      : undefined\n\n    trackEffects(dep, eventInfo)\n  }\n}\n\nexport function trackEffects(\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\n) {\n  let shouldTrack = false\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit // set newly tracked\n      shouldTrack = !wasTracked(dep)\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect!)\n  }\n\n  if (shouldTrack) {\n    dep.add(activeEffect!)\n    activeEffect!.deps.push(dep)\n    if (__DEV__ && activeEffect!.onTrack) {\n      activeEffect!.onTrack({\n        effect: activeEffect!,\n        ...debuggerEventExtraInfo!\n      })\n    }\n  }\n}\n\nexport function trigger(\n  target: object,\n  type: TriggerOpTypes,\n  key?: unknown,\n  newValue?: unknown,\n  oldValue?: unknown,\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\n) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // never been tracked\n    return\n  }\n\n  let deps: (Dep | undefined)[] = []\n  if (type === TriggerOpTypes.CLEAR) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()]\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= (newValue as number)) {\n        deps.push(dep)\n      }\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key))\n    }\n\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'))\n        }\n        break\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        break\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  const eventInfo = __DEV__\n    ? { target, type, key, newValue, oldValue, oldTarget }\n    : undefined\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (__DEV__) {\n        triggerEffects(deps[0], eventInfo)\n      } else {\n        triggerEffects(deps[0])\n      }\n    }\n  } else {\n    const effects: ReactiveEffect[] = []\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep)\n      }\n    }\n    if (__DEV__) {\n      triggerEffects(createDep(effects), eventInfo)\n    } else {\n      triggerEffects(createDep(effects))\n    }\n  }\n}\n\nexport function triggerEffects(\n  dep: Dep | ReactiveEffect[],\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\n) {\n  // spread into array for stabilization\n  const effects = isArray(dep) ? dep : [...dep]\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n}\n\nfunction triggerEffect(\n  effect: ReactiveEffect,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\n) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    if (__DEV__ && effect.onTrigger) {\n      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo))\n    }\n    if (effect.scheduler) {\n      effect.scheduler()\n    } else {\n      effect.run()\n    }\n  }\n}\n","import {\n  reactive,\n  readonly,\n  toRaw,\n  ReactiveFlags,\n  Target,\n  readonlyMap,\n  reactiveMap,\n  shallowReactiveMap,\n  shallowReadonlyMap,\n  isReadonly,\n  isShallow\n} from './reactive'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport {\n  track,\n  trigger,\n  ITERATE_KEY,\n  pauseTracking,\n  resetTracking\n} from './effect'\nimport {\n  isObject,\n  hasOwn,\n  isSymbol,\n  hasChanged,\n  isArray,\n  isIntegerKey,\n  extend,\n  makeMap\n} from '@vue/shared'\nimport { isRef } from './ref'\nimport { warn } from './warning'\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\n\nconst builtInSymbols = new Set(\n  /*#__PURE__*/\n  Object.getOwnPropertyNames(Symbol)\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n    // function\n    .filter(key => key !== 'arguments' && key !== 'caller')\n    .map(key => (Symbol as any)[key])\n    .filter(isSymbol)\n)\n\nconst get = /*#__PURE__*/ createGetter()\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\n\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n  const instrumentations: Record<string, Function> = {}\n  // instrument identity-sensitive Array methods to account for possible reactive\n  // values\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      const arr = toRaw(this) as any\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, TrackOpTypes.GET, i + '')\n      }\n      // we run the method using the original args first (which may be reactive)\n      const res = arr[key](...args)\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key](...args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      pauseTracking()\n      const res = (toRaw(this) as any)[key].apply(this, args)\n      resetTracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\n      return shallow\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n          ? shallowReactiveMap\n          : reactiveMap\n        ).get(target)\n    ) {\n      return target\n    }\n\n    const targetIsArray = isArray(target)\n\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n\n    const res = Reflect.get(target, key, receiver)\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n\n    if (shallow) {\n      return res\n    }\n\n    if (isRef(res)) {\n      // ref unwrapping - skip unwrap for Array + integer key.\n      return targetIsArray && isIntegerKey(key) ? res : res.value\n    }\n\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n\n    return res\n  }\n}\n\nconst set = /*#__PURE__*/ createSetter()\nconst shallowSet = /*#__PURE__*/ createSetter(true)\n\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object,\n    key: string | symbol,\n    value: unknown,\n    receiver: object\n  ): boolean {\n    let oldValue = (target as any)[key]\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue)\n        value = toRaw(value)\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n\nfunction deleteProperty(target: object, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = (target as any)[key]\n  const result = Reflect.deleteProperty(target, key)\n  if (result && hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\nfunction has(target: object, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, TrackOpTypes.HAS, key)\n  }\n  return result\n}\n\nfunction ownKeys(target: object): (string | symbol)[] {\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n\nexport const readonlyHandlers: ProxyHandler<object> = {\n  get: readonlyGet,\n  set(target, key) {\n    if (__DEV__) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      )\n    }\n    return true\n  },\n  deleteProperty(target, key) {\n    if (__DEV__) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      )\n    }\n    return true\n  }\n}\n\nexport const shallowReactiveHandlers = /*#__PURE__*/ extend(\n  {},\n  mutableHandlers,\n  {\n    get: shallowGet,\n    set: shallowSet\n  }\n)\n\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nexport const shallowReadonlyHandlers = /*#__PURE__*/ extend(\n  {},\n  readonlyHandlers,\n  {\n    get: shallowReadonlyGet\n  }\n)\n","import { toRaw, ReactiveFlags, toReactive, toReadonly } from './reactive'\nimport { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './effect'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { capitalize, hasOwn, hasChanged, toRawType, isMap } from '@vue/shared'\n\nexport type CollectionTypes = IterableCollections | WeakCollections\n\ntype IterableCollections = Map<any, any> | Set<any>\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\ntype MapTypes = Map<any, any> | WeakMap<any, any>\ntype SetTypes = Set<any> | WeakSet<any>\n\nconst toShallow = <T extends unknown>(value: T): T => value\n\nconst getProto = <T extends CollectionTypes>(v: T): any =>\n  Reflect.getPrototypeOf(v)\n\nfunction get(\n  target: MapTypes,\n  key: unknown,\n  isReadonly = false,\n  isShallow = false\n) {\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = (target as any)[ReactiveFlags.RAW]\n  const rawTarget = toRaw(target)\n  const rawKey = toRaw(key)\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, TrackOpTypes.GET, key)\n    }\n    track(rawTarget, TrackOpTypes.GET, rawKey)\n  }\n  const { has } = getProto(rawTarget)\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key))\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey))\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key)\n  }\n}\n\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\n  const target = (this as any)[ReactiveFlags.RAW]\n  const rawTarget = toRaw(target)\n  const rawKey = toRaw(key)\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, TrackOpTypes.HAS, key)\n    }\n    track(rawTarget, TrackOpTypes.HAS, rawKey)\n  }\n  return key === rawKey\n    ? target.has(key)\n    : target.has(key) || target.has(rawKey)\n}\n\nfunction size(target: IterableCollections, isReadonly = false) {\n  target = (target as any)[ReactiveFlags.RAW]\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\n  return Reflect.get(target, 'size', target)\n}\n\nfunction add(this: SetTypes, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto = getProto(target)\n  const hadKey = proto.has.call(target, value)\n  if (!hadKey) {\n    target.add(value)\n    trigger(target, TriggerOpTypes.ADD, value, value)\n  }\n  return this\n}\n\nfunction set(this: MapTypes, key: unknown, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const { has, get } = getProto(target)\n\n  let hadKey = has.call(target, key)\n  if (!hadKey) {\n    key = toRaw(key)\n    hadKey = has.call(target, key)\n  } else if (__DEV__) {\n    checkIdentityKeys(target, has, key)\n  }\n\n  const oldValue = get.call(target, key)\n  target.set(key, value)\n  if (!hadKey) {\n    trigger(target, TriggerOpTypes.ADD, key, value)\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n  }\n  return this\n}\n\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\n  const target = toRaw(this)\n  const { has, get } = getProto(target)\n  let hadKey = has.call(target, key)\n  if (!hadKey) {\n    key = toRaw(key)\n    hadKey = has.call(target, key)\n  } else if (__DEV__) {\n    checkIdentityKeys(target, has, key)\n  }\n\n  const oldValue = get ? get.call(target, key) : undefined\n  // forward the operation before queueing reactions\n  const result = target.delete(key)\n  if (hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\nfunction clear(this: IterableCollections) {\n  const target = toRaw(this)\n  const hadItems = target.size !== 0\n  const oldTarget = __DEV__\n    ? isMap(target)\n      ? new Map(target)\n      : new Set(target)\n    : undefined\n  // forward the operation before queueing reactions\n  const result = target.clear()\n  if (hadItems) {\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\n  }\n  return result\n}\n\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\n  return function forEach(\n    this: IterableCollections,\n    callback: Function,\n    thisArg?: unknown\n  ) {\n    const observed = this as any\n    const target = observed[ReactiveFlags.RAW]\n    const rawTarget = toRaw(target)\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\n    return target.forEach((value: unknown, key: unknown) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\n    })\n  }\n}\n\ninterface Iterable {\n  [Symbol.iterator](): Iterator\n}\n\ninterface Iterator {\n  next(value?: any): IterationResult\n}\n\ninterface IterationResult {\n  value: any\n  done: boolean\n}\n\nfunction createIterableMethod(\n  method: string | symbol,\n  isReadonly: boolean,\n  isShallow: boolean\n) {\n  return function (\n    this: IterableCollections,\n    ...args: unknown[]\n  ): Iterable & Iterator {\n    const target = (this as any)[ReactiveFlags.RAW]\n    const rawTarget = toRaw(target)\n    const targetIsMap = isMap(rawTarget)\n    const isPair =\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\n    const isKeyOnly = method === 'keys' && targetIsMap\n    const innerIterator = target[method](...args)\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n    !isReadonly &&\n      track(\n        rawTarget,\n        TrackOpTypes.ITERATE,\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n      )\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next()\n        return done\n          ? { value, done }\n          : {\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n              done\n            }\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this\n      }\n    }\n  }\n}\n\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\n  return function (this: CollectionTypes, ...args: unknown[]) {\n    if (__DEV__) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\n      console.warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      )\n    }\n    return type === TriggerOpTypes.DELETE ? false : this\n  }\n}\n\nfunction createInstrumentations() {\n  const mutableInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  }\n\n  const shallowInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, false, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  }\n\n  const readonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, false)\n  }\n\n  const shallowReadonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, true)\n  }\n\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations[method as string] = createIterableMethod(\n      method,\n      false,\n      false\n    )\n    readonlyInstrumentations[method as string] = createIterableMethod(\n      method,\n      true,\n      false\n    )\n    shallowInstrumentations[method as string] = createIterableMethod(\n      method,\n      false,\n      true\n    )\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\n      method,\n      true,\n      true\n    )\n  })\n\n  return [\n    mutableInstrumentations,\n    readonlyInstrumentations,\n    shallowInstrumentations,\n    shallowReadonlyInstrumentations\n  ]\n}\n\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* #__PURE__*/ createInstrumentations()\n\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\n  const instrumentations = shallow\n    ? isReadonly\n      ? shallowReadonlyInstrumentations\n      : shallowInstrumentations\n    : isReadonly\n    ? readonlyInstrumentations\n    : mutableInstrumentations\n\n  return (\n    target: CollectionTypes,\n    key: string | symbol,\n    receiver: CollectionTypes\n  ) => {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.RAW) {\n      return target\n    }\n\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target\n        ? instrumentations\n        : target,\n      key,\n      receiver\n    )\n  }\n}\n\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n}\n\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n}\n\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n}\n\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\n  {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n  }\n\nfunction checkIdentityKeys(\n  target: CollectionTypes,\n  has: (key: unknown) => boolean,\n  key: unknown\n) {\n  const rawKey = toRaw(key)\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target)\n    console.warn(\n      `Reactive ${type} contains both the raw and reactive ` +\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n        `which can lead to inconsistencies. ` +\n        `Avoid differentiating between the raw and reactive versions ` +\n        `of an object and only use the reactive version if possible.`\n    )\n  }\n}\n","import { isObject, toRawType, def } from '@vue/shared'\nimport {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReactiveHandlers,\n  shallowReadonlyHandlers\n} from './baseHandlers'\nimport {\n  mutableCollectionHandlers,\n  readonlyCollectionHandlers,\n  shallowCollectionHandlers,\n  shallowReadonlyCollectionHandlers\n} from './collectionHandlers'\nimport type { UnwrapRefSimple, Ref, RawSymbol } from './ref'\n\nexport const enum ReactiveFlags {\n  SKIP = '__v_skip',\n  IS_REACTIVE = '__v_isReactive',\n  IS_READONLY = '__v_isReadonly',\n  IS_SHALLOW = '__v_isShallow',\n  RAW = '__v_raw'\n}\n\nexport interface Target {\n  [ReactiveFlags.SKIP]?: boolean\n  [ReactiveFlags.IS_REACTIVE]?: boolean\n  [ReactiveFlags.IS_READONLY]?: boolean\n  [ReactiveFlags.IS_SHALLOW]?: boolean\n  [ReactiveFlags.RAW]?: any\n}\n\nexport const reactiveMap = new WeakMap<Target, any>()\nexport const shallowReactiveMap = new WeakMap<Target, any>()\nexport const readonlyMap = new WeakMap<Target, any>()\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\n\nconst enum TargetType {\n  INVALID = 0,\n  COMMON = 1,\n  COLLECTION = 2\n}\n\nfunction targetTypeMap(rawType: string) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n\nfunction getTargetType(value: Target) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\n// only unwrap nested ref\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\n\n/**\n * Creates a reactive copy of the original object.\n *\n * The reactive conversion is \"deep\"â€”it affects all nested properties. In the\n * ES2015 Proxy based implementation, the returned proxy is **not** equal to the\n * original object. It is recommended to work exclusively with the reactive\n * proxy and avoid relying on the original object.\n *\n * A reactive object also automatically unwraps refs contained in it, so you\n * don't need to use `.value` when accessing and mutating their value:\n *\n * ```js\n * const count = ref(0)\n * const obj = reactive({\n *   count\n * })\n *\n * obj.count++\n * obj.count // -> 1\n * count.value // -> 1\n * ```\n */\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n\nexport declare const ShallowReactiveMarker: unique symbol\n\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\n\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nexport function shallowReactive<T extends object>(\n  target: T\n): ShallowReactive<T> {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  )\n}\n\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\ntype Builtin = Primitive | Function | Date | Error | RegExp\nexport type DeepReadonly<T> = T extends Builtin\n  ? T\n  : T extends Map<infer K, infer V>\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends ReadonlyMap<infer K, infer V>\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends WeakMap<infer K, infer V>\n  ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends Set<infer U>\n  ? ReadonlySet<DeepReadonly<U>>\n  : T extends ReadonlySet<infer U>\n  ? ReadonlySet<DeepReadonly<U>>\n  : T extends WeakSet<infer U>\n  ? WeakSet<DeepReadonly<U>>\n  : T extends Promise<infer U>\n  ? Promise<DeepReadonly<U>>\n  : T extends Ref<infer U>\n  ? Readonly<Ref<DeepReadonly<U>>>\n  : T extends {}\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : Readonly<T>\n\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nexport function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>> {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  )\n}\n\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  )\n}\n\nfunction createReactiveObject(\n  target: Target,\n  isReadonly: boolean,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>,\n  proxyMap: WeakMap<Target, any>\n) {\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // target already has corresponding Proxy\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // only specific value types can be observed.\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  proxyMap.set(target, proxy)\n  return proxy\n}\n\nexport function isReactive(value: unknown): boolean {\n  if (isReadonly(value)) {\n    return isReactive((value as Target)[ReactiveFlags.RAW])\n  }\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\n}\n\nexport function isReadonly(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\n}\n\nexport function isShallow(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\n}\n\nexport function isProxy(value: unknown): boolean {\n  return isReactive(value) || isReadonly(value)\n}\n\nexport function toRaw<T>(observed: T): T {\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\n  return raw ? toRaw(raw) : observed\n}\n\nexport function markRaw<T extends object>(\n  value: T\n): T & { [RawSymbol]?: true } {\n  def(value, ReactiveFlags.SKIP, true)\n  return value\n}\n\nexport const toReactive = <T extends unknown>(value: T): T =>\n  isObject(value) ? reactive(value) : value\n\nexport const toReadonly = <T extends unknown>(value: T): T =>\n  isObject(value) ? readonly(value as Record<any, any>) : value\n","import {\n  activeEffect,\n  shouldTrack,\n  trackEffects,\n  triggerEffects\n} from './effect'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { isArray, hasChanged, IfAny } from '@vue/shared'\nimport {\n  isProxy,\n  toRaw,\n  isReactive,\n  toReactive,\n  isReadonly,\n  isShallow\n} from './reactive'\nimport type { ShallowReactiveMarker } from './reactive'\nimport { CollectionTypes } from './collectionHandlers'\nimport { createDep, Dep } from './dep'\n\ndeclare const RefSymbol: unique symbol\nexport declare const RawSymbol: unique symbol\n\nexport interface Ref<T = any> {\n  value: T\n  /**\n   * Type differentiator only.\n   * We need this to be in public d.ts but don't want it to show up in IDE\n   * autocomplete, so we use a private Symbol instead.\n   */\n  [RefSymbol]: true\n}\n\ntype RefBase<T> = {\n  dep?: Dep\n  value: T\n}\n\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    if (__DEV__) {\n      trackEffects(ref.dep || (ref.dep = createDep()), {\n        target: ref,\n        type: TrackOpTypes.GET,\n        key: 'value'\n      })\n    } else {\n      trackEffects(ref.dep || (ref.dep = createDep()))\n    }\n  }\n}\n\nexport function triggerRefValue(ref: RefBase<any>, newVal?: any) {\n  ref = toRaw(ref)\n  if (ref.dep) {\n    if (__DEV__) {\n      triggerEffects(ref.dep, {\n        target: ref,\n        type: TriggerOpTypes.SET,\n        key: 'value',\n        newValue: newVal\n      })\n    } else {\n      triggerEffects(ref.dep)\n    }\n  }\n}\n\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\nexport function isRef(r: any): r is Ref {\n  return !!(r && r.__v_isRef === true)\n}\n\nexport function ref<T extends object>(\n  value: T\n): [T] extends [Ref] ? T : Ref<UnwrapRef<T>>\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n\ndeclare const ShallowRefMarker: unique symbol\n\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\n\nexport function shallowRef<T extends object>(\n  value: T\n): T extends Ref ? T : ShallowRef<T>\nexport function shallowRef<T>(value: T): ShallowRef<T>\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\nexport function shallowRef(value?: unknown) {\n  return createRef(value, true)\n}\n\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(value: T, public readonly __v_isShallow: boolean) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, newVal)\n    }\n  }\n}\n\nexport function triggerRef(ref: Ref) {\n  triggerRefValue(ref, __DEV__ ? ref.value : void 0)\n}\n\nexport function unref<T>(ref: T | Ref<T>): T {\n  return isRef(ref) ? (ref.value as any) : ref\n}\n\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key]\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value\n      return true\n    } else {\n      return Reflect.set(target, key, value, receiver)\n    }\n  }\n}\n\nexport function proxyRefs<T extends object>(\n  objectWithRefs: T\n): ShallowUnwrapRef<T> {\n  return isReactive(objectWithRefs)\n    ? objectWithRefs\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\n}\n\nexport type CustomRefFactory<T> = (\n  track: () => void,\n  trigger: () => void\n) => {\n  get: () => T\n  set: (value: T) => void\n}\n\nclass CustomRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\n\n  public readonly __v_isRef = true\n\n  constructor(factory: CustomRefFactory<T>) {\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newVal) {\n    this._set(newVal)\n  }\n}\n\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\n  return new CustomRefImpl(factory) as any\n}\n\nexport type ToRefs<T = any> = {\n  [K in keyof T]: ToRef<T[K]>\n}\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\n  if (__DEV__ && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\n  }\n  const ret: any = isArray(object) ? new Array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toRef(object, key)\n  }\n  return ret\n}\n\nclass ObjectRefImpl<T extends object, K extends keyof T> {\n  public readonly __v_isRef = true\n\n  constructor(\n    private readonly _object: T,\n    private readonly _key: K,\n    private readonly _defaultValue?: T[K]\n  ) {}\n\n  get value() {\n    const val = this._object[this._key]\n    return val === undefined ? (this._defaultValue as T[K]) : val\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal\n  }\n}\n\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): ToRef<T[K]>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  defaultValue: T[K]\n): ToRef<Exclude<T[K], undefined>>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  defaultValue?: T[K]\n): ToRef<T[K]> {\n  const val = object[key]\n  return isRef(val)\n    ? val\n    : (new ObjectRefImpl(object, key, defaultValue) as any)\n}\n\n// corner case when use narrows type\n// Ex. type RelativePath = string & { __brand: unknown }\n// RelativePath extends object -> true\ntype BaseTypes = string | number | boolean\n\n/**\n * This is a special exported interface for other packages to declare\n * additional types that should bail out for ref unwrapping. For example\n * \\@vue/runtime-dom can declare it like so in its d.ts:\n *\n * ``` ts\n * declare module '@vue/reactivity' {\n *   export interface RefUnwrapBailTypes {\n *     runtimeDOMBailTypes: Node | Window\n *   }\n * }\n * ```\n *\n * Note that api-extractor somehow refuses to include `declare module`\n * augmentations in its generated d.ts, so we have to manually append them\n * to the final generated d.ts in our build process.\n */\nexport interface RefUnwrapBailTypes {}\n\nexport type ShallowUnwrapRef<T> = {\n  [K in keyof T]: T[K] extends Ref<infer V>\n    ? V\n    : // if `V` is `unknown` that means it does not extend `Ref` and is undefined\n    T[K] extends Ref<infer V> | undefined\n    ? unknown extends V\n      ? undefined\n      : V | undefined\n    : T[K]\n}\n\nexport type UnwrapRef<T> = T extends ShallowRef<infer V>\n  ? V\n  : T extends Ref<infer V>\n  ? UnwrapRefSimple<V>\n  : UnwrapRefSimple<T>\n\nexport type UnwrapRefSimple<T> = T extends\n  | Function\n  | CollectionTypes\n  | BaseTypes\n  | Ref\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\n  | { [RawSymbol]?: true }\n  ? T\n  : T extends Array<any>\n  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\n  : T extends object & { [ShallowReactiveMarker]?: never }\n  ? {\n      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\n    }\n  : T\n","import { DebuggerOptions, ReactiveEffect } from './effect'\nimport { Ref, trackRefValue, triggerRefValue } from './ref'\nimport { isFunction, NOOP } from '@vue/shared'\nimport { ReactiveFlags, toRaw } from './reactive'\nimport { Dep } from './dep'\n\ndeclare const ComputedRefSymbol: unique symbol\n\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\n  readonly value: T\n  [ComputedRefSymbol]: true\n}\n\nexport interface WritableComputedRef<T> extends Ref<T> {\n  readonly effect: ReactiveEffect<T>\n}\n\nexport type ComputedGetter<T> = (...args: any[]) => T\nexport type ComputedSetter<T> = (v: T) => void\n\nexport interface WritableComputedOptions<T> {\n  get: ComputedGetter<T>\n  set: ComputedSetter<T>\n}\n\nexport class ComputedRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private _value!: T\n  public readonly effect: ReactiveEffect<T>\n\n  public readonly __v_isRef = true\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\n\n  public _dirty = true\n  public _cacheable: boolean\n\n  constructor(\n    getter: ComputedGetter<T>,\n    private readonly _setter: ComputedSetter<T>,\n    isReadonly: boolean,\n    isSSR: boolean\n  ) {\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true\n        triggerRefValue(this)\n      }\n    })\n    this.effect.computed = this\n    this.effect.active = this._cacheable = !isSSR\n    this[ReactiveFlags.IS_READONLY] = isReadonly\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    const self = toRaw(this)\n    trackRefValue(self)\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false\n      self._value = self.effect.run()!\n    }\n    return self._value\n  }\n\n  set value(newValue: T) {\n    this._setter(newValue)\n  }\n}\n\nexport function computed<T>(\n  getter: ComputedGetter<T>,\n  debugOptions?: DebuggerOptions\n): ComputedRef<T>\nexport function computed<T>(\n  options: WritableComputedOptions<T>,\n  debugOptions?: DebuggerOptions\n): WritableComputedRef<T>\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\n  debugOptions?: DebuggerOptions,\n  isSSR = false\n) {\n  let getter: ComputedGetter<T>\n  let setter: ComputedSetter<T>\n\n  const onlyGetter = isFunction(getterOrOptions)\n  if (onlyGetter) {\n    getter = getterOrOptions\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\n\n  if (__DEV__ && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack\n    cRef.effect.onTrigger = debugOptions.onTrigger\n  }\n\n  return cRef as any\n}\n","import { Dep } from './dep'\nimport { ReactiveEffect } from './effect'\nimport { ComputedGetter, ComputedRef } from './computed'\nimport { ReactiveFlags, toRaw } from './reactive'\nimport { trackRefValue, triggerRefValue } from './ref'\n\nconst tick = /*#__PURE__*/ Promise.resolve()\nconst queue: any[] = []\nlet queued = false\n\nconst scheduler = (fn: any) => {\n  queue.push(fn)\n  if (!queued) {\n    queued = true\n    tick.then(flush)\n  }\n}\n\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue.length = 0\n  queued = false\n}\n\nclass DeferredComputedRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private _value!: T\n  private _dirty = true\n  public readonly effect: ReactiveEffect<T>\n\n  public readonly __v_isRef = true\n  public readonly [ReactiveFlags.IS_READONLY] = true\n\n  constructor(getter: ComputedGetter<T>) {\n    let compareTarget: any\n    let hasCompareTarget = false\n    let scheduled = false\n    this.effect = new ReactiveEffect(getter, (computedTrigger?: boolean) => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value\n          hasCompareTarget = true\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value\n          scheduled = true\n          hasCompareTarget = false\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this)\n            }\n            scheduled = false\n          })\n        }\n        // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler!(true /* computedTrigger */)\n          }\n        }\n      }\n      this._dirty = true\n    })\n    this.effect.computed = this as any\n  }\n\n  private _get() {\n    if (this._dirty) {\n      this._dirty = false\n      return (this._value = this.effect.run()!)\n    }\n    return this._value\n  }\n\n  get value() {\n    trackRefValue(this)\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    return toRaw(this)._get()\n  }\n}\n\nexport function deferredComputed<T>(getter: () => T): ComputedRef<T> {\n  return new DeferredComputedRefImpl(getter) as any\n}\n"],"names":["get","has","set"],"mappings":"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"}