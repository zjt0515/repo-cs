{"version":3,"file":"reactivity.esm-browser.prod.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/effectScope.ts","../src/dep.ts","../src/effect.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts","../src/deferredComputed.ts"],"sourcesContent":["/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","import { makeMap } from './makeMap'\n\nexport { makeMap }\nexport * from './patchFlags'\nexport * from './shapeFlags'\nexport * from './slotFlags'\nexport * from './globalsWhitelist'\nexport * from './codeframe'\nexport * from './normalizeProp'\nexport * from './domTagConfig'\nexport * from './domAttrConfig'\nexport * from './escapeHtml'\nexport * from './looseEqual'\nexport * from './toDisplayString'\nexport * from './typeUtils'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nconst onRE = /^on[^a-z]/\nexport const isOn = (key: string) => onRE.test(key)\n\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\n\nexport const extend = Object.assign\n\nexport const remove = <T>(arr: T[], el: T) => {\n  const i = arr.indexOf(el)\n  if (i > -1) {\n    arr.splice(i, 1)\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isMap = (val: unknown): val is Map<any, any> =>\n  toTypeString(val) === '[object Map]'\nexport const isSet = (val: unknown): val is Set<any> =>\n  toTypeString(val) === '[object Set]'\n\nexport const isDate = (val: unknown): val is Date => toTypeString(val) === '[object Date]'\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const toRawType = (value: unknown): string => {\n  // extract \"RawType\" from strings like \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isIntegerKey = (key: unknown) =>\n  isString(key) &&\n  key !== 'NaN' &&\n  key[0] !== '-' &&\n  '' + parseInt(key, 10) === key\n\nexport const isReservedProp = /*#__PURE__*/ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  ',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\n)\n\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'\n)\n\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\n  const cache: Record<string, string> = Object.create(null)\n  return ((str: string) => {\n    const hit = cache[str]\n    return hit || (cache[str] = fn(str))\n  }) as any\n}\n\nconst camelizeRE = /-(\\w)/g\n/**\n * @private\n */\nexport const camelize = cacheStringFunction((str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n})\n\nconst hyphenateRE = /\\B([A-Z])/g\n/**\n * @private\n */\nexport const hyphenate = cacheStringFunction((str: string) =>\n  str.replace(hyphenateRE, '-$1').toLowerCase()\n)\n\n/**\n * @private\n */\nexport const capitalize = cacheStringFunction(\n  (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\n)\n\n/**\n * @private\n */\nexport const toHandlerKey = cacheStringFunction((str: string) =>\n  str ? `on${capitalize(str)}` : ``\n)\n\n// compare whether a value has changed, accounting for NaN.\nexport const hasChanged = (value: any, oldValue: any): boolean =>\n  !Object.is(value, oldValue)\n\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg)\n  }\n}\n\nexport const def = (obj: object, key: string | symbol, value: any) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  })\n}\n\nexport const toNumber = (val: any): any => {\n  const n = parseFloat(val)\n  return isNaN(n) ? val : n\n}\n\nlet _globalThis: any\nexport const getGlobalThis = (): any => {\n  return (\n    _globalThis ||\n    (_globalThis =\n      typeof globalThis !== 'undefined'\n        ? globalThis\n        : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n        ? window\n        : typeof global !== 'undefined'\n        ? global\n        : {})\n  )\n}\n\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\n\nexport function genPropsAccessExp(name: string) {\n  return identRE.test(name)\n    ? `__props.${name}`\n    : `__props[${JSON.stringify(name)}]`\n}\n","import { ReactiveEffect } from './effect'\nimport { warn } from './warning'\n\nlet activeEffectScope: EffectScope | undefined\n\nexport class EffectScope {\n  /**\n   * @internal\n   */\n  active = true\n  /**\n   * @internal\n   */\n  effects: ReactiveEffect[] = []\n  /**\n   * @internal\n   */\n  cleanups: (() => void)[] = []\n\n  /**\n   * only assigned by undetached scope\n   * @internal\n   */\n  parent: EffectScope | undefined\n  /**\n   * record undetached scopes\n   * @internal\n   */\n  scopes: EffectScope[] | undefined\n  /**\n   * track a child scope's index in its parent's scopes array for optimized\n   * removal\n   * @internal\n   */\n  private index: number | undefined\n\n  constructor(detached = false) {\n    if (!detached && activeEffectScope) {\n      this.parent = activeEffectScope\n      this.index =\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n          this\n        ) - 1\n    }\n  }\n\n  run<T>(fn: () => T): T | undefined {\n    if (this.active) {\n      const currentEffectScope = activeEffectScope\n      try {\n        activeEffectScope = this\n        return fn()\n      } finally {\n        activeEffectScope = currentEffectScope\n      }\n    } else if (__DEV__) {\n      warn(`cannot run an inactive effect scope.`)\n    }\n  }\n\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this\n  }\n\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent\n  }\n\n  stop(fromParent?: boolean) {\n    if (this.active) {\n      let i, l\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop()\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]()\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true)\n        }\n      }\n      // nested scope, dereference from parent to avoid memory leaks\n      if (this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes!.pop()\n        if (last && last !== this) {\n          this.parent.scopes![this.index!] = last\n          last.index = this.index!\n        }\n      }\n      this.active = false\n    }\n  }\n}\n\nexport function effectScope(detached?: boolean) {\n  return new EffectScope(detached)\n}\n\nexport function recordEffectScope(\n  effect: ReactiveEffect,\n  scope: EffectScope | undefined = activeEffectScope\n) {\n  if (scope && scope.active) {\n    scope.effects.push(effect)\n  }\n}\n\nexport function getCurrentScope() {\n  return activeEffectScope\n}\n\nexport function onScopeDispose(fn: () => void) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn)\n  } else if (__DEV__) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope` +\n        ` to be associated with.`\n    )\n  }\n}\n","import { ReactiveEffect, trackOpBit } from './effect'\n\nexport type Dep = Set<ReactiveEffect> & TrackedMarkers\n\n/**\n * wasTracked and newTracked maintain the status for several levels of effect\n * tracking recursion. One bit per level is used to define whether the dependency\n * was/is tracked.\n */\ntype TrackedMarkers = {\n  /**\n   * wasTracked\n   */\n  w: number\n  /**\n   * newTracked\n   */\n  n: number\n}\n\nexport const createDep = (effects?: ReactiveEffect[]): Dep => {\n  const dep = new Set<ReactiveEffect>(effects) as Dep\n  dep.w = 0\n  dep.n = 0\n  return dep\n}\n\nexport const wasTracked = (dep: Dep): boolean => (dep.w & trackOpBit) > 0\n\nexport const newTracked = (dep: Dep): boolean => (dep.n & trackOpBit) > 0\n\nexport const initDepMarkers = ({ deps }: ReactiveEffect) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit // set was tracked\n    }\n  }\n}\n\nexport const finalizeDepMarkers = (effect: ReactiveEffect) => {\n  const { deps } = effect\n  if (deps.length) {\n    let ptr = 0\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i]\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect)\n      } else {\n        deps[ptr++] = dep\n      }\n      // clear bits\n      dep.w &= ~trackOpBit\n      dep.n &= ~trackOpBit\n    }\n    deps.length = ptr\n  }\n}\n","import { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { extend, isArray, isIntegerKey, isMap } from '@vue/shared'\nimport { EffectScope, recordEffectScope } from './effectScope'\nimport {\n  createDep,\n  Dep,\n  finalizeDepMarkers,\n  initDepMarkers,\n  newTracked,\n  wasTracked\n} from './dep'\nimport { ComputedRefImpl } from './computed'\n\n// The main WeakMap that stores {target -> key -> dep} connections.\n// Conceptually, it's easier to think of a dependency as a Dep class\n// which maintains a Set of subscribers, but we simply store them as\n// raw Sets to reduce memory overhead.\ntype KeyToDepMap = Map<any, Dep>\nconst targetMap = new WeakMap<any, KeyToDepMap>()\n\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0\n\nexport let trackOpBit = 1\n\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30\n\nexport type EffectScheduler = (...args: any[]) => any\n\nexport type DebuggerEvent = {\n  effect: ReactiveEffect\n} & DebuggerEventExtraInfo\n\nexport type DebuggerEventExtraInfo = {\n  target: object\n  type: TrackOpTypes | TriggerOpTypes\n  key: any\n  newValue?: any\n  oldValue?: any\n  oldTarget?: Map<any, any> | Set<any>\n}\n\nexport let activeEffect: ReactiveEffect | undefined\n\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\n\nexport class ReactiveEffect<T = any> {\n  active = true\n  deps: Dep[] = []\n  parent: ReactiveEffect | undefined = undefined\n\n  /**\n   * Can be attached after creation\n   * @internal\n   */\n  computed?: ComputedRefImpl<T>\n  /**\n   * @internal\n   */\n  allowRecurse?: boolean\n  /**\n   * @internal\n   */\n  private deferStop?: boolean\n\n  onStop?: () => void\n  // dev only\n  onTrack?: (event: DebuggerEvent) => void\n  // dev only\n  onTrigger?: (event: DebuggerEvent) => void\n\n  constructor(\n    public fn: () => T,\n    public scheduler: EffectScheduler | null = null,\n    scope?: EffectScope\n  ) {\n    recordEffectScope(this, scope)\n  }\n\n  run() {\n    if (!this.active) {\n      return this.fn()\n    }\n    let parent: ReactiveEffect | undefined = activeEffect\n    let lastShouldTrack = shouldTrack\n    while (parent) {\n      if (parent === this) {\n        return\n      }\n      parent = parent.parent\n    }\n    try {\n      this.parent = activeEffect\n      activeEffect = this\n      shouldTrack = true\n\n      trackOpBit = 1 << ++effectTrackDepth\n\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this)\n      } else {\n        cleanupEffect(this)\n      }\n      return this.fn()\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this)\n      }\n\n      trackOpBit = 1 << --effectTrackDepth\n\n      activeEffect = this.parent\n      shouldTrack = lastShouldTrack\n      this.parent = undefined\n\n      if (this.deferStop) {\n        this.stop()\n      }\n    }\n  }\n\n  stop() {\n    // stopped while running itself - defer the cleanup\n    if (activeEffect === this) {\n      this.deferStop = true\n    } else if (this.active) {\n      cleanupEffect(this)\n      if (this.onStop) {\n        this.onStop()\n      }\n      this.active = false\n    }\n  }\n}\n\nfunction cleanupEffect(effect: ReactiveEffect) {\n  const { deps } = effect\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect)\n    }\n    deps.length = 0\n  }\n}\n\nexport interface DebuggerOptions {\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\nexport interface ReactiveEffectOptions extends DebuggerOptions {\n  lazy?: boolean\n  scheduler?: EffectScheduler\n  scope?: EffectScope\n  allowRecurse?: boolean\n  onStop?: () => void\n}\n\nexport interface ReactiveEffectRunner<T = any> {\n  (): T\n  effect: ReactiveEffect\n}\n\nexport function effect<T = any>(\n  fn: () => T,\n  options?: ReactiveEffectOptions\n): ReactiveEffectRunner {\n  if ((fn as ReactiveEffectRunner).effect) {\n    fn = (fn as ReactiveEffectRunner).effect.fn\n  }\n\n  const _effect = new ReactiveEffect(fn)\n  if (options) {\n    extend(_effect, options)\n    if (options.scope) recordEffectScope(_effect, options.scope)\n  }\n  if (!options || !options.lazy) {\n    _effect.run()\n  }\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\n  runner.effect = _effect\n  return runner\n}\n\nexport function stop(runner: ReactiveEffectRunner) {\n  runner.effect.stop()\n}\n\nexport let shouldTrack = true\nconst trackStack: boolean[] = []\n\nexport function pauseTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = false\n}\n\nexport function enableTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = true\n}\n\nexport function resetTracking() {\n  const last = trackStack.pop()\n  shouldTrack = last === undefined ? true : last\n}\n\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n      depsMap.set(key, (dep = createDep()))\n    }\n\n    const eventInfo = __DEV__\n      ? { effect: activeEffect, target, type, key }\n      : undefined\n\n    trackEffects(dep, eventInfo)\n  }\n}\n\nexport function trackEffects(\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\n) {\n  let shouldTrack = false\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit // set newly tracked\n      shouldTrack = !wasTracked(dep)\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect!)\n  }\n\n  if (shouldTrack) {\n    dep.add(activeEffect!)\n    activeEffect!.deps.push(dep)\n    if (__DEV__ && activeEffect!.onTrack) {\n      activeEffect!.onTrack({\n        effect: activeEffect!,\n        ...debuggerEventExtraInfo!\n      })\n    }\n  }\n}\n\nexport function trigger(\n  target: object,\n  type: TriggerOpTypes,\n  key?: unknown,\n  newValue?: unknown,\n  oldValue?: unknown,\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\n) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // never been tracked\n    return\n  }\n\n  let deps: (Dep | undefined)[] = []\n  if (type === TriggerOpTypes.CLEAR) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()]\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= (newValue as number)) {\n        deps.push(dep)\n      }\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key))\n    }\n\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'))\n        }\n        break\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        break\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  const eventInfo = __DEV__\n    ? { target, type, key, newValue, oldValue, oldTarget }\n    : undefined\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (__DEV__) {\n        triggerEffects(deps[0], eventInfo)\n      } else {\n        triggerEffects(deps[0])\n      }\n    }\n  } else {\n    const effects: ReactiveEffect[] = []\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep)\n      }\n    }\n    if (__DEV__) {\n      triggerEffects(createDep(effects), eventInfo)\n    } else {\n      triggerEffects(createDep(effects))\n    }\n  }\n}\n\nexport function triggerEffects(\n  dep: Dep | ReactiveEffect[],\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\n) {\n  // spread into array for stabilization\n  const effects = isArray(dep) ? dep : [...dep]\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n}\n\nfunction triggerEffect(\n  effect: ReactiveEffect,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\n) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    if (__DEV__ && effect.onTrigger) {\n      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo))\n    }\n    if (effect.scheduler) {\n      effect.scheduler()\n    } else {\n      effect.run()\n    }\n  }\n}\n","import {\n  reactive,\n  readonly,\n  toRaw,\n  ReactiveFlags,\n  Target,\n  readonlyMap,\n  reactiveMap,\n  shallowReactiveMap,\n  shallowReadonlyMap,\n  isReadonly,\n  isShallow\n} from './reactive'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport {\n  track,\n  trigger,\n  ITERATE_KEY,\n  pauseTracking,\n  resetTracking\n} from './effect'\nimport {\n  isObject,\n  hasOwn,\n  isSymbol,\n  hasChanged,\n  isArray,\n  isIntegerKey,\n  extend,\n  makeMap\n} from '@vue/shared'\nimport { isRef } from './ref'\nimport { warn } from './warning'\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\n\nconst builtInSymbols = new Set(\n  /*#__PURE__*/\n  Object.getOwnPropertyNames(Symbol)\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n    // function\n    .filter(key => key !== 'arguments' && key !== 'caller')\n    .map(key => (Symbol as any)[key])\n    .filter(isSymbol)\n)\n\nconst get = /*#__PURE__*/ createGetter()\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\n\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n  const instrumentations: Record<string, Function> = {}\n  // instrument identity-sensitive Array methods to account for possible reactive\n  // values\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      const arr = toRaw(this) as any\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, TrackOpTypes.GET, i + '')\n      }\n      // we run the method using the original args first (which may be reactive)\n      const res = arr[key](...args)\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key](...args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      pauseTracking()\n      const res = (toRaw(this) as any)[key].apply(this, args)\n      resetTracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\n      return shallow\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n          ? shallowReactiveMap\n          : reactiveMap\n        ).get(target)\n    ) {\n      return target\n    }\n\n    const targetIsArray = isArray(target)\n\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n\n    const res = Reflect.get(target, key, receiver)\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n\n    if (shallow) {\n      return res\n    }\n\n    if (isRef(res)) {\n      // ref unwrapping - skip unwrap for Array + integer key.\n      return targetIsArray && isIntegerKey(key) ? res : res.value\n    }\n\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n\n    return res\n  }\n}\n\nconst set = /*#__PURE__*/ createSetter()\nconst shallowSet = /*#__PURE__*/ createSetter(true)\n\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object,\n    key: string | symbol,\n    value: unknown,\n    receiver: object\n  ): boolean {\n    let oldValue = (target as any)[key]\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue)\n        value = toRaw(value)\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n\nfunction deleteProperty(target: object, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = (target as any)[key]\n  const result = Reflect.deleteProperty(target, key)\n  if (result && hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\nfunction has(target: object, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, TrackOpTypes.HAS, key)\n  }\n  return result\n}\n\nfunction ownKeys(target: object): (string | symbol)[] {\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n\nexport const readonlyHandlers: ProxyHandler<object> = {\n  get: readonlyGet,\n  set(target, key) {\n    if (__DEV__) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      )\n    }\n    return true\n  },\n  deleteProperty(target, key) {\n    if (__DEV__) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      )\n    }\n    return true\n  }\n}\n\nexport const shallowReactiveHandlers = /*#__PURE__*/ extend(\n  {},\n  mutableHandlers,\n  {\n    get: shallowGet,\n    set: shallowSet\n  }\n)\n\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nexport const shallowReadonlyHandlers = /*#__PURE__*/ extend(\n  {},\n  readonlyHandlers,\n  {\n    get: shallowReadonlyGet\n  }\n)\n","import { toRaw, ReactiveFlags, toReactive, toReadonly } from './reactive'\nimport { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './effect'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { capitalize, hasOwn, hasChanged, toRawType, isMap } from '@vue/shared'\n\nexport type CollectionTypes = IterableCollections | WeakCollections\n\ntype IterableCollections = Map<any, any> | Set<any>\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\ntype MapTypes = Map<any, any> | WeakMap<any, any>\ntype SetTypes = Set<any> | WeakSet<any>\n\nconst toShallow = <T extends unknown>(value: T): T => value\n\nconst getProto = <T extends CollectionTypes>(v: T): any =>\n  Reflect.getPrototypeOf(v)\n\nfunction get(\n  target: MapTypes,\n  key: unknown,\n  isReadonly = false,\n  isShallow = false\n) {\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = (target as any)[ReactiveFlags.RAW]\n  const rawTarget = toRaw(target)\n  const rawKey = toRaw(key)\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, TrackOpTypes.GET, key)\n    }\n    track(rawTarget, TrackOpTypes.GET, rawKey)\n  }\n  const { has } = getProto(rawTarget)\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key))\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey))\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key)\n  }\n}\n\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\n  const target = (this as any)[ReactiveFlags.RAW]\n  const rawTarget = toRaw(target)\n  const rawKey = toRaw(key)\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, TrackOpTypes.HAS, key)\n    }\n    track(rawTarget, TrackOpTypes.HAS, rawKey)\n  }\n  return key === rawKey\n    ? target.has(key)\n    : target.has(key) || target.has(rawKey)\n}\n\nfunction size(target: IterableCollections, isReadonly = false) {\n  target = (target as any)[ReactiveFlags.RAW]\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\n  return Reflect.get(target, 'size', target)\n}\n\nfunction add(this: SetTypes, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto = getProto(target)\n  const hadKey = proto.has.call(target, value)\n  if (!hadKey) {\n    target.add(value)\n    trigger(target, TriggerOpTypes.ADD, value, value)\n  }\n  return this\n}\n\nfunction set(this: MapTypes, key: unknown, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const { has, get } = getProto(target)\n\n  let hadKey = has.call(target, key)\n  if (!hadKey) {\n    key = toRaw(key)\n    hadKey = has.call(target, key)\n  } else if (__DEV__) {\n    checkIdentityKeys(target, has, key)\n  }\n\n  const oldValue = get.call(target, key)\n  target.set(key, value)\n  if (!hadKey) {\n    trigger(target, TriggerOpTypes.ADD, key, value)\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n  }\n  return this\n}\n\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\n  const target = toRaw(this)\n  const { has, get } = getProto(target)\n  let hadKey = has.call(target, key)\n  if (!hadKey) {\n    key = toRaw(key)\n    hadKey = has.call(target, key)\n  } else if (__DEV__) {\n    checkIdentityKeys(target, has, key)\n  }\n\n  const oldValue = get ? get.call(target, key) : undefined\n  // forward the operation before queueing reactions\n  const result = target.delete(key)\n  if (hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\nfunction clear(this: IterableCollections) {\n  const target = toRaw(this)\n  const hadItems = target.size !== 0\n  const oldTarget = __DEV__\n    ? isMap(target)\n      ? new Map(target)\n      : new Set(target)\n    : undefined\n  // forward the operation before queueing reactions\n  const result = target.clear()\n  if (hadItems) {\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\n  }\n  return result\n}\n\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\n  return function forEach(\n    this: IterableCollections,\n    callback: Function,\n    thisArg?: unknown\n  ) {\n    const observed = this as any\n    const target = observed[ReactiveFlags.RAW]\n    const rawTarget = toRaw(target)\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\n    return target.forEach((value: unknown, key: unknown) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\n    })\n  }\n}\n\ninterface Iterable {\n  [Symbol.iterator](): Iterator\n}\n\ninterface Iterator {\n  next(value?: any): IterationResult\n}\n\ninterface IterationResult {\n  value: any\n  done: boolean\n}\n\nfunction createIterableMethod(\n  method: string | symbol,\n  isReadonly: boolean,\n  isShallow: boolean\n) {\n  return function (\n    this: IterableCollections,\n    ...args: unknown[]\n  ): Iterable & Iterator {\n    const target = (this as any)[ReactiveFlags.RAW]\n    const rawTarget = toRaw(target)\n    const targetIsMap = isMap(rawTarget)\n    const isPair =\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\n    const isKeyOnly = method === 'keys' && targetIsMap\n    const innerIterator = target[method](...args)\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n    !isReadonly &&\n      track(\n        rawTarget,\n        TrackOpTypes.ITERATE,\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n      )\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next()\n        return done\n          ? { value, done }\n          : {\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n              done\n            }\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this\n      }\n    }\n  }\n}\n\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\n  return function (this: CollectionTypes, ...args: unknown[]) {\n    if (__DEV__) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\n      console.warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      )\n    }\n    return type === TriggerOpTypes.DELETE ? false : this\n  }\n}\n\nfunction createInstrumentations() {\n  const mutableInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  }\n\n  const shallowInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, false, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  }\n\n  const readonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, false)\n  }\n\n  const shallowReadonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, true)\n  }\n\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations[method as string] = createIterableMethod(\n      method,\n      false,\n      false\n    )\n    readonlyInstrumentations[method as string] = createIterableMethod(\n      method,\n      true,\n      false\n    )\n    shallowInstrumentations[method as string] = createIterableMethod(\n      method,\n      false,\n      true\n    )\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\n      method,\n      true,\n      true\n    )\n  })\n\n  return [\n    mutableInstrumentations,\n    readonlyInstrumentations,\n    shallowInstrumentations,\n    shallowReadonlyInstrumentations\n  ]\n}\n\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* #__PURE__*/ createInstrumentations()\n\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\n  const instrumentations = shallow\n    ? isReadonly\n      ? shallowReadonlyInstrumentations\n      : shallowInstrumentations\n    : isReadonly\n    ? readonlyInstrumentations\n    : mutableInstrumentations\n\n  return (\n    target: CollectionTypes,\n    key: string | symbol,\n    receiver: CollectionTypes\n  ) => {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.RAW) {\n      return target\n    }\n\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target\n        ? instrumentations\n        : target,\n      key,\n      receiver\n    )\n  }\n}\n\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n}\n\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n}\n\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n}\n\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\n  {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n  }\n\nfunction checkIdentityKeys(\n  target: CollectionTypes,\n  has: (key: unknown) => boolean,\n  key: unknown\n) {\n  const rawKey = toRaw(key)\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target)\n    console.warn(\n      `Reactive ${type} contains both the raw and reactive ` +\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n        `which can lead to inconsistencies. ` +\n        `Avoid differentiating between the raw and reactive versions ` +\n        `of an object and only use the reactive version if possible.`\n    )\n  }\n}\n","import { isObject, toRawType, def } from '@vue/shared'\nimport {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReactiveHandlers,\n  shallowReadonlyHandlers\n} from './baseHandlers'\nimport {\n  mutableCollectionHandlers,\n  readonlyCollectionHandlers,\n  shallowCollectionHandlers,\n  shallowReadonlyCollectionHandlers\n} from './collectionHandlers'\nimport type { UnwrapRefSimple, Ref, RawSymbol } from './ref'\n\nexport const enum ReactiveFlags {\n  SKIP = '__v_skip',\n  IS_REACTIVE = '__v_isReactive',\n  IS_READONLY = '__v_isReadonly',\n  IS_SHALLOW = '__v_isShallow',\n  RAW = '__v_raw'\n}\n\nexport interface Target {\n  [ReactiveFlags.SKIP]?: boolean\n  [ReactiveFlags.IS_REACTIVE]?: boolean\n  [ReactiveFlags.IS_READONLY]?: boolean\n  [ReactiveFlags.IS_SHALLOW]?: boolean\n  [ReactiveFlags.RAW]?: any\n}\n\nexport const reactiveMap = new WeakMap<Target, any>()\nexport const shallowReactiveMap = new WeakMap<Target, any>()\nexport const readonlyMap = new WeakMap<Target, any>()\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\n\nconst enum TargetType {\n  INVALID = 0,\n  COMMON = 1,\n  COLLECTION = 2\n}\n\nfunction targetTypeMap(rawType: string) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n\nfunction getTargetType(value: Target) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\n// only unwrap nested ref\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\n\n/**\n * Creates a reactive copy of the original object.\n *\n * The reactive conversion is \"deep\"â€”it affects all nested properties. In the\n * ES2015 Proxy based implementation, the returned proxy is **not** equal to the\n * original object. It is recommended to work exclusively with the reactive\n * proxy and avoid relying on the original object.\n *\n * A reactive object also automatically unwraps refs contained in it, so you\n * don't need to use `.value` when accessing and mutating their value:\n *\n * ```js\n * const count = ref(0)\n * const obj = reactive({\n *   count\n * })\n *\n * obj.count++\n * obj.count // -> 1\n * count.value // -> 1\n * ```\n */\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n\nexport declare const ShallowReactiveMarker: unique symbol\n\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\n\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nexport function shallowReactive<T extends object>(\n  target: T\n): ShallowReactive<T> {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  )\n}\n\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\ntype Builtin = Primitive | Function | Date | Error | RegExp\nexport type DeepReadonly<T> = T extends Builtin\n  ? T\n  : T extends Map<infer K, infer V>\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends ReadonlyMap<infer K, infer V>\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends WeakMap<infer K, infer V>\n  ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends Set<infer U>\n  ? ReadonlySet<DeepReadonly<U>>\n  : T extends ReadonlySet<infer U>\n  ? ReadonlySet<DeepReadonly<U>>\n  : T extends WeakSet<infer U>\n  ? WeakSet<DeepReadonly<U>>\n  : T extends Promise<infer U>\n  ? Promise<DeepReadonly<U>>\n  : T extends Ref<infer U>\n  ? Readonly<Ref<DeepReadonly<U>>>\n  : T extends {}\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : Readonly<T>\n\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nexport function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>> {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  )\n}\n\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  )\n}\n\nfunction createReactiveObject(\n  target: Target,\n  isReadonly: boolean,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>,\n  proxyMap: WeakMap<Target, any>\n) {\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // target already has corresponding Proxy\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // only specific value types can be observed.\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  proxyMap.set(target, proxy)\n  return proxy\n}\n\nexport function isReactive(value: unknown): boolean {\n  if (isReadonly(value)) {\n    return isReactive((value as Target)[ReactiveFlags.RAW])\n  }\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\n}\n\nexport function isReadonly(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\n}\n\nexport function isShallow(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\n}\n\nexport function isProxy(value: unknown): boolean {\n  return isReactive(value) || isReadonly(value)\n}\n\nexport function toRaw<T>(observed: T): T {\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\n  return raw ? toRaw(raw) : observed\n}\n\nexport function markRaw<T extends object>(\n  value: T\n): T & { [RawSymbol]?: true } {\n  def(value, ReactiveFlags.SKIP, true)\n  return value\n}\n\nexport const toReactive = <T extends unknown>(value: T): T =>\n  isObject(value) ? reactive(value) : value\n\nexport const toReadonly = <T extends unknown>(value: T): T =>\n  isObject(value) ? readonly(value as Record<any, any>) : value\n","import {\n  activeEffect,\n  shouldTrack,\n  trackEffects,\n  triggerEffects\n} from './effect'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { isArray, hasChanged, IfAny } from '@vue/shared'\nimport {\n  isProxy,\n  toRaw,\n  isReactive,\n  toReactive,\n  isReadonly,\n  isShallow\n} from './reactive'\nimport type { ShallowReactiveMarker } from './reactive'\nimport { CollectionTypes } from './collectionHandlers'\nimport { createDep, Dep } from './dep'\n\ndeclare const RefSymbol: unique symbol\nexport declare const RawSymbol: unique symbol\n\nexport interface Ref<T = any> {\n  value: T\n  /**\n   * Type differentiator only.\n   * We need this to be in public d.ts but don't want it to show up in IDE\n   * autocomplete, so we use a private Symbol instead.\n   */\n  [RefSymbol]: true\n}\n\ntype RefBase<T> = {\n  dep?: Dep\n  value: T\n}\n\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    if (__DEV__) {\n      trackEffects(ref.dep || (ref.dep = createDep()), {\n        target: ref,\n        type: TrackOpTypes.GET,\n        key: 'value'\n      })\n    } else {\n      trackEffects(ref.dep || (ref.dep = createDep()))\n    }\n  }\n}\n\nexport function triggerRefValue(ref: RefBase<any>, newVal?: any) {\n  ref = toRaw(ref)\n  if (ref.dep) {\n    if (__DEV__) {\n      triggerEffects(ref.dep, {\n        target: ref,\n        type: TriggerOpTypes.SET,\n        key: 'value',\n        newValue: newVal\n      })\n    } else {\n      triggerEffects(ref.dep)\n    }\n  }\n}\n\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\nexport function isRef(r: any): r is Ref {\n  return !!(r && r.__v_isRef === true)\n}\n\nexport function ref<T extends object>(\n  value: T\n): [T] extends [Ref] ? T : Ref<UnwrapRef<T>>\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n\ndeclare const ShallowRefMarker: unique symbol\n\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\n\nexport function shallowRef<T extends object>(\n  value: T\n): T extends Ref ? T : ShallowRef<T>\nexport function shallowRef<T>(value: T): ShallowRef<T>\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\nexport function shallowRef(value?: unknown) {\n  return createRef(value, true)\n}\n\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(value: T, public readonly __v_isShallow: boolean) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, newVal)\n    }\n  }\n}\n\nexport function triggerRef(ref: Ref) {\n  triggerRefValue(ref, __DEV__ ? ref.value : void 0)\n}\n\nexport function unref<T>(ref: T | Ref<T>): T {\n  return isRef(ref) ? (ref.value as any) : ref\n}\n\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key]\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value\n      return true\n    } else {\n      return Reflect.set(target, key, value, receiver)\n    }\n  }\n}\n\nexport function proxyRefs<T extends object>(\n  objectWithRefs: T\n): ShallowUnwrapRef<T> {\n  return isReactive(objectWithRefs)\n    ? objectWithRefs\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\n}\n\nexport type CustomRefFactory<T> = (\n  track: () => void,\n  trigger: () => void\n) => {\n  get: () => T\n  set: (value: T) => void\n}\n\nclass CustomRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\n\n  public readonly __v_isRef = true\n\n  constructor(factory: CustomRefFactory<T>) {\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newVal) {\n    this._set(newVal)\n  }\n}\n\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\n  return new CustomRefImpl(factory) as any\n}\n\nexport type ToRefs<T = any> = {\n  [K in keyof T]: ToRef<T[K]>\n}\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\n  if (__DEV__ && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\n  }\n  const ret: any = isArray(object) ? new Array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toRef(object, key)\n  }\n  return ret\n}\n\nclass ObjectRefImpl<T extends object, K extends keyof T> {\n  public readonly __v_isRef = true\n\n  constructor(\n    private readonly _object: T,\n    private readonly _key: K,\n    private readonly _defaultValue?: T[K]\n  ) {}\n\n  get value() {\n    const val = this._object[this._key]\n    return val === undefined ? (this._defaultValue as T[K]) : val\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal\n  }\n}\n\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): ToRef<T[K]>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  defaultValue: T[K]\n): ToRef<Exclude<T[K], undefined>>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  defaultValue?: T[K]\n): ToRef<T[K]> {\n  const val = object[key]\n  return isRef(val)\n    ? val\n    : (new ObjectRefImpl(object, key, defaultValue) as any)\n}\n\n// corner case when use narrows type\n// Ex. type RelativePath = string & { __brand: unknown }\n// RelativePath extends object -> true\ntype BaseTypes = string | number | boolean\n\n/**\n * This is a special exported interface for other packages to declare\n * additional types that should bail out for ref unwrapping. For example\n * \\@vue/runtime-dom can declare it like so in its d.ts:\n *\n * ``` ts\n * declare module '@vue/reactivity' {\n *   export interface RefUnwrapBailTypes {\n *     runtimeDOMBailTypes: Node | Window\n *   }\n * }\n * ```\n *\n * Note that api-extractor somehow refuses to include `declare module`\n * augmentations in its generated d.ts, so we have to manually append them\n * to the final generated d.ts in our build process.\n */\nexport interface RefUnwrapBailTypes {}\n\nexport type ShallowUnwrapRef<T> = {\n  [K in keyof T]: T[K] extends Ref<infer V>\n    ? V\n    : // if `V` is `unknown` that means it does not extend `Ref` and is undefined\n    T[K] extends Ref<infer V> | undefined\n    ? unknown extends V\n      ? undefined\n      : V | undefined\n    : T[K]\n}\n\nexport type UnwrapRef<T> = T extends ShallowRef<infer V>\n  ? V\n  : T extends Ref<infer V>\n  ? UnwrapRefSimple<V>\n  : UnwrapRefSimple<T>\n\nexport type UnwrapRefSimple<T> = T extends\n  | Function\n  | CollectionTypes\n  | BaseTypes\n  | Ref\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\n  | { [RawSymbol]?: true }\n  ? T\n  : T extends Array<any>\n  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\n  : T extends object & { [ShallowReactiveMarker]?: never }\n  ? {\n      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\n    }\n  : T\n","import { DebuggerOptions, ReactiveEffect } from './effect'\nimport { Ref, trackRefValue, triggerRefValue } from './ref'\nimport { isFunction, NOOP } from '@vue/shared'\nimport { ReactiveFlags, toRaw } from './reactive'\nimport { Dep } from './dep'\n\ndeclare const ComputedRefSymbol: unique symbol\n\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\n  readonly value: T\n  [ComputedRefSymbol]: true\n}\n\nexport interface WritableComputedRef<T> extends Ref<T> {\n  readonly effect: ReactiveEffect<T>\n}\n\nexport type ComputedGetter<T> = (...args: any[]) => T\nexport type ComputedSetter<T> = (v: T) => void\n\nexport interface WritableComputedOptions<T> {\n  get: ComputedGetter<T>\n  set: ComputedSetter<T>\n}\n\nexport class ComputedRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private _value!: T\n  public readonly effect: ReactiveEffect<T>\n\n  public readonly __v_isRef = true\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\n\n  public _dirty = true\n  public _cacheable: boolean\n\n  constructor(\n    getter: ComputedGetter<T>,\n    private readonly _setter: ComputedSetter<T>,\n    isReadonly: boolean,\n    isSSR: boolean\n  ) {\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true\n        triggerRefValue(this)\n      }\n    })\n    this.effect.computed = this\n    this.effect.active = this._cacheable = !isSSR\n    this[ReactiveFlags.IS_READONLY] = isReadonly\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    const self = toRaw(this)\n    trackRefValue(self)\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false\n      self._value = self.effect.run()!\n    }\n    return self._value\n  }\n\n  set value(newValue: T) {\n    this._setter(newValue)\n  }\n}\n\nexport function computed<T>(\n  getter: ComputedGetter<T>,\n  debugOptions?: DebuggerOptions\n): ComputedRef<T>\nexport function computed<T>(\n  options: WritableComputedOptions<T>,\n  debugOptions?: DebuggerOptions\n): WritableComputedRef<T>\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\n  debugOptions?: DebuggerOptions,\n  isSSR = false\n) {\n  let getter: ComputedGetter<T>\n  let setter: ComputedSetter<T>\n\n  const onlyGetter = isFunction(getterOrOptions)\n  if (onlyGetter) {\n    getter = getterOrOptions\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\n\n  if (__DEV__ && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack\n    cRef.effect.onTrigger = debugOptions.onTrigger\n  }\n\n  return cRef as any\n}\n","import { Dep } from './dep'\nimport { ReactiveEffect } from './effect'\nimport { ComputedGetter, ComputedRef } from './computed'\nimport { ReactiveFlags, toRaw } from './reactive'\nimport { trackRefValue, triggerRefValue } from './ref'\n\nconst tick = /*#__PURE__*/ Promise.resolve()\nconst queue: any[] = []\nlet queued = false\n\nconst scheduler = (fn: any) => {\n  queue.push(fn)\n  if (!queued) {\n    queued = true\n    tick.then(flush)\n  }\n}\n\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue.length = 0\n  queued = false\n}\n\nclass DeferredComputedRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private _value!: T\n  private _dirty = true\n  public readonly effect: ReactiveEffect<T>\n\n  public readonly __v_isRef = true\n  public readonly [ReactiveFlags.IS_READONLY] = true\n\n  constructor(getter: ComputedGetter<T>) {\n    let compareTarget: any\n    let hasCompareTarget = false\n    let scheduled = false\n    this.effect = new ReactiveEffect(getter, (computedTrigger?: boolean) => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value\n          hasCompareTarget = true\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value\n          scheduled = true\n          hasCompareTarget = false\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this)\n            }\n            scheduled = false\n          })\n        }\n        // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler!(true /* computedTrigger */)\n          }\n        }\n      }\n      this._dirty = true\n    })\n    this.effect.computed = this as any\n  }\n\n  private _get() {\n    if (this._dirty) {\n      this._dirty = false\n      return (this._value = this.effect.run()!)\n    }\n    return this._value\n  }\n\n  get value() {\n    trackRefValue(this)\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    return toRaw(this)._get()\n  }\n}\n\nexport function deferredComputed<T>(getter: () => T): ComputedRef<T> {\n  return new DeferredComputedRefImpl(getter) as any\n}\n"],"names":["makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","NOOP","extend","assign","hasOwnProperty","prototype","hasOwn","key","call","isArray","Array","isMap","toTypeString","isSymbol","isObject","objectToString","toString","value","isIntegerKey","parseInt","hasChanged","oldValue","is","activeEffectScope","EffectScope","constructor","detached","this","parent","index","scopes","push","run","fn","active","currentEffectScope","on","off","stop","fromParent","l","effects","cleanups","last","pop","effectScope","recordEffectScope","effect","scope","getCurrentScope","onScopeDispose","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","targetMap","WeakMap","effectTrackDepth","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","undefined","lastShouldTrack","shouldTrack","deps","initDepMarkers","cleanupEffect","ptr","delete","finalizeDepMarkers","deferStop","onStop","options","_effect","lazy","runner","bind","trackStack","pauseTracking","enableTracking","resetTracking","track","target","type","depsMap","get","set","Map","trackEffects","debuggerEventExtraInfo","has","add","trigger","newValue","oldTarget","values","forEach","triggerEffects","computed","triggerEffect","allowRecurse","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","arr","toRaw","res","apply","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","isRef","readonly","reactive","createSetter","isShallow","hadKey","Number","result","mutableHandlers","deleteProperty","ownKeys","readonlyHandlers","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","rawTarget","rawKey","wrap","toReadonly","toReactive","size","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","getTargetType","isExtensible","rawType","targetTypeMap","slice","toRawType","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","obj","defineProperty","configurable","enumerable","def","trackRefValue","ref","triggerRefValue","newVal","r","__v_isRef","createRef","shallowRef","rawValue","RefImpl","__v_isShallow","_rawValue","_value","useDirectValue","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","object","ret","toRef","ObjectRefImpl","_object","_key","_defaultValue","defaultValue","ComputedRefImpl","getter","_setter","isSSR","_dirty","_cacheable","self","getterOrOptions","debugOptions","setter","onlyGetter","tick","Promise","resolve","queue","queued","flush","DeferredComputedRefImpl","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","then","e","deferredComputed"],"mappings":"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"}