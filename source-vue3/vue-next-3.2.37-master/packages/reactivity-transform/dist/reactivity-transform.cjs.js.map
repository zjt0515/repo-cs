{"version":3,"file":"reactivity-transform.cjs.js","sources":["../src/reactivityTransform.ts"],"sourcesContent":["import {\n  Node,\n  Identifier,\n  BlockStatement,\n  CallExpression,\n  ObjectPattern,\n  ArrayPattern,\n  Program,\n  VariableDeclarator,\n  Expression,\n  VariableDeclaration\n} from '@babel/types'\nimport MagicString, { SourceMap } from 'magic-string'\nimport { walk } from 'estree-walker'\nimport {\n  extractIdentifiers,\n  isFunctionType,\n  isInDestructureAssignment,\n  isReferencedIdentifier,\n  isStaticProperty,\n  walkFunctionParams\n} from '@vue/compiler-core'\nimport { parse, ParserPlugin } from '@babel/parser'\nimport { hasOwn, isArray, isString, genPropsAccessExp } from '@vue/shared'\n\nconst CONVERT_SYMBOL = '$'\nconst ESCAPE_SYMBOL = '$$'\nconst shorthands = ['ref', 'computed', 'shallowRef', 'toRef', 'customRef']\nconst transformCheckRE = /[^\\w]\\$(?:\\$|ref|computed|shallowRef)?\\s*(\\(|\\<)/\n\nexport function shouldTransform(src: string): boolean {\n  return transformCheckRE.test(src)\n}\n\ntype Scope = Record<string, boolean | 'prop'>\n\nexport interface RefTransformOptions {\n  filename?: string\n  sourceMap?: boolean\n  parserPlugins?: ParserPlugin[]\n  importHelpersFrom?: string\n}\n\nexport interface RefTransformResults {\n  code: string\n  map: SourceMap | null\n  rootRefs: string[]\n  importedHelpers: string[]\n}\n\nexport function transform(\n  src: string,\n  {\n    filename,\n    sourceMap,\n    parserPlugins,\n    importHelpersFrom = 'vue'\n  }: RefTransformOptions = {}\n): RefTransformResults {\n  const plugins: ParserPlugin[] = parserPlugins || []\n  if (filename) {\n    if (/\\.tsx?$/.test(filename)) {\n      plugins.push('typescript')\n    }\n    if (filename.endsWith('x')) {\n      plugins.push('jsx')\n    }\n  }\n\n  const ast = parse(src, {\n    sourceType: 'module',\n    plugins\n  })\n  const s = new MagicString(src)\n  const res = transformAST(ast.program, s, 0)\n\n  // inject helper imports\n  if (res.importedHelpers.length) {\n    s.prepend(\n      `import { ${res.importedHelpers\n        .map(h => `${h} as _${h}`)\n        .join(', ')} } from '${importHelpersFrom}'\\n`\n    )\n  }\n\n  return {\n    ...res,\n    code: s.toString(),\n    map: sourceMap\n      ? s.generateMap({\n          source: filename,\n          hires: true,\n          includeContent: true\n        })\n      : null\n  }\n}\n\nexport function transformAST(\n  ast: Program,\n  s: MagicString,\n  offset = 0,\n  knownRefs?: string[],\n  knownProps?: Record<\n    string, // public prop key\n    {\n      local: string // local identifier, may be different\n      default?: any\n    }\n  >\n): {\n  rootRefs: string[]\n  importedHelpers: string[]\n} {\n  // TODO remove when out of experimental\n  warnExperimental()\n\n  let convertSymbol = CONVERT_SYMBOL\n  let escapeSymbol = ESCAPE_SYMBOL\n\n  // macro import handling\n  for (const node of ast.body) {\n    if (\n      node.type === 'ImportDeclaration' &&\n      node.source.value === 'vue/macros'\n    ) {\n      // remove macro imports\n      s.remove(node.start! + offset, node.end! + offset)\n      // check aliasing\n      for (const specifier of node.specifiers) {\n        if (specifier.type === 'ImportSpecifier') {\n          const imported = (specifier.imported as Identifier).name\n          const local = specifier.local.name\n          if (local !== imported) {\n            if (imported === ESCAPE_SYMBOL) {\n              escapeSymbol = local\n            } else if (imported === CONVERT_SYMBOL) {\n              convertSymbol = local\n            } else {\n              error(\n                `macro imports for ref-creating methods do not support aliasing.`,\n                specifier\n              )\n            }\n          }\n        }\n      }\n    }\n  }\n\n  const importedHelpers = new Set<string>()\n  const rootScope: Scope = {}\n  const scopeStack: Scope[] = [rootScope]\n  let currentScope: Scope = rootScope\n  let escapeScope: CallExpression | undefined // inside $$()\n  const excludedIds = new WeakSet<Identifier>()\n  const parentStack: Node[] = []\n  const propsLocalToPublicMap = Object.create(null)\n\n  if (knownRefs) {\n    for (const key of knownRefs) {\n      rootScope[key] = true\n    }\n  }\n  if (knownProps) {\n    for (const key in knownProps) {\n      const { local } = knownProps[key]\n      rootScope[local] = 'prop'\n      propsLocalToPublicMap[local] = key\n    }\n  }\n\n  function isRefCreationCall(callee: string): string | false {\n    if (callee === convertSymbol) {\n      return convertSymbol\n    }\n    if (callee[0] === '$' && shorthands.includes(callee.slice(1))) {\n      return callee\n    }\n    return false\n  }\n\n  function error(msg: string, node: Node) {\n    const e = new Error(msg)\n    ;(e as any).node = node\n    throw e\n  }\n\n  function helper(msg: string) {\n    importedHelpers.add(msg)\n    return `_${msg}`\n  }\n\n  function registerBinding(id: Identifier, isRef = false) {\n    excludedIds.add(id)\n    if (currentScope) {\n      currentScope[id.name] = isRef\n    } else {\n      error(\n        'registerBinding called without active scope, something is wrong.',\n        id\n      )\n    }\n  }\n\n  const registerRefBinding = (id: Identifier) => registerBinding(id, true)\n\n  let tempVarCount = 0\n  function genTempVar() {\n    return `__$temp_${++tempVarCount}`\n  }\n\n  function snip(node: Node) {\n    return s.original.slice(node.start! + offset, node.end! + offset)\n  }\n\n  function walkScope(node: Program | BlockStatement, isRoot = false) {\n    for (const stmt of node.body) {\n      if (stmt.type === 'VariableDeclaration') {\n        walkVariableDeclaration(stmt, isRoot)\n      } else if (\n        stmt.type === 'FunctionDeclaration' ||\n        stmt.type === 'ClassDeclaration'\n      ) {\n        if (stmt.declare || !stmt.id) continue\n        registerBinding(stmt.id)\n      } else if (\n        (stmt.type === 'ForOfStatement' || stmt.type === 'ForInStatement') &&\n        stmt.left.type === 'VariableDeclaration'\n      ) {\n        walkVariableDeclaration(stmt.left)\n      } else if (\n        stmt.type === 'ExportNamedDeclaration' &&\n        stmt.declaration &&\n        stmt.declaration.type === 'VariableDeclaration'\n      ) {\n        walkVariableDeclaration(stmt.declaration, isRoot)\n      } else if (\n        stmt.type === 'LabeledStatement' &&\n        stmt.body.type === 'VariableDeclaration'\n      ) {\n        walkVariableDeclaration(stmt.body, isRoot)\n      }\n    }\n  }\n\n  function walkVariableDeclaration(stmt: VariableDeclaration, isRoot = false) {\n    if (stmt.declare) {\n      return\n    }\n    for (const decl of stmt.declarations) {\n      let refCall\n      const isCall =\n        decl.init &&\n        decl.init.type === 'CallExpression' &&\n        decl.init.callee.type === 'Identifier'\n      if (\n        isCall &&\n        (refCall = isRefCreationCall((decl as any).init.callee.name))\n      ) {\n        processRefDeclaration(refCall, decl.id, decl.init as CallExpression)\n      } else {\n        const isProps =\n          isRoot && isCall && (decl as any).init.callee.name === 'defineProps'\n        for (const id of extractIdentifiers(decl.id)) {\n          if (isProps) {\n            // for defineProps destructure, only exclude them since they\n            // are already passed in as knownProps\n            excludedIds.add(id)\n          } else {\n            registerBinding(id)\n          }\n        }\n      }\n    }\n  }\n\n  function processRefDeclaration(\n    method: string,\n    id: VariableDeclarator['id'],\n    call: CallExpression\n  ) {\n    excludedIds.add(call.callee as Identifier)\n    if (method === convertSymbol) {\n      // $\n      // remove macro\n      s.remove(call.callee.start! + offset, call.callee.end! + offset)\n      if (id.type === 'Identifier') {\n        // single variable\n        registerRefBinding(id)\n      } else if (id.type === 'ObjectPattern') {\n        processRefObjectPattern(id, call)\n      } else if (id.type === 'ArrayPattern') {\n        processRefArrayPattern(id, call)\n      }\n    } else {\n      // shorthands\n      if (id.type === 'Identifier') {\n        registerRefBinding(id)\n        // replace call\n        s.overwrite(\n          call.start! + offset,\n          call.start! + method.length + offset,\n          helper(method.slice(1))\n        )\n      } else {\n        error(`${method}() cannot be used with destructure patterns.`, call)\n      }\n    }\n  }\n\n  function processRefObjectPattern(\n    pattern: ObjectPattern,\n    call: CallExpression,\n    tempVar?: string,\n    path: PathSegment[] = []\n  ) {\n    if (!tempVar) {\n      tempVar = genTempVar()\n      // const { x } = $(useFoo()) --> const __$temp_1 = useFoo()\n      s.overwrite(pattern.start! + offset, pattern.end! + offset, tempVar)\n    }\n\n    for (const p of pattern.properties) {\n      let nameId: Identifier | undefined\n      let key: Expression | string | undefined\n      let defaultValue: Expression | undefined\n      if (p.type === 'ObjectProperty') {\n        if (p.key.start! === p.value.start!) {\n          // shorthand { foo }\n          nameId = p.key as Identifier\n          if (p.value.type === 'Identifier') {\n            // avoid shorthand value identifier from being processed\n            excludedIds.add(p.value)\n          } else if (\n            p.value.type === 'AssignmentPattern' &&\n            p.value.left.type === 'Identifier'\n          ) {\n            // { foo = 1 }\n            excludedIds.add(p.value.left)\n            defaultValue = p.value.right\n          }\n        } else {\n          key = p.computed ? p.key : (p.key as Identifier).name\n          if (p.value.type === 'Identifier') {\n            // { foo: bar }\n            nameId = p.value\n          } else if (p.value.type === 'ObjectPattern') {\n            processRefObjectPattern(p.value, call, tempVar, [...path, key])\n          } else if (p.value.type === 'ArrayPattern') {\n            processRefArrayPattern(p.value, call, tempVar, [...path, key])\n          } else if (p.value.type === 'AssignmentPattern') {\n            if (p.value.left.type === 'Identifier') {\n              // { foo: bar = 1 }\n              nameId = p.value.left\n              defaultValue = p.value.right\n            } else if (p.value.left.type === 'ObjectPattern') {\n              processRefObjectPattern(p.value.left, call, tempVar, [\n                ...path,\n                [key, p.value.right]\n              ])\n            } else if (p.value.left.type === 'ArrayPattern') {\n              processRefArrayPattern(p.value.left, call, tempVar, [\n                ...path,\n                [key, p.value.right]\n              ])\n            } else {\n              // MemberExpression case is not possible here, ignore\n            }\n          }\n        }\n      } else {\n        // rest element { ...foo }\n        error(`reactivity destructure does not support rest elements.`, p)\n      }\n      if (nameId) {\n        registerRefBinding(nameId)\n        // inject toRef() after original replaced pattern\n        const source = pathToString(tempVar, path)\n        const keyStr = isString(key)\n          ? `'${key}'`\n          : key\n          ? snip(key)\n          : `'${nameId.name}'`\n        const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``\n        s.appendLeft(\n          call.end! + offset,\n          `,\\n  ${nameId.name} = ${helper(\n            'toRef'\n          )}(${source}, ${keyStr}${defaultStr})`\n        )\n      }\n    }\n  }\n\n  function processRefArrayPattern(\n    pattern: ArrayPattern,\n    call: CallExpression,\n    tempVar?: string,\n    path: PathSegment[] = []\n  ) {\n    if (!tempVar) {\n      // const [x] = $(useFoo()) --> const __$temp_1 = useFoo()\n      tempVar = genTempVar()\n      s.overwrite(pattern.start! + offset, pattern.end! + offset, tempVar)\n    }\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const e = pattern.elements[i]\n      if (!e) continue\n      let nameId: Identifier | undefined\n      let defaultValue: Expression | undefined\n      if (e.type === 'Identifier') {\n        // [a] --> [__a]\n        nameId = e\n      } else if (e.type === 'AssignmentPattern') {\n        // [a = 1]\n        nameId = e.left as Identifier\n        defaultValue = e.right\n      } else if (e.type === 'RestElement') {\n        // [...a]\n        error(`reactivity destructure does not support rest elements.`, e)\n      } else if (e.type === 'ObjectPattern') {\n        processRefObjectPattern(e, call, tempVar, [...path, i])\n      } else if (e.type === 'ArrayPattern') {\n        processRefArrayPattern(e, call, tempVar, [...path, i])\n      }\n      if (nameId) {\n        registerRefBinding(nameId)\n        // inject toRef() after original replaced pattern\n        const source = pathToString(tempVar, path)\n        const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``\n        s.appendLeft(\n          call.end! + offset,\n          `,\\n  ${nameId.name} = ${helper(\n            'toRef'\n          )}(${source}, ${i}${defaultStr})`\n        )\n      }\n    }\n  }\n\n  type PathSegmentAtom = Expression | string | number\n\n  type PathSegment =\n    | PathSegmentAtom\n    | [PathSegmentAtom, Expression /* default value */]\n\n  function pathToString(source: string, path: PathSegment[]): string {\n    if (path.length) {\n      for (const seg of path) {\n        if (isArray(seg)) {\n          source = `(${source}${segToString(seg[0])} || ${snip(seg[1])})`\n        } else {\n          source += segToString(seg)\n        }\n      }\n    }\n    return source\n  }\n\n  function segToString(seg: PathSegmentAtom): string {\n    if (typeof seg === 'number') {\n      return `[${seg}]`\n    } else if (typeof seg === 'string') {\n      return `.${seg}`\n    } else {\n      return snip(seg)\n    }\n  }\n\n  function rewriteId(\n    scope: Scope,\n    id: Identifier,\n    parent: Node,\n    parentStack: Node[]\n  ): boolean {\n    if (hasOwn(scope, id.name)) {\n      const bindingType = scope[id.name]\n      if (bindingType) {\n        const isProp = bindingType === 'prop'\n        if (isStaticProperty(parent) && parent.shorthand) {\n          // let binding used in a property shorthand\n          // skip for destructure patterns\n          if (\n            !(parent as any).inPattern ||\n            isInDestructureAssignment(parent, parentStack)\n          ) {\n            if (isProp) {\n              if (escapeScope) {\n                // prop binding in $$()\n                // { prop } -> { prop: __props_prop }\n                registerEscapedPropBinding(id)\n                s.appendLeft(\n                  id.end! + offset,\n                  `: __props_${propsLocalToPublicMap[id.name]}`\n                )\n              } else {\n                // { prop } -> { prop: __props.prop }\n                s.appendLeft(\n                  id.end! + offset,\n                  `: ${genPropsAccessExp(propsLocalToPublicMap[id.name])}`\n                )\n              }\n            } else {\n              // { foo } -> { foo: foo.value }\n              s.appendLeft(id.end! + offset, `: ${id.name}.value`)\n            }\n          }\n        } else {\n          if (isProp) {\n            if (escapeScope) {\n              // x --> __props_x\n              registerEscapedPropBinding(id)\n              s.overwrite(\n                id.start! + offset,\n                id.end! + offset,\n                `__props_${propsLocalToPublicMap[id.name]}`\n              )\n            } else {\n              // x --> __props.x\n              s.overwrite(\n                id.start! + offset,\n                id.end! + offset,\n                genPropsAccessExp(propsLocalToPublicMap[id.name])\n              )\n            }\n          } else {\n            // x --> x.value\n            s.appendLeft(id.end! + offset, '.value')\n          }\n        }\n      }\n      return true\n    }\n    return false\n  }\n\n  const propBindingRefs: Record<string, true> = {}\n  function registerEscapedPropBinding(id: Identifier) {\n    if (!propBindingRefs.hasOwnProperty(id.name)) {\n      propBindingRefs[id.name] = true\n      const publicKey = propsLocalToPublicMap[id.name]\n      s.prependRight(\n        offset,\n        `const __props_${publicKey} = ${helper(\n          `toRef`\n        )}(__props, '${publicKey}')\\n`\n      )\n    }\n  }\n\n  // check root scope first\n  walkScope(ast, true)\n  ;(walk as any)(ast, {\n    enter(node: Node, parent?: Node) {\n      parent && parentStack.push(parent)\n\n      // function scopes\n      if (isFunctionType(node)) {\n        scopeStack.push((currentScope = {}))\n        walkFunctionParams(node, registerBinding)\n        if (node.body.type === 'BlockStatement') {\n          walkScope(node.body)\n        }\n        return\n      }\n\n      // catch param\n      if (node.type === 'CatchClause') {\n        scopeStack.push((currentScope = {}))\n        if (node.param && node.param.type === 'Identifier') {\n          registerBinding(node.param)\n        }\n        walkScope(node.body)\n        return\n      }\n\n      // non-function block scopes\n      if (node.type === 'BlockStatement' && !isFunctionType(parent!)) {\n        scopeStack.push((currentScope = {}))\n        walkScope(node)\n        return\n      }\n\n      // skip type nodes\n      if (\n        parent &&\n        parent.type.startsWith('TS') &&\n        parent.type !== 'TSAsExpression' &&\n        parent.type !== 'TSNonNullExpression' &&\n        parent.type !== 'TSTypeAssertion'\n      ) {\n        return this.skip()\n      }\n\n      if (\n        node.type === 'Identifier' &&\n        // if inside $$(), skip unless this is a destructured prop binding\n        !(escapeScope && rootScope[node.name] !== 'prop') &&\n        isReferencedIdentifier(node, parent!, parentStack) &&\n        !excludedIds.has(node)\n      ) {\n        // walk up the scope chain to check if id should be appended .value\n        let i = scopeStack.length\n        while (i--) {\n          if (rewriteId(scopeStack[i], node, parent!, parentStack)) {\n            return\n          }\n        }\n      }\n\n      if (node.type === 'CallExpression' && node.callee.type === 'Identifier') {\n        const callee = node.callee.name\n\n        const refCall = isRefCreationCall(callee)\n        if (refCall && (!parent || parent.type !== 'VariableDeclarator')) {\n          return error(\n            `${refCall} can only be used as the initializer of ` +\n              `a variable declaration.`,\n            node\n          )\n        }\n\n        if (callee === escapeSymbol) {\n          s.remove(node.callee.start! + offset, node.callee.end! + offset)\n          escapeScope = node\n        }\n\n        // TODO remove when out of experimental\n        if (callee === '$raw') {\n          error(\n            `$raw() has been replaced by $$(). ` +\n              `See ${RFC_LINK} for latest updates.`,\n            node\n          )\n        }\n        if (callee === '$fromRef') {\n          error(\n            `$fromRef() has been replaced by $(). ` +\n              `See ${RFC_LINK} for latest updates.`,\n            node\n          )\n        }\n      }\n    },\n    leave(node: Node, parent?: Node) {\n      parent && parentStack.pop()\n      if (\n        (node.type === 'BlockStatement' && !isFunctionType(parent!)) ||\n        isFunctionType(node)\n      ) {\n        scopeStack.pop()\n        currentScope = scopeStack[scopeStack.length - 1] || null\n      }\n      if (node === escapeScope) {\n        escapeScope = undefined\n      }\n    }\n  })\n\n  return {\n    rootRefs: Object.keys(rootScope).filter(key => rootScope[key] === true),\n    importedHelpers: [...importedHelpers]\n  }\n}\n\nconst RFC_LINK = `https://github.com/vuejs/rfcs/discussions/369`\nconst hasWarned: Record<string, boolean> = {}\n\nfunction warnExperimental() {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined') {\n    return\n  }\n  warnOnce(\n    `Reactivity transform is an experimental feature.\\n` +\n      `Experimental features may change behavior between patch versions.\\n` +\n      `It is recommended to pin your vue dependencies to exact versions to avoid breakage.\\n` +\n      `You can follow the proposal's status at ${RFC_LINK}.`\n  )\n}\n\nfunction warnOnce(msg: string) {\n  const isNodeProd =\n    typeof process !== 'undefined' && process.env.NODE_ENV === 'production'\n  if (!isNodeProd && !__TEST__ && !hasWarned[msg]) {\n    hasWarned[msg] = true\n    warn(msg)\n  }\n}\n\nfunction warn(msg: string) {\n  console.warn(\n    `\\x1b[1m\\x1b[33m[@vue/reactivity-transform]\\x1b[0m\\x1b[33m ${msg}\\x1b[0m\\n`\n  )\n}\n"],"names":["parse","MagicString","extractIdentifiers","isString","isArray","hasOwn","isStaticProperty","isInDestructureAssignment","genPropsAccessExp","walk","isFunctionType","walkFunctionParams","isReferencedIdentifier"],"mappings":"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"}