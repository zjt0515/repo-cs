{"version":3,"file":"compiler-ssr.cjs.js","sources":["../src/runtimeHelpers.ts","../src/transforms/ssrVIf.ts","../src/transforms/ssrVFor.ts","../src/transforms/ssrTransformSlotOutlet.ts","../src/errors.ts","../src/transforms/ssrTransformTeleport.ts","../src/transforms/ssrTransformSuspense.ts","../src/transforms/ssrTransformElement.ts","../src/transforms/ssrTransformTransitionGroup.ts","../src/transforms/ssrTransformComponent.ts","../src/ssrCodegenTransform.ts","../src/transforms/ssrVModel.ts","../src/transforms/ssrVShow.ts","../src/transforms/ssrInjectFallthroughAttrs.ts","../src/transforms/ssrInjectCssVars.ts","../src/index.ts"],"sourcesContent":["import { registerRuntimeHelpers } from '@vue/compiler-dom'\n\nexport const SSR_INTERPOLATE = Symbol(`ssrInterpolate`)\nexport const SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`)\nexport const SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`)\nexport const SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`)\nexport const SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`)\nexport const SSR_RENDER_CLASS = Symbol(`ssrRenderClass`)\nexport const SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`)\nexport const SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`)\nexport const SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`)\nexport const SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`)\nexport const SSR_RENDER_LIST = Symbol(`ssrRenderList`)\nexport const SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`)\nexport const SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`)\nexport const SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`)\nexport const SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`)\nexport const SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`)\nexport const SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`)\nexport const SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`)\nexport const SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`)\n\nexport const ssrHelpers = {\n  [SSR_INTERPOLATE]: `ssrInterpolate`,\n  [SSR_RENDER_VNODE]: `ssrRenderVNode`,\n  [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,\n  [SSR_RENDER_SLOT]: `ssrRenderSlot`,\n  [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,\n  [SSR_RENDER_CLASS]: `ssrRenderClass`,\n  [SSR_RENDER_STYLE]: `ssrRenderStyle`,\n  [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,\n  [SSR_RENDER_ATTR]: `ssrRenderAttr`,\n  [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,\n  [SSR_RENDER_LIST]: `ssrRenderList`,\n  [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,\n  [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,\n  [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,\n  [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,\n  [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,\n  [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,\n  [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,\n  [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`\n}\n\n// Note: these are helpers imported from @vue/server-renderer\n// make sure the names match!\nregisterRuntimeHelpers(ssrHelpers)\n","import {\n  createStructuralDirectiveTransform,\n  processIf,\n  IfNode,\n  createIfStatement,\n  createBlockStatement,\n  createCallExpression,\n  IfBranchNode,\n  BlockStatement,\n  NodeTypes\n} from '@vue/compiler-dom'\nimport {\n  SSRTransformContext,\n  processChildrenAsStatement\n} from '../ssrCodegenTransform'\n\n// Plugin for the first transform pass, which simply constructs the AST node\nexport const ssrTransformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  processIf\n)\n\n// This is called during the 2nd transform pass to construct the SSR-specific\n// codegen nodes.\nexport function ssrProcessIf(\n  node: IfNode,\n  context: SSRTransformContext,\n  disableNestedFragments = false\n) {\n  const [rootBranch] = node.branches\n  const ifStatement = createIfStatement(\n    rootBranch.condition!,\n    processIfBranch(rootBranch, context, disableNestedFragments)\n  )\n  context.pushStatement(ifStatement)\n\n  let currentIf = ifStatement\n  for (let i = 1; i < node.branches.length; i++) {\n    const branch = node.branches[i]\n    const branchBlockStatement = processIfBranch(\n      branch,\n      context,\n      disableNestedFragments\n    )\n    if (branch.condition) {\n      // else-if\n      currentIf = currentIf.alternate = createIfStatement(\n        branch.condition,\n        branchBlockStatement\n      )\n    } else {\n      // else\n      currentIf.alternate = branchBlockStatement\n    }\n  }\n\n  if (!currentIf.alternate) {\n    currentIf.alternate = createBlockStatement([\n      createCallExpression(`_push`, ['`<!---->`'])\n    ])\n  }\n}\n\nfunction processIfBranch(\n  branch: IfBranchNode,\n  context: SSRTransformContext,\n  disableNestedFragments = false\n): BlockStatement {\n  const { children } = branch\n  const needFragmentWrapper =\n    !disableNestedFragments &&\n    (children.length !== 1 || children[0].type !== NodeTypes.ELEMENT) &&\n    // optimize away nested fragments when the only child is a ForNode\n    !(children.length === 1 && children[0].type === NodeTypes.FOR)\n  return processChildrenAsStatement(branch, context, needFragmentWrapper)\n}\n","import {\n  createStructuralDirectiveTransform,\n  ForNode,\n  processFor,\n  createCallExpression,\n  createFunctionExpression,\n  createForLoopParams,\n  NodeTypes\n} from '@vue/compiler-dom'\nimport {\n  SSRTransformContext,\n  processChildrenAsStatement\n} from '../ssrCodegenTransform'\nimport { SSR_RENDER_LIST } from '../runtimeHelpers'\n\n// Plugin for the first transform pass, which simply constructs the AST node\nexport const ssrTransformFor = createStructuralDirectiveTransform(\n  'for',\n  processFor\n)\n\n// This is called during the 2nd transform pass to construct the SSR-specific\n// codegen nodes.\nexport function ssrProcessFor(\n  node: ForNode,\n  context: SSRTransformContext,\n  disableNestedFragments = false\n) {\n  const needFragmentWrapper =\n    !disableNestedFragments &&\n    (node.children.length !== 1 || node.children[0].type !== NodeTypes.ELEMENT)\n  const renderLoop = createFunctionExpression(\n    createForLoopParams(node.parseResult)\n  )\n  renderLoop.body = processChildrenAsStatement(\n    node,\n    context,\n    needFragmentWrapper\n  )\n  // v-for always renders a fragment unless explicitly disabled\n  if (!disableNestedFragments) {\n    context.pushStringPart(`<!--[-->`)\n  }\n  context.pushStatement(\n    createCallExpression(context.helper(SSR_RENDER_LIST), [\n      node.source,\n      renderLoop\n    ])\n  )\n  if (!disableNestedFragments) {\n    context.pushStringPart(`<!--]-->`)\n  }\n}\n","import {\n  NodeTransform,\n  isSlotOutlet,\n  processSlotOutlet,\n  createCallExpression,\n  SlotOutletNode,\n  createFunctionExpression,\n  NodeTypes,\n  ElementTypes,\n  resolveComponentType,\n  TRANSITION\n} from '@vue/compiler-dom'\nimport { SSR_RENDER_SLOT, SSR_RENDER_SLOT_INNER } from '../runtimeHelpers'\nimport {\n  SSRTransformContext,\n  processChildrenAsStatement\n} from '../ssrCodegenTransform'\n\nexport const ssrTransformSlotOutlet: NodeTransform = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const { slotName, slotProps } = processSlotOutlet(node, context)\n\n    const args = [\n      `_ctx.$slots`,\n      slotName,\n      slotProps || `{}`,\n      // fallback content placeholder. will be replaced in the process phase\n      `null`,\n      `_push`,\n      `_parent`\n    ]\n\n    // inject slot scope id if current template uses :slotted\n    if (context.scopeId && context.slotted !== false) {\n      args.push(`\"${context.scopeId}-s\"`)\n    }\n\n    let method = SSR_RENDER_SLOT\n\n    // #3989\n    // check if this is a single slot inside a transition wrapper - since\n    // transition will unwrap the slot fragment into a single vnode at runtime,\n    // we need to avoid rendering the slot as a fragment.\n    const parent = context.parent\n    if (\n      parent &&\n      parent.type === NodeTypes.ELEMENT &&\n      parent.tagType === ElementTypes.COMPONENT &&\n      resolveComponentType(parent, context, true) === TRANSITION &&\n      parent.children.filter(c => c.type === NodeTypes.ELEMENT).length === 1\n    ) {\n      method = SSR_RENDER_SLOT_INNER\n      if (!(context.scopeId && context.slotted !== false)) {\n        args.push('null')\n      }\n      args.push('true')\n    }\n\n    node.ssrCodegenNode = createCallExpression(context.helper(method), args)\n  }\n}\n\nexport function ssrProcessSlotOutlet(\n  node: SlotOutletNode,\n  context: SSRTransformContext\n) {\n  const renderCall = node.ssrCodegenNode!\n\n  // has fallback content\n  if (node.children.length) {\n    const fallbackRenderFn = createFunctionExpression([])\n    fallbackRenderFn.body = processChildrenAsStatement(node, context)\n    // _renderSlot(slots, name, props, fallback, ...)\n    renderCall.arguments[3] = fallbackRenderFn\n  }\n\n  // Forwarded <slot/>. Merge slot scope ids\n  if (context.withSlotScopeId) {\n    const slotScopeId = renderCall.arguments[6]\n    renderCall.arguments[6] = slotScopeId\n      ? `${slotScopeId as string} + _scopeId`\n      : `_scopeId`\n  }\n\n  context.pushStatement(node.ssrCodegenNode!)\n}\n","import {\n  SourceLocation,\n  CompilerError,\n  createCompilerError,\n  DOMErrorCodes\n} from '@vue/compiler-dom'\n\nexport interface SSRCompilerError extends CompilerError {\n  code: SSRErrorCodes\n}\n\nexport function createSSRCompilerError(\n  code: SSRErrorCodes,\n  loc?: SourceLocation\n) {\n  return createCompilerError(code, loc, SSRErrorMessages) as SSRCompilerError\n}\n\nexport const enum SSRErrorCodes {\n  X_SSR_UNSAFE_ATTR_NAME = DOMErrorCodes.__EXTEND_POINT__,\n  X_SSR_NO_TELEPORT_TARGET,\n  X_SSR_INVALID_AST_NODE\n}\n\nexport const SSRErrorMessages: { [code: number]: string } = {\n  [SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME]: `Unsafe attribute name for SSR.`,\n  [SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET]: `Missing the 'to' prop on teleport element.`,\n  [SSRErrorCodes.X_SSR_INVALID_AST_NODE]: `Invalid AST node during SSR transform.`\n}\n","import {\n  ComponentNode,\n  findProp,\n  NodeTypes,\n  createSimpleExpression,\n  createFunctionExpression,\n  createCallExpression,\n  ExpressionNode\n} from '@vue/compiler-dom'\nimport {\n  SSRTransformContext,\n  processChildrenAsStatement\n} from '../ssrCodegenTransform'\nimport { createSSRCompilerError, SSRErrorCodes } from '../errors'\nimport { SSR_RENDER_TELEPORT } from '../runtimeHelpers'\n\n// Note: this is a 2nd-pass codegen transform.\nexport function ssrProcessTeleport(\n  node: ComponentNode,\n  context: SSRTransformContext\n) {\n  const targetProp = findProp(node, 'to')\n  if (!targetProp) {\n    context.onError(\n      createSSRCompilerError(SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET, node.loc)\n    )\n    return\n  }\n\n  let target: ExpressionNode | undefined\n  if (targetProp.type === NodeTypes.ATTRIBUTE) {\n    target =\n      targetProp.value && createSimpleExpression(targetProp.value.content, true)\n  } else {\n    target = targetProp.exp\n  }\n  if (!target) {\n    context.onError(\n      createSSRCompilerError(\n        SSRErrorCodes.X_SSR_NO_TELEPORT_TARGET,\n        targetProp.loc\n      )\n    )\n    return\n  }\n\n  const disabledProp = findProp(node, 'disabled', false, true /* allow empty */)\n  const disabled = disabledProp\n    ? disabledProp.type === NodeTypes.ATTRIBUTE\n      ? `true`\n      : disabledProp.exp || `false`\n    : `false`\n\n  const contentRenderFn = createFunctionExpression(\n    [`_push`],\n    undefined, // Body is added later\n    true, // newline\n    false, // isSlot\n    node.loc\n  )\n  contentRenderFn.body = processChildrenAsStatement(node, context)\n  context.pushStatement(\n    createCallExpression(context.helper(SSR_RENDER_TELEPORT), [\n      `_push`,\n      contentRenderFn,\n      target,\n      disabled,\n      `_parent`\n    ])\n  )\n}\n","import {\n  ComponentNode,\n  TransformContext,\n  buildSlots,\n  createFunctionExpression,\n  FunctionExpression,\n  TemplateChildNode,\n  createCallExpression,\n  SlotsExpression\n} from '@vue/compiler-dom'\nimport {\n  SSRTransformContext,\n  processChildrenAsStatement\n} from '../ssrCodegenTransform'\nimport { SSR_RENDER_SUSPENSE } from '../runtimeHelpers'\n\nconst wipMap = new WeakMap<ComponentNode, WIPEntry>()\n\ninterface WIPEntry {\n  slotsExp: SlotsExpression\n  wipSlots: Array<{\n    fn: FunctionExpression\n    children: TemplateChildNode[]\n  }>\n}\n\n// phase 1\nexport function ssrTransformSuspense(\n  node: ComponentNode,\n  context: TransformContext\n) {\n  return () => {\n    if (node.children.length) {\n      const wipEntry: WIPEntry = {\n        slotsExp: null!, // to be immediately set\n        wipSlots: []\n      }\n      wipMap.set(node, wipEntry)\n      wipEntry.slotsExp = buildSlots(node, context, (_props, children, loc) => {\n        const fn = createFunctionExpression(\n          [],\n          undefined, // no return, assign body later\n          true, // newline\n          false, // suspense slots are not treated as normal slots\n          loc\n        )\n        wipEntry.wipSlots.push({\n          fn,\n          children\n        })\n        return fn\n      }).slots\n    }\n  }\n}\n\n// phase 2\nexport function ssrProcessSuspense(\n  node: ComponentNode,\n  context: SSRTransformContext\n) {\n  // complete wip slots with ssr code\n  const wipEntry = wipMap.get(node)\n  if (!wipEntry) {\n    return\n  }\n  const { slotsExp, wipSlots } = wipEntry\n  for (let i = 0; i < wipSlots.length; i++) {\n    const slot = wipSlots[i]\n    slot.fn.body = processChildrenAsStatement(slot, context)\n  }\n  // _push(ssrRenderSuspense(slots))\n  context.pushStatement(\n    createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [\n      `_push`,\n      slotsExp\n    ])\n  )\n}\n","import {\n  NodeTransform,\n  NodeTypes,\n  ElementTypes,\n  TemplateLiteral,\n  createTemplateLiteral,\n  createInterpolation,\n  createCallExpression,\n  createConditionalExpression,\n  createSimpleExpression,\n  buildProps,\n  DirectiveNode,\n  PlainElementNode,\n  createCompilerError,\n  ErrorCodes,\n  CallExpression,\n  createArrayExpression,\n  ExpressionNode,\n  JSChildNode,\n  ArrayExpression,\n  createAssignmentExpression,\n  TextNode,\n  hasDynamicKeyVBind,\n  MERGE_PROPS,\n  isStaticArgOf,\n  createSequenceExpression,\n  InterpolationNode,\n  isStaticExp,\n  AttributeNode,\n  buildDirectiveArgs,\n  TransformContext,\n  PropsExpression\n} from '@vue/compiler-dom'\nimport {\n  escapeHtml,\n  isBooleanAttr,\n  isBuiltInDirective,\n  isSSRSafeAttrName,\n  NO,\n  propsToAttrMap\n} from '@vue/shared'\nimport { createSSRCompilerError, SSRErrorCodes } from '../errors'\nimport {\n  SSR_RENDER_ATTR,\n  SSR_RENDER_CLASS,\n  SSR_RENDER_STYLE,\n  SSR_RENDER_DYNAMIC_ATTR,\n  SSR_RENDER_ATTRS,\n  SSR_INTERPOLATE,\n  SSR_GET_DYNAMIC_MODEL_PROPS,\n  SSR_INCLUDE_BOOLEAN_ATTR,\n  SSR_GET_DIRECTIVE_PROPS\n} from '../runtimeHelpers'\nimport { SSRTransformContext, processChildren } from '../ssrCodegenTransform'\n\n// for directives with children overwrite (e.g. v-html & v-text), we need to\n// store the raw children so that they can be added in the 2nd pass.\nconst rawChildrenMap = new WeakMap<\n  PlainElementNode,\n  TemplateLiteral['elements'][0]\n>()\n\nexport const ssrTransformElement: NodeTransform = (node, context) => {\n  if (\n    node.type !== NodeTypes.ELEMENT ||\n    node.tagType !== ElementTypes.ELEMENT\n  ) {\n    return\n  }\n\n  return function ssrPostTransformElement() {\n    // element\n    // generate the template literal representing the open tag.\n    const openTag: TemplateLiteral['elements'] = [`<${node.tag}`]\n    // some tags need to be passed to runtime for special checks\n    const needTagForRuntime =\n      node.tag === 'textarea' || node.tag.indexOf('-') > 0\n\n    // v-bind=\"obj\", v-bind:[key] and custom directives can potentially\n    // overwrite other static attrs and can affect final rendering result,\n    // so when they are present we need to bail out to full `renderAttrs`\n    const hasDynamicVBind = hasDynamicKeyVBind(node)\n    const hasCustomDir = node.props.some(\n      p => p.type === NodeTypes.DIRECTIVE && !isBuiltInDirective(p.name)\n    )\n    const needMergeProps = hasDynamicVBind || hasCustomDir\n    if (needMergeProps) {\n      const { props, directives } = buildProps(\n        node,\n        context,\n        node.props,\n        false /* isComponent */,\n        false /* isDynamicComponent */,\n        true /* ssr */\n      )\n      if (props || directives.length) {\n        const mergedProps = buildSSRProps(props, directives, context)\n        const propsExp = createCallExpression(\n          context.helper(SSR_RENDER_ATTRS),\n          [mergedProps]\n        )\n\n        if (node.tag === 'textarea') {\n          const existingText = node.children[0] as\n            | TextNode\n            | InterpolationNode\n            | undefined\n          // If interpolation, this is dynamic <textarea> content, potentially\n          // injected by v-model and takes higher priority than v-bind value\n          if (!existingText || existingText.type !== NodeTypes.INTERPOLATION) {\n            // <textarea> with dynamic v-bind. We don't know if the final props\n            // will contain .value, so we will have to do something special:\n            // assign the merged props to a temp variable, and check whether\n            // it contains value (if yes, render is as children).\n            const tempId = `_temp${context.temps++}`\n            propsExp.arguments = [\n              createAssignmentExpression(\n                createSimpleExpression(tempId, false),\n                mergedProps\n              )\n            ]\n            rawChildrenMap.set(\n              node,\n              createCallExpression(context.helper(SSR_INTERPOLATE), [\n                createConditionalExpression(\n                  createSimpleExpression(`\"value\" in ${tempId}`, false),\n                  createSimpleExpression(`${tempId}.value`, false),\n                  createSimpleExpression(\n                    existingText ? existingText.content : ``,\n                    true\n                  ),\n                  false\n                )\n              ])\n            )\n          }\n        } else if (node.tag === 'input') {\n          // <input v-bind=\"obj\" v-model>\n          // we need to determine the props to render for the dynamic v-model\n          // and merge it with the v-bind expression.\n          const vModel = findVModel(node)\n          if (vModel) {\n            // 1. save the props (san v-model) in a temp variable\n            const tempId = `_temp${context.temps++}`\n            const tempExp = createSimpleExpression(tempId, false)\n            propsExp.arguments = [\n              createSequenceExpression([\n                createAssignmentExpression(tempExp, mergedProps),\n                createCallExpression(context.helper(MERGE_PROPS), [\n                  tempExp,\n                  createCallExpression(\n                    context.helper(SSR_GET_DYNAMIC_MODEL_PROPS),\n                    [\n                      tempExp, // existing props\n                      vModel.exp! // model\n                    ]\n                  )\n                ])\n              ])\n            ]\n          }\n        }\n\n        if (needTagForRuntime) {\n          propsExp.arguments.push(`\"${node.tag}\"`)\n        }\n\n        openTag.push(propsExp)\n      }\n    }\n\n    // book keeping static/dynamic class merging.\n    let dynamicClassBinding: CallExpression | undefined = undefined\n    let staticClassBinding: string | undefined = undefined\n    // all style bindings are converted to dynamic by transformStyle.\n    // but we need to make sure to merge them.\n    let dynamicStyleBinding: CallExpression | undefined = undefined\n\n    for (let i = 0; i < node.props.length; i++) {\n      const prop = node.props[i]\n      // ignore true-value/false-value on input\n      if (node.tag === 'input' && isTrueFalseValue(prop)) {\n        continue\n      }\n      // special cases with children override\n      if (prop.type === NodeTypes.DIRECTIVE) {\n        if (prop.name === 'html' && prop.exp) {\n          rawChildrenMap.set(node, prop.exp)\n        } else if (prop.name === 'text' && prop.exp) {\n          node.children = [createInterpolation(prop.exp, prop.loc)]\n        } else if (prop.name === 'slot') {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, prop.loc)\n          )\n        } else if (isTextareaWithValue(node, prop) && prop.exp) {\n          if (!needMergeProps) {\n            node.children = [createInterpolation(prop.exp, prop.loc)]\n          }\n        } else if (!needMergeProps && prop.name !== 'on') {\n          // Directive transforms.\n          const directiveTransform = context.directiveTransforms[prop.name]\n          if (directiveTransform) {\n            const { props, ssrTagParts } = directiveTransform(\n              prop,\n              node,\n              context\n            )\n            if (ssrTagParts) {\n              openTag.push(...ssrTagParts)\n            }\n            for (let j = 0; j < props.length; j++) {\n              const { key, value } = props[j]\n              if (isStaticExp(key)) {\n                let attrName = key.content\n                // static key attr\n                if (attrName === 'key' || attrName === 'ref') {\n                  continue\n                }\n                if (attrName === 'class') {\n                  openTag.push(\n                    ` class=\"`,\n                    (dynamicClassBinding = createCallExpression(\n                      context.helper(SSR_RENDER_CLASS),\n                      [value]\n                    )),\n                    `\"`\n                  )\n                } else if (attrName === 'style') {\n                  if (dynamicStyleBinding) {\n                    // already has style binding, merge into it.\n                    mergeCall(dynamicStyleBinding, value)\n                  } else {\n                    openTag.push(\n                      ` style=\"`,\n                      (dynamicStyleBinding = createCallExpression(\n                        context.helper(SSR_RENDER_STYLE),\n                        [value]\n                      )),\n                      `\"`\n                    )\n                  }\n                } else {\n                  attrName =\n                    node.tag.indexOf('-') > 0\n                      ? attrName // preserve raw name on custom elements\n                      : propsToAttrMap[attrName] || attrName.toLowerCase()\n                  if (isBooleanAttr(attrName)) {\n                    openTag.push(\n                      createConditionalExpression(\n                        createCallExpression(\n                          context.helper(SSR_INCLUDE_BOOLEAN_ATTR),\n                          [value]\n                        ),\n                        createSimpleExpression(' ' + attrName, true),\n                        createSimpleExpression('', true),\n                        false /* no newline */\n                      )\n                    )\n                  } else if (isSSRSafeAttrName(attrName)) {\n                    openTag.push(\n                      createCallExpression(context.helper(SSR_RENDER_ATTR), [\n                        key,\n                        value\n                      ])\n                    )\n                  } else {\n                    context.onError(\n                      createSSRCompilerError(\n                        SSRErrorCodes.X_SSR_UNSAFE_ATTR_NAME,\n                        key.loc\n                      )\n                    )\n                  }\n                }\n              } else {\n                // dynamic key attr\n                // this branch is only encountered for custom directive\n                // transforms that returns properties with dynamic keys\n                const args: CallExpression['arguments'] = [key, value]\n                if (needTagForRuntime) {\n                  args.push(`\"${node.tag}\"`)\n                }\n                openTag.push(\n                  createCallExpression(\n                    context.helper(SSR_RENDER_DYNAMIC_ATTR),\n                    args\n                  )\n                )\n              }\n            }\n          }\n        }\n      } else {\n        // special case: value on <textarea>\n        if (node.tag === 'textarea' && prop.name === 'value' && prop.value) {\n          rawChildrenMap.set(node, escapeHtml(prop.value.content))\n        } else if (!needMergeProps) {\n          if (prop.name === 'key' || prop.name === 'ref') {\n            continue\n          }\n          // static prop\n          if (prop.name === 'class' && prop.value) {\n            staticClassBinding = JSON.stringify(prop.value.content)\n          }\n          openTag.push(\n            ` ${prop.name}` +\n              (prop.value ? `=\"${escapeHtml(prop.value.content)}\"` : ``)\n          )\n        }\n      }\n    }\n\n    // handle co-existence of dynamic + static class bindings\n    if (dynamicClassBinding && staticClassBinding) {\n      mergeCall(dynamicClassBinding, staticClassBinding)\n      removeStaticBinding(openTag, 'class')\n    }\n\n    if (context.scopeId) {\n      openTag.push(` ${context.scopeId}`)\n    }\n\n    node.ssrCodegenNode = createTemplateLiteral(openTag)\n  }\n}\n\nexport function buildSSRProps(\n  props: PropsExpression | undefined,\n  directives: DirectiveNode[],\n  context: TransformContext\n): JSChildNode {\n  let mergePropsArgs: JSChildNode[] = []\n  if (props) {\n    if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\n      // already a mergeProps call\n      mergePropsArgs = props.arguments as JSChildNode[]\n    } else {\n      mergePropsArgs.push(props)\n    }\n  }\n  if (directives.length) {\n    for (const dir of directives) {\n      mergePropsArgs.push(\n        createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [\n          `_ctx`,\n          ...buildDirectiveArgs(dir, context).elements\n        ] as JSChildNode[])\n      )\n    }\n  }\n\n  return mergePropsArgs.length > 1\n    ? createCallExpression(context.helper(MERGE_PROPS), mergePropsArgs)\n    : mergePropsArgs[0]\n}\n\nfunction isTrueFalseValue(prop: DirectiveNode | AttributeNode) {\n  if (prop.type === NodeTypes.DIRECTIVE) {\n    return (\n      prop.name === 'bind' &&\n      prop.arg &&\n      isStaticExp(prop.arg) &&\n      (prop.arg.content === 'true-value' || prop.arg.content === 'false-value')\n    )\n  } else {\n    return prop.name === 'true-value' || prop.name === 'false-value'\n  }\n}\n\nfunction isTextareaWithValue(\n  node: PlainElementNode,\n  prop: DirectiveNode\n): boolean {\n  return !!(\n    node.tag === 'textarea' &&\n    prop.name === 'bind' &&\n    isStaticArgOf(prop.arg, 'value')\n  )\n}\n\nfunction mergeCall(call: CallExpression, arg: string | JSChildNode) {\n  const existing = call.arguments[0] as ExpressionNode | ArrayExpression\n  if (existing.type === NodeTypes.JS_ARRAY_EXPRESSION) {\n    existing.elements.push(arg)\n  } else {\n    call.arguments[0] = createArrayExpression([existing, arg])\n  }\n}\n\nfunction removeStaticBinding(\n  tag: TemplateLiteral['elements'],\n  binding: string\n) {\n  const regExp = new RegExp(`^ ${binding}=\".+\"$`)\n\n  const i = tag.findIndex(e => typeof e === 'string' && regExp.test(e))\n\n  if (i > -1) {\n    tag.splice(i, 1)\n  }\n}\n\nfunction findVModel(node: PlainElementNode): DirectiveNode | undefined {\n  return node.props.find(\n    p => p.type === NodeTypes.DIRECTIVE && p.name === 'model' && p.exp\n  ) as DirectiveNode | undefined\n}\n\nexport function ssrProcessElement(\n  node: PlainElementNode,\n  context: SSRTransformContext\n) {\n  const isVoidTag = context.options.isVoidTag || NO\n  const elementsToAdd = node.ssrCodegenNode!.elements\n  for (let j = 0; j < elementsToAdd.length; j++) {\n    context.pushStringPart(elementsToAdd[j])\n  }\n\n  // Handle slot scopeId\n  if (context.withSlotScopeId) {\n    context.pushStringPart(createSimpleExpression(`_scopeId`, false))\n  }\n\n  // close open tag\n  context.pushStringPart(`>`)\n\n  const rawChildren = rawChildrenMap.get(node)\n  if (rawChildren) {\n    context.pushStringPart(rawChildren)\n  } else if (node.children.length) {\n    processChildren(node, context)\n  }\n\n  if (!isVoidTag(node.tag)) {\n    // push closing tag\n    context.pushStringPart(`</${node.tag}>`)\n  }\n}\n","import {\n  AttributeNode,\n  buildProps,\n  ComponentNode,\n  createCallExpression,\n  DirectiveNode,\n  findProp,\n  JSChildNode,\n  NodeTypes,\n  TransformContext\n} from '@vue/compiler-dom'\nimport { SSR_RENDER_ATTRS } from '../runtimeHelpers'\nimport { processChildren, SSRTransformContext } from '../ssrCodegenTransform'\nimport { buildSSRProps } from './ssrTransformElement'\n\nconst wipMap = new WeakMap<ComponentNode, WIPEntry>()\n\ninterface WIPEntry {\n  tag: AttributeNode | DirectiveNode\n  propsExp: string | JSChildNode | null\n}\n\n// phase 1: build props\nexport function ssrTransformTransitionGroup(\n  node: ComponentNode,\n  context: TransformContext\n) {\n  return () => {\n    const tag = findProp(node, 'tag')\n    if (tag) {\n      const otherProps = node.props.filter(p => p !== tag)\n      const { props, directives } = buildProps(\n        node,\n        context,\n        otherProps,\n        true, /* isComponent */\n        false, /* isDynamicComponent */\n        true /* ssr (skip event listeners) */\n      )\n      let propsExp = null\n      if (props || directives.length) {\n        propsExp = createCallExpression(context.helper(SSR_RENDER_ATTRS), [\n          buildSSRProps(props, directives, context)\n        ])\n      }\n      wipMap.set(node, {\n        tag,\n        propsExp\n      })\n    }\n  }\n}\n\n// phase 2: process children\nexport function ssrProcessTransitionGroup(\n  node: ComponentNode,\n  context: SSRTransformContext\n) {\n  const entry = wipMap.get(node)\n  if (entry) {\n    const { tag, propsExp } = entry\n    if (tag.type === NodeTypes.DIRECTIVE) {\n      // dynamic :tag\n      context.pushStringPart(`<`)\n      context.pushStringPart(tag.exp!)\n      if (propsExp) {\n        context.pushStringPart(propsExp)\n      }\n      context.pushStringPart(`>`)\n\n      processChildren(\n        node,\n        context,\n        false,\n        /**\n         * TransitionGroup has the special runtime behavior of flattening and\n         * concatenating all children into a single fragment (in order for them to\n         * be patched using the same key map) so we need to account for that here\n         * by disabling nested fragment wrappers from being generated.\n         */\n        true\n      )\n      context.pushStringPart(`</`)\n      context.pushStringPart(tag.exp!)\n      context.pushStringPart(`>`)\n    } else {\n      // static tag\n      context.pushStringPart(`<${tag.value!.content}`)\n      if (propsExp) {\n        context.pushStringPart(propsExp)\n      }\n      context.pushStringPart(`>`)\n      processChildren(node, context, false, true)\n      context.pushStringPart(`</${tag.value!.content}>`)\n    }\n  } else {\n    // fragment\n    processChildren(node, context, true, true)\n  }\n}\n","import {\n  NodeTransform,\n  NodeTypes,\n  ElementTypes,\n  createCallExpression,\n  resolveComponentType,\n  buildProps,\n  ComponentNode,\n  SlotFnBuilder,\n  createFunctionExpression,\n  buildSlots,\n  FunctionExpression,\n  TemplateChildNode,\n  createIfStatement,\n  createSimpleExpression,\n  getBaseTransformPreset,\n  DOMNodeTransforms,\n  DOMDirectiveTransforms,\n  createReturnStatement,\n  ReturnStatement,\n  Namespaces,\n  locStub,\n  RootNode,\n  TransformContext,\n  CompilerOptions,\n  TransformOptions,\n  createRoot,\n  createTransformContext,\n  traverseNode,\n  ExpressionNode,\n  TemplateNode,\n  SUSPENSE,\n  TELEPORT,\n  TRANSITION_GROUP,\n  CREATE_VNODE,\n  CallExpression,\n  JSChildNode,\n  RESOLVE_DYNAMIC_COMPONENT,\n  TRANSITION\n} from '@vue/compiler-dom'\nimport { SSR_RENDER_COMPONENT, SSR_RENDER_VNODE } from '../runtimeHelpers'\nimport {\n  SSRTransformContext,\n  processChildren,\n  processChildrenAsStatement\n} from '../ssrCodegenTransform'\nimport { ssrProcessTeleport } from './ssrTransformTeleport'\nimport {\n  ssrProcessSuspense,\n  ssrTransformSuspense\n} from './ssrTransformSuspense'\nimport {\n  ssrProcessTransitionGroup,\n  ssrTransformTransitionGroup\n} from './ssrTransformTransitionGroup'\nimport { isSymbol, isObject, isArray } from '@vue/shared'\nimport { buildSSRProps } from './ssrTransformElement'\n\n// We need to construct the slot functions in the 1st pass to ensure proper\n// scope tracking, but the children of each slot cannot be processed until\n// the 2nd pass, so we store the WIP slot functions in a weakMap during the 1st\n// pass and complete them in the 2nd pass.\nconst wipMap = new WeakMap<ComponentNode, WIPSlotEntry[]>()\n\nconst WIP_SLOT = Symbol()\n\ninterface WIPSlotEntry {\n  type: typeof WIP_SLOT\n  fn: FunctionExpression\n  children: TemplateChildNode[]\n  vnodeBranch: ReturnStatement\n}\n\nconst componentTypeMap = new WeakMap<\n  ComponentNode,\n  string | symbol | CallExpression\n>()\n\n// ssr component transform is done in two phases:\n// In phase 1. we use `buildSlot` to analyze the children of the component into\n// WIP slot functions (it must be done in phase 1 because `buildSlot` relies on\n// the core transform context).\n// In phase 2. we convert the WIP slots from phase 1 into ssr-specific codegen\n// nodes.\nexport const ssrTransformComponent: NodeTransform = (node, context) => {\n  if (\n    node.type !== NodeTypes.ELEMENT ||\n    node.tagType !== ElementTypes.COMPONENT\n  ) {\n    return\n  }\n\n  const component = resolveComponentType(node, context, true /* ssr */)\n  const isDynamicComponent =\n    isObject(component) && component.callee === RESOLVE_DYNAMIC_COMPONENT\n  componentTypeMap.set(node, component)\n\n  if (isSymbol(component)) {\n    if (component === SUSPENSE) {\n      return ssrTransformSuspense(node, context)\n    }\n    if (component === TRANSITION_GROUP) {\n      return ssrTransformTransitionGroup(node, context)\n    }\n    return // other built-in components: fallthrough\n  }\n\n  // Build the fallback vnode-based branch for the component's slots.\n  // We need to clone the node into a fresh copy and use the buildSlots' logic\n  // to get access to the children of each slot. We then compile them with\n  // a child transform pipeline using vnode-based transforms (instead of ssr-\n  // based ones), and save the result branch (a ReturnStatement) in an array.\n  // The branch is retrieved when processing slots again in ssr mode.\n  const vnodeBranches: ReturnStatement[] = []\n  const clonedNode = clone(node)\n\n  return function ssrPostTransformComponent() {\n    // Using the cloned node, build the normal VNode-based branches (for\n    // fallback in case the child is render-fn based). Store them in an array\n    // for later use.\n    if (clonedNode.children.length) {\n      buildSlots(clonedNode, context, (props, children) => {\n        vnodeBranches.push(createVNodeSlotBranch(props, children, context))\n        return createFunctionExpression(undefined)\n      })\n    }\n\n    let propsExp: string | JSChildNode = `null`\n    if (node.props.length) {\n      // note we are not passing ssr: true here because for components, v-on\n      // handlers should still be passed\n      const { props, directives } = buildProps(\n        node,\n        context,\n        undefined,\n        true,\n        isDynamicComponent\n      )\n      if (props || directives.length) {\n        propsExp = buildSSRProps(props, directives, context)\n      }\n    }\n\n    const wipEntries: WIPSlotEntry[] = []\n    wipMap.set(node, wipEntries)\n\n    const buildSSRSlotFn: SlotFnBuilder = (props, children, loc) => {\n      const fn = createFunctionExpression(\n        [props || `_`, `_push`, `_parent`, `_scopeId`],\n        undefined, // no return, assign body later\n        true, // newline\n        true, // isSlot\n        loc\n      )\n      wipEntries.push({\n        type: WIP_SLOT,\n        fn,\n        children,\n        // also collect the corresponding vnode branch built earlier\n        vnodeBranch: vnodeBranches[wipEntries.length]\n      })\n      return fn\n    }\n\n    const slots = node.children.length\n      ? buildSlots(node, context, buildSSRSlotFn).slots\n      : `null`\n\n    if (typeof component !== 'string') {\n      // dynamic component that resolved to a `resolveDynamicComponent` call\n      // expression - since the resolved result may be a plain element (string)\n      // or a VNode, handle it with `renderVNode`.\n      node.ssrCodegenNode = createCallExpression(\n        context.helper(SSR_RENDER_VNODE),\n        [\n          `_push`,\n          createCallExpression(context.helper(CREATE_VNODE), [\n            component,\n            propsExp,\n            slots\n          ]),\n          `_parent`\n        ]\n      )\n    } else {\n      node.ssrCodegenNode = createCallExpression(\n        context.helper(SSR_RENDER_COMPONENT),\n        [component, propsExp, slots, `_parent`]\n      )\n    }\n  }\n}\n\nexport function ssrProcessComponent(\n  node: ComponentNode,\n  context: SSRTransformContext,\n  parent: { children: TemplateChildNode[] }\n) {\n  const component = componentTypeMap.get(node)!\n  if (!node.ssrCodegenNode) {\n    // this is a built-in component that fell-through.\n    if (component === TELEPORT) {\n      return ssrProcessTeleport(node, context)\n    } else if (component === SUSPENSE) {\n      return ssrProcessSuspense(node, context)\n    } else if (component === TRANSITION_GROUP) {\n      return ssrProcessTransitionGroup(node, context)\n    } else {\n      // real fall-through: Transition / KeepAlive\n      // just render its children.\n      // #5352: if is at root level of a slot, push an empty string.\n      // this does not affect the final output, but avoids all-comment slot\n      // content of being treated as empty by ssrRenderSlot().\n      if ((parent as WIPSlotEntry).type === WIP_SLOT) {\n        context.pushStringPart(``)\n      }\n      // #5351: filter out comment children inside transition\n      if (component === TRANSITION) {\n        node.children = node.children.filter(c => c.type !== NodeTypes.COMMENT)\n      }\n      processChildren(node, context)\n    }\n  } else {\n    // finish up slot function expressions from the 1st pass.\n    const wipEntries = wipMap.get(node) || []\n    for (let i = 0; i < wipEntries.length; i++) {\n      const { fn, vnodeBranch } = wipEntries[i]\n      // For each slot, we generate two branches: one SSR-optimized branch and\n      // one normal vnode-based branch. The branches are taken based on the\n      // presence of the 2nd `_push` argument (which is only present if the slot\n      // is called by `_ssrRenderSlot`.\n      fn.body = createIfStatement(\n        createSimpleExpression(`_push`, false),\n        processChildrenAsStatement(\n          wipEntries[i],\n          context,\n          false,\n          true /* withSlotScopeId */\n        ),\n        vnodeBranch\n      )\n    }\n\n    // component is inside a slot, inherit slot scope Id\n    if (context.withSlotScopeId) {\n      node.ssrCodegenNode.arguments.push(`_scopeId`)\n    }\n\n    if (typeof component === 'string') {\n      // static component\n      context.pushStatement(\n        createCallExpression(`_push`, [node.ssrCodegenNode])\n      )\n    } else {\n      // dynamic component (`resolveDynamicComponent` call)\n      // the codegen node is a `renderVNode` call\n      context.pushStatement(node.ssrCodegenNode)\n    }\n  }\n}\n\nexport const rawOptionsMap = new WeakMap<RootNode, CompilerOptions>()\n\nconst [baseNodeTransforms, baseDirectiveTransforms] =\n  getBaseTransformPreset(true)\nconst vnodeNodeTransforms = [...baseNodeTransforms, ...DOMNodeTransforms]\nconst vnodeDirectiveTransforms = {\n  ...baseDirectiveTransforms,\n  ...DOMDirectiveTransforms\n}\n\nfunction createVNodeSlotBranch(\n  props: ExpressionNode | undefined,\n  children: TemplateChildNode[],\n  parentContext: TransformContext\n): ReturnStatement {\n  // apply a sub-transform using vnode-based transforms.\n  const rawOptions = rawOptionsMap.get(parentContext.root)!\n\n  const subOptions = {\n    ...rawOptions,\n    // overwrite with vnode-based transforms\n    nodeTransforms: [\n      ...vnodeNodeTransforms,\n      ...(rawOptions.nodeTransforms || [])\n    ],\n    directiveTransforms: {\n      ...vnodeDirectiveTransforms,\n      ...(rawOptions.directiveTransforms || {})\n    }\n  }\n\n  // wrap the children with a wrapper template for proper children treatment.\n  const wrapperNode: TemplateNode = {\n    type: NodeTypes.ELEMENT,\n    ns: Namespaces.HTML,\n    tag: 'template',\n    tagType: ElementTypes.TEMPLATE,\n    isSelfClosing: false,\n    // important: provide v-slot=\"props\" on the wrapper for proper\n    // scope analysis\n    props: [\n      {\n        type: NodeTypes.DIRECTIVE,\n        name: 'slot',\n        exp: props,\n        arg: undefined,\n        modifiers: [],\n        loc: locStub\n      }\n    ],\n    children,\n    loc: locStub,\n    codegenNode: undefined\n  }\n  subTransform(wrapperNode, subOptions, parentContext)\n  return createReturnStatement(children)\n}\n\nfunction subTransform(\n  node: TemplateChildNode,\n  options: TransformOptions,\n  parentContext: TransformContext\n) {\n  const childRoot = createRoot([node])\n  const childContext = createTransformContext(childRoot, options)\n  // this sub transform is for vnode fallback branch so it should be handled\n  // like normal render functions\n  childContext.ssr = false\n  // inherit parent scope analysis state\n  childContext.scopes = { ...parentContext.scopes }\n  childContext.identifiers = { ...parentContext.identifiers }\n  childContext.imports = parentContext.imports\n  // traverse\n  traverseNode(childRoot, childContext)\n  // merge helpers/components/directives into parent context\n  ;(['helpers', 'components', 'directives'] as const).forEach(key => {\n    childContext[key].forEach((value: any, helperKey: any) => {\n      if (key === 'helpers') {\n        const parentCount = parentContext.helpers.get(helperKey)\n        if (parentCount === undefined) {\n          parentContext.helpers.set(helperKey, value)\n        } else {\n          parentContext.helpers.set(helperKey, value + parentCount)\n        }\n      } else {\n        ;(parentContext[key] as any).add(value)\n      }\n    })\n  })\n  // imports/hoists are not merged because:\n  // - imports are only used for asset urls and should be consistent between\n  //   node/client branches\n  // - hoists are not enabled for the client branch here\n}\n\nfunction clone(v: any): any {\n  if (isArray(v)) {\n    return v.map(clone)\n  } else if (isObject(v)) {\n    const res: any = {}\n    for (const key in v) {\n      res[key] = clone(v[key])\n    }\n    return res\n  } else {\n    return v\n  }\n}\n","import {\n  RootNode,\n  BlockStatement,\n  TemplateLiteral,\n  createCallExpression,\n  createTemplateLiteral,\n  NodeTypes,\n  TemplateChildNode,\n  ElementTypes,\n  createBlockStatement,\n  CompilerOptions,\n  IfStatement,\n  CallExpression,\n  isText,\n  processExpression,\n  createSimpleExpression,\n  createCompoundExpression,\n  createTransformContext,\n  createRoot\n} from '@vue/compiler-dom'\nimport { isString, escapeHtml } from '@vue/shared'\nimport { SSR_INTERPOLATE, ssrHelpers } from './runtimeHelpers'\nimport { ssrProcessIf } from './transforms/ssrVIf'\nimport { ssrProcessFor } from './transforms/ssrVFor'\nimport { ssrProcessSlotOutlet } from './transforms/ssrTransformSlotOutlet'\nimport { ssrProcessComponent } from './transforms/ssrTransformComponent'\nimport { ssrProcessElement } from './transforms/ssrTransformElement'\nimport { createSSRCompilerError, SSRErrorCodes } from './errors'\n\n// Because SSR codegen output is completely different from client-side output\n// (e.g. multiple elements can be concatenated into a single template literal\n// instead of each getting a corresponding call), we need to apply an extra\n// transform pass to convert the template AST into a fresh JS AST before\n// passing it to codegen.\n\nexport function ssrCodegenTransform(ast: RootNode, options: CompilerOptions) {\n  const context = createSSRTransformContext(ast, options)\n\n  // inject SFC <style> CSS variables\n  // we do this instead of inlining the expression to ensure the vars are\n  // only resolved once per render\n  if (options.ssrCssVars) {\n    const varsExp = processExpression(\n      createSimpleExpression(options.ssrCssVars, false),\n      createTransformContext(createRoot([]), options)\n    )\n    context.body.push(\n      createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`])\n    )\n  }\n\n  const isFragment =\n    ast.children.length > 1 && ast.children.some(c => !isText(c))\n  processChildren(ast, context, isFragment)\n  ast.codegenNode = createBlockStatement(context.body)\n\n  // Finalize helpers.\n  // We need to separate helpers imported from 'vue' vs. '@vue/server-renderer'\n  ast.ssrHelpers = Array.from(\n    new Set([...ast.helpers.filter(h => h in ssrHelpers), ...context.helpers])\n  )\n\n  ast.helpers = ast.helpers.filter(h => !(h in ssrHelpers))\n}\n\nexport type SSRTransformContext = ReturnType<typeof createSSRTransformContext>\n\nfunction createSSRTransformContext(\n  root: RootNode,\n  options: CompilerOptions,\n  helpers: Set<symbol> = new Set(),\n  withSlotScopeId = false\n) {\n  const body: BlockStatement['body'] = []\n  let currentString: TemplateLiteral | null = null\n\n  return {\n    root,\n    options,\n    body,\n    helpers,\n    withSlotScopeId,\n    onError:\n      options.onError ||\n      (e => {\n        throw e\n      }),\n    helper<T extends symbol>(name: T): T {\n      helpers.add(name)\n      return name\n    },\n    pushStringPart(part: TemplateLiteral['elements'][0]) {\n      if (!currentString) {\n        const currentCall = createCallExpression(`_push`)\n        body.push(currentCall)\n        currentString = createTemplateLiteral([])\n        currentCall.arguments.push(currentString)\n      }\n      const bufferedElements = currentString.elements\n      const lastItem = bufferedElements[bufferedElements.length - 1]\n      if (isString(part) && isString(lastItem)) {\n        bufferedElements[bufferedElements.length - 1] += part\n      } else {\n        bufferedElements.push(part)\n      }\n    },\n    pushStatement(statement: IfStatement | CallExpression) {\n      // close current string\n      currentString = null\n      body.push(statement)\n    }\n  }\n}\n\nfunction createChildContext(\n  parent: SSRTransformContext,\n  withSlotScopeId = parent.withSlotScopeId\n): SSRTransformContext {\n  // ensure child inherits parent helpers\n  return createSSRTransformContext(\n    parent.root,\n    parent.options,\n    parent.helpers,\n    withSlotScopeId\n  )\n}\n\ninterface Container {\n  children: TemplateChildNode[]\n}\n\nexport function processChildren(\n  parent: Container,\n  context: SSRTransformContext,\n  asFragment = false,\n  disableNestedFragments = false\n) {\n  if (asFragment) {\n    context.pushStringPart(`<!--[-->`)\n  }\n  const { children } = parent\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    switch (child.type) {\n      case NodeTypes.ELEMENT:\n        switch (child.tagType) {\n          case ElementTypes.ELEMENT:\n            ssrProcessElement(child, context)\n            break\n          case ElementTypes.COMPONENT:\n            ssrProcessComponent(child, context, parent)\n            break\n          case ElementTypes.SLOT:\n            ssrProcessSlotOutlet(child, context)\n            break\n          case ElementTypes.TEMPLATE:\n            // TODO\n            break\n          default:\n            context.onError(\n              createSSRCompilerError(\n                SSRErrorCodes.X_SSR_INVALID_AST_NODE,\n                (child as any).loc\n              )\n            )\n            // make sure we exhaust all possible types\n            const exhaustiveCheck: never = child\n            return exhaustiveCheck\n        }\n        break\n      case NodeTypes.TEXT:\n        context.pushStringPart(escapeHtml(child.content))\n        break\n      case NodeTypes.COMMENT:\n        // no need to escape comment here because the AST can only\n        // contain valid comments.\n        context.pushStringPart(`<!--${child.content}-->`)\n        break\n      case NodeTypes.INTERPOLATION:\n        context.pushStringPart(\n          createCallExpression(context.helper(SSR_INTERPOLATE), [child.content])\n        )\n        break\n      case NodeTypes.IF:\n        ssrProcessIf(child, context, disableNestedFragments)\n        break\n      case NodeTypes.FOR:\n        ssrProcessFor(child, context, disableNestedFragments)\n        break\n      case NodeTypes.IF_BRANCH:\n        // no-op - handled by ssrProcessIf\n        break\n      case NodeTypes.TEXT_CALL:\n      case NodeTypes.COMPOUND_EXPRESSION:\n        // no-op - these two types can never appear as template child node since\n        // `transformText` is not used during SSR compile.\n        break\n      default:\n        context.onError(\n          createSSRCompilerError(\n            SSRErrorCodes.X_SSR_INVALID_AST_NODE,\n            (child as any).loc\n          )\n        )\n        // make sure we exhaust all possible types\n        const exhaustiveCheck: never = child\n        return exhaustiveCheck\n    }\n  }\n  if (asFragment) {\n    context.pushStringPart(`<!--]-->`)\n  }\n}\n\nexport function processChildrenAsStatement(\n  parent: Container,\n  parentContext: SSRTransformContext,\n  asFragment = false,\n  withSlotScopeId = parentContext.withSlotScopeId\n): BlockStatement {\n  const childContext = createChildContext(parentContext, withSlotScopeId)\n  processChildren(parent, childContext, asFragment)\n  return createBlockStatement(childContext.body)\n}\n","import {\n  DirectiveTransform,\n  ElementTypes,\n  transformModel,\n  findProp,\n  NodeTypes,\n  createDOMCompilerError,\n  DOMErrorCodes,\n  createObjectProperty,\n  createSimpleExpression,\n  createCallExpression,\n  PlainElementNode,\n  ExpressionNode,\n  createConditionalExpression,\n  createInterpolation,\n  hasDynamicKeyVBind\n} from '@vue/compiler-dom'\nimport {\n  SSR_LOOSE_EQUAL,\n  SSR_LOOSE_CONTAIN,\n  SSR_RENDER_DYNAMIC_MODEL\n} from '../runtimeHelpers'\nimport { DirectiveTransformResult } from 'packages/compiler-core/src/transform'\n\nexport const ssrTransformModel: DirectiveTransform = (dir, node, context) => {\n  const model = dir.exp!\n\n  function checkDuplicatedValue() {\n    const value = findProp(node, 'value')\n    if (value) {\n      context.onError(\n        createDOMCompilerError(\n          DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE,\n          value.loc\n        )\n      )\n    }\n  }\n\n  if (node.tagType === ElementTypes.ELEMENT) {\n    const res: DirectiveTransformResult = { props: [] }\n    const defaultProps = [\n      // default value binding for text type inputs\n      createObjectProperty(`value`, model)\n    ]\n    if (node.tag === 'input') {\n      const type = findProp(node, 'type')\n      if (type) {\n        const value = findValueBinding(node)\n        if (type.type === NodeTypes.DIRECTIVE) {\n          // dynamic type\n          res.ssrTagParts = [\n            createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [\n              type.exp!,\n              model,\n              value\n            ])\n          ]\n        } else if (type.value) {\n          // static type\n          switch (type.value.content) {\n            case 'radio':\n              res.props = [\n                createObjectProperty(\n                  `checked`,\n                  createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\n                    model,\n                    value\n                  ])\n                )\n              ]\n              break\n            case 'checkbox':\n              const trueValueBinding = findProp(node, 'true-value')\n              if (trueValueBinding) {\n                const trueValue =\n                  trueValueBinding.type === NodeTypes.ATTRIBUTE\n                    ? JSON.stringify(trueValueBinding.value!.content)\n                    : trueValueBinding.exp!\n                res.props = [\n                  createObjectProperty(\n                    `checked`,\n                    createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\n                      model,\n                      trueValue\n                    ])\n                  )\n                ]\n              } else {\n                res.props = [\n                  createObjectProperty(\n                    `checked`,\n                    createConditionalExpression(\n                      createCallExpression(`Array.isArray`, [model]),\n                      createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [\n                        model,\n                        value\n                      ]),\n                      model\n                    )\n                  )\n                ]\n              }\n              break\n            case 'file':\n              context.onError(\n                createDOMCompilerError(\n                  DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\n                  dir.loc\n                )\n              )\n              break\n            default:\n              checkDuplicatedValue()\n              res.props = defaultProps\n              break\n          }\n        }\n      } else if (hasDynamicKeyVBind(node)) {\n        // dynamic type due to dynamic v-bind\n        // NOOP, handled in ssrTransformElement due to need to rewrite\n        // the entire props expression\n      } else {\n        // text type\n        checkDuplicatedValue()\n        res.props = defaultProps\n      }\n    } else if (node.tag === 'textarea') {\n      checkDuplicatedValue()\n      node.children = [createInterpolation(model, model.loc)]\n    } else if (node.tag === 'select') {\n      // NOOP\n      // select relies on client-side directive to set initial selected state.\n    } else {\n      context.onError(\n        createDOMCompilerError(\n          DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\n          dir.loc\n        )\n      )\n    }\n\n    return res\n  } else {\n    // component v-model\n    return transformModel(dir, node, context)\n  }\n}\n\nfunction findValueBinding(node: PlainElementNode): ExpressionNode {\n  const valueBinding = findProp(node, 'value')\n  return valueBinding\n    ? valueBinding.type === NodeTypes.DIRECTIVE\n      ? valueBinding.exp!\n      : createSimpleExpression(valueBinding.value!.content, true)\n    : createSimpleExpression(`null`, false)\n}\n","import {\n  DirectiveTransform,\n  DOMErrorCodes,\n  createObjectProperty,\n  createSimpleExpression,\n  createConditionalExpression,\n  createObjectExpression,\n  createDOMCompilerError\n} from '@vue/compiler-dom'\n\nexport const ssrTransformShow: DirectiveTransform = (dir, node, context) => {\n  if (!dir.exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION)\n    )\n  }\n  return {\n    props: [\n      createObjectProperty(\n        `style`,\n        createConditionalExpression(\n          dir.exp!,\n          createSimpleExpression(`null`, false),\n          createObjectExpression([\n            createObjectProperty(\n              `display`,\n              createSimpleExpression(`none`, true)\n            )\n          ]),\n          false /* no newline */\n        )\n      )\n    ]\n  }\n}\n","import {\n  NodeTransform,\n  NodeTypes,\n  ElementTypes,\n  locStub,\n  createSimpleExpression,\n  RootNode,\n  TemplateChildNode,\n  ParentNode,\n  findDir,\n  isBuiltInType\n} from '@vue/compiler-dom'\n\nconst filterChild = (node: ParentNode) =>\n  node.children.filter(n => n.type !== NodeTypes.COMMENT)\n\nconst hasSingleChild = (node: ParentNode): boolean =>\n  filterChild(node).length === 1\n\nexport const ssrInjectFallthroughAttrs: NodeTransform = (node, context) => {\n  // _attrs is provided as a function argument.\n  // mark it as a known identifier so that it doesn't get prefixed by\n  // transformExpression.\n  if (node.type === NodeTypes.ROOT) {\n    context.identifiers._attrs = 1\n  }\n\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    node.tagType === ElementTypes.COMPONENT &&\n    (isBuiltInType(node.tag, 'Transition') ||\n      isBuiltInType(node.tag, 'KeepAlive'))\n  ) {\n    const rootChildren = filterChild(context.root)\n    if (rootChildren.length === 1 && rootChildren[0] === node) {\n      if (hasSingleChild(node)) {\n        injectFallthroughAttrs(node.children[0])\n      }\n      return\n    }\n  }\n\n  const parent = context.parent\n  if (!parent || parent.type !== NodeTypes.ROOT) {\n    return\n  }\n\n  if (node.type === NodeTypes.IF_BRANCH && hasSingleChild(node)) {\n    // detect cases where the parent v-if is not the only root level node\n    let hasEncounteredIf = false\n    for (const c of filterChild(parent)) {\n      if (\n        c.type === NodeTypes.IF ||\n        (c.type === NodeTypes.ELEMENT && findDir(c, 'if'))\n      ) {\n        // multiple root v-if\n        if (hasEncounteredIf) return\n        hasEncounteredIf = true\n      } else if (\n        // node before v-if\n        !hasEncounteredIf ||\n        // non else nodes\n        !(c.type === NodeTypes.ELEMENT && findDir(c, /else/, true))\n      ) {\n        return\n      }\n    }\n    injectFallthroughAttrs(node.children[0])\n  } else if (hasSingleChild(parent)) {\n    injectFallthroughAttrs(node)\n  }\n}\n\nfunction injectFallthroughAttrs(node: RootNode | TemplateChildNode) {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    (node.tagType === ElementTypes.ELEMENT ||\n      node.tagType === ElementTypes.COMPONENT) &&\n    !findDir(node, 'for')\n  ) {\n    node.props.push({\n      type: NodeTypes.DIRECTIVE,\n      name: 'bind',\n      arg: undefined,\n      exp: createSimpleExpression(`_attrs`, false),\n      modifiers: [],\n      loc: locStub\n    })\n  }\n}\n","import {\n  NodeTransform,\n  NodeTypes,\n  ElementTypes,\n  locStub,\n  createSimpleExpression,\n  RootNode,\n  TemplateChildNode,\n  findDir,\n  isBuiltInType\n} from '@vue/compiler-dom'\n\nexport const ssrInjectCssVars: NodeTransform = (node, context) => {\n  if (!context.ssrCssVars) {\n    return\n  }\n\n  // _cssVars is initialized once per render function\n  // the code is injected in ssrCodegenTransform when creating the\n  // ssr transform context\n  if (node.type === NodeTypes.ROOT) {\n    context.identifiers._cssVars = 1\n  }\n\n  const parent = context.parent\n  if (!parent || parent.type !== NodeTypes.ROOT) {\n    return\n  }\n\n  if (node.type === NodeTypes.IF_BRANCH) {\n    for (const child of node.children) {\n      injectCssVars(child)\n    }\n  } else {\n    injectCssVars(node)\n  }\n}\n\nfunction injectCssVars(node: RootNode | TemplateChildNode) {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    (node.tagType === ElementTypes.ELEMENT ||\n      node.tagType === ElementTypes.COMPONENT) &&\n    !findDir(node, 'for')\n  ) {\n    if (isBuiltInType(node.tag, 'Suspense')) {\n      for (const child of node.children) {\n        if (\n          child.type === NodeTypes.ELEMENT &&\n          child.tagType === ElementTypes.TEMPLATE\n        ) {\n          // suspense slot\n          child.children.forEach(injectCssVars)\n        } else {\n          injectCssVars(child)\n        }\n      }\n    } else {\n      node.props.push({\n        type: NodeTypes.DIRECTIVE,\n        name: 'bind',\n        arg: undefined,\n        exp: createSimpleExpression(`_cssVars`, false),\n        modifiers: [],\n        loc: locStub\n      })\n    }\n  }\n}\n","import {\n  CodegenResult,\n  baseParse,\n  parserOptions,\n  transform,\n  generate,\n  CompilerOptions,\n  transformExpression,\n  trackVForSlotScopes,\n  trackSlotScopes,\n  noopDirectiveTransform,\n  transformBind,\n  transformStyle,\n  transformOn\n} from '@vue/compiler-dom'\nimport { ssrCodegenTransform } from './ssrCodegenTransform'\nimport { ssrTransformElement } from './transforms/ssrTransformElement'\nimport {\n  ssrTransformComponent,\n  rawOptionsMap\n} from './transforms/ssrTransformComponent'\nimport { ssrTransformSlotOutlet } from './transforms/ssrTransformSlotOutlet'\nimport { ssrTransformIf } from './transforms/ssrVIf'\nimport { ssrTransformFor } from './transforms/ssrVFor'\nimport { ssrTransformModel } from './transforms/ssrVModel'\nimport { ssrTransformShow } from './transforms/ssrVShow'\nimport { ssrInjectFallthroughAttrs } from './transforms/ssrInjectFallthroughAttrs'\nimport { ssrInjectCssVars } from './transforms/ssrInjectCssVars'\n\nexport function compile(\n  template: string,\n  options: CompilerOptions = {}\n): CodegenResult {\n  options = {\n    ...options,\n    // apply DOM-specific parsing options\n    ...parserOptions,\n    ssr: true,\n    inSSR: true,\n    scopeId: options.mode === 'function' ? null : options.scopeId,\n    // always prefix since compiler-ssr doesn't have size concern\n    prefixIdentifiers: true,\n    // disable optimizations that are unnecessary for ssr\n    cacheHandlers: false,\n    hoistStatic: false\n  }\n\n  const ast = baseParse(template, options)\n\n  // Save raw options for AST. This is needed when performing sub-transforms\n  // on slot vnode branches.\n  rawOptionsMap.set(ast, options)\n\n  transform(ast, {\n    ...options,\n    hoistStatic: false,\n    nodeTransforms: [\n      ssrTransformIf,\n      ssrTransformFor,\n      trackVForSlotScopes,\n      transformExpression,\n      ssrTransformSlotOutlet,\n      ssrInjectFallthroughAttrs,\n      ssrInjectCssVars,\n      ssrTransformElement,\n      ssrTransformComponent,\n      trackSlotScopes,\n      transformStyle,\n      ...(options.nodeTransforms || []) // user transforms\n    ],\n    directiveTransforms: {\n      // reusing core v-bind\n      bind: transformBind,\n      on: transformOn,\n      // model and show has dedicated SSR handling\n      model: ssrTransformModel,\n      show: ssrTransformShow,\n      // the following are ignored during SSR\n      // on: noopDirectiveTransform,\n      cloak: noopDirectiveTransform,\n      once: noopDirectiveTransform,\n      memo: noopDirectiveTransform,\n      ...(options.directiveTransforms || {}) // user transforms\n    }\n  })\n\n  // traverse the template AST and convert into SSR codegen AST\n  // by replacing ast.codegenNode.\n  ssrCodegenTransform(ast, options)\n\n  return generate(ast, options)\n}\n"],"names":["registerRuntimeHelpers","createStructuralDirectiveTransform","processIf","createIfStatement","createBlockStatement","createCallExpression","processFor","createFunctionExpression","createForLoopParams","isSlotOutlet","processSlotOutlet","resolveComponentType","TRANSITION","createCompilerError","findProp","createSimpleExpression","buildSlots","hasDynamicKeyVBind","isBuiltInDirective","buildProps","createAssignmentExpression","createConditionalExpression","createSequenceExpression","MERGE_PROPS","createInterpolation","isStaticExp","propsToAttrMap","isBooleanAttr","isSSRSafeAttrName","escapeHtml","createTemplateLiteral","buildDirectiveArgs","isStaticArgOf","createArrayExpression","NO","wipMap","isObject","RESOLVE_DYNAMIC_COMPONENT","isSymbol","SUSPENSE","TRANSITION_GROUP","CREATE_VNODE","TELEPORT","getBaseTransformPreset","DOMNodeTransforms","DOMDirectiveTransforms","locStub","createReturnStatement","createRoot","createTransformContext","traverseNode","isArray","processExpression","createCompoundExpression","isText","isString","createDOMCompilerError","createObjectProperty","transformModel","createObjectExpression","isBuiltInType","findDir","parserOptions","baseParse","transform","trackVForSlotScopes","transformExpression","trackSlotScopes","transformStyle","transformBind","transformOn","noopDirectiveTransform","generate"],"mappings":";;;;;;;AAEO,MAAM,eAAe,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAA;AAChD,MAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAA;AACjD,MAAM,oBAAoB,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAA;AACzD,MAAM,eAAe,GAAG,MAAM,CAAC,eAAe,CAAC,CAAA;AAC/C,MAAM,qBAAqB,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAA;AAC1D,MAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAA;AACjD,MAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAA;AACjD,MAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAA;AACjD,MAAM,eAAe,GAAG,MAAM,CAAC,eAAe,CAAC,CAAA;AAC/C,MAAM,uBAAuB,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAA;AAC9D,MAAM,eAAe,GAAG,MAAM,CAAC,eAAe,CAAC,CAAA;AAC/C,MAAM,wBAAwB,GAAG,MAAM,CAAC,uBAAuB,CAAC,CAAA;AAChE,MAAM,eAAe,GAAG,MAAM,CAAC,eAAe,CAAC,CAAA;AAC/C,MAAM,iBAAiB,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAA;AACnD,MAAM,wBAAwB,GAAG,MAAM,CAAC,uBAAuB,CAAC,CAAA;AAChE,MAAM,2BAA2B,GAAG,MAAM,CAAC,yBAAyB,CAAC,CAAA;AACrE,MAAM,mBAAmB,GAAG,MAAM,CAAC,mBAAmB,CAAC,CAAA;AACvD,MAAM,mBAAmB,GAAG,MAAM,CAAC,mBAAmB,CAAC,CAAA;AACvD,MAAM,uBAAuB,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAA;AAE9D,MAAM,UAAU,GAAG;IACxB,CAAC,eAAe,GAAG,gBAAgB;IACnC,CAAC,gBAAgB,GAAG,gBAAgB;IACpC,CAAC,oBAAoB,GAAG,oBAAoB;IAC5C,CAAC,eAAe,GAAG,eAAe;IAClC,CAAC,qBAAqB,GAAG,oBAAoB;IAC7C,CAAC,gBAAgB,GAAG,gBAAgB;IACpC,CAAC,gBAAgB,GAAG,gBAAgB;IACpC,CAAC,gBAAgB,GAAG,gBAAgB;IACpC,CAAC,eAAe,GAAG,eAAe;IAClC,CAAC,uBAAuB,GAAG,sBAAsB;IACjD,CAAC,eAAe,GAAG,eAAe;IAClC,CAAC,wBAAwB,GAAG,uBAAuB;IACnD,CAAC,eAAe,GAAG,eAAe;IAClC,CAAC,iBAAiB,GAAG,iBAAiB;IACtC,CAAC,wBAAwB,GAAG,uBAAuB;IACnD,CAAC,2BAA2B,GAAG,yBAAyB;IACxD,CAAC,mBAAmB,GAAG,mBAAmB;IAC1C,CAAC,mBAAmB,GAAG,mBAAmB;IAC1C,CAAC,uBAAuB,GAAG,sBAAsB;CAClD,CAAA;AAED;AACA;AACAA,kCAAsB,CAAC,UAAU,CAAC;;AC9BlC;AACO,MAAM,cAAc,GAAGC,8CAAkC,CAC9D,qBAAqB,EACrBC,qBAAS,CACV,CAAA;AAED;AACA;SACgB,YAAY,CAC1B,IAAY,EACZ,OAA4B,EAC5B,sBAAsB,GAAG,KAAK;IAE9B,MAAM,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAA;IAClC,MAAM,WAAW,GAAGC,6BAAiB,CACnC,UAAU,CAAC,SAAU,EACrB,eAAe,CAAC,UAAU,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAC7D,CAAA;IACD,OAAO,CAAC,aAAa,CAAC,WAAW,CAAC,CAAA;IAElC,IAAI,SAAS,GAAG,WAAW,CAAA;IAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC7C,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;QAC/B,MAAM,oBAAoB,GAAG,eAAe,CAC1C,MAAM,EACN,OAAO,EACP,sBAAsB,CACvB,CAAA;QACD,IAAI,MAAM,CAAC,SAAS,EAAE;;YAEpB,SAAS,GAAG,SAAS,CAAC,SAAS,GAAGA,6BAAiB,CACjD,MAAM,CAAC,SAAS,EAChB,oBAAoB,CACrB,CAAA;SACF;aAAM;;YAEL,SAAS,CAAC,SAAS,GAAG,oBAAoB,CAAA;SAC3C;KACF;IAED,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE;QACxB,SAAS,CAAC,SAAS,GAAGC,gCAAoB,CAAC;YACzCC,gCAAoB,CAAC,OAAO,EAAE,CAAC,WAAW,CAAC,CAAC;SAC7C,CAAC,CAAA;KACH;AACH,CAAC;AAED,SAAS,eAAe,CACtB,MAAoB,EACpB,OAA4B,EAC5B,sBAAsB,GAAG,KAAK;IAE9B,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,CAAA;IAC3B,MAAM,mBAAmB,GACvB,CAAC,sBAAsB;SACtB,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,+BAAuB;;QAEjE,EAAE,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,4BAAmB,CAAA;IAChE,OAAO,0BAA0B,CAAC,MAAM,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAA;AACzE;;AC5DA;AACO,MAAM,eAAe,GAAGJ,8CAAkC,CAC/D,KAAK,EACLK,sBAAU,CACX,CAAA;AAED;AACA;SACgB,aAAa,CAC3B,IAAa,EACb,OAA4B,EAC5B,sBAAsB,GAAG,KAAK;IAE9B,MAAM,mBAAmB,GACvB,CAAC,sBAAsB;SACtB,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,+BAAuB,CAAA;IAC7E,MAAM,UAAU,GAAGC,oCAAwB,CACzCC,+BAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CACtC,CAAA;IACD,UAAU,CAAC,IAAI,GAAG,0BAA0B,CAC1C,IAAI,EACJ,OAAO,EACP,mBAAmB,CACpB,CAAA;;IAED,IAAI,CAAC,sBAAsB,EAAE;QAC3B,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAA;KACnC;IACD,OAAO,CAAC,aAAa,CACnBH,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE;QACpD,IAAI,CAAC,MAAM;QACX,UAAU;KACX,CAAC,CACH,CAAA;IACD,IAAI,CAAC,sBAAsB,EAAE;QAC3B,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAA;KACnC;AACH;;AClCO,MAAM,sBAAsB,GAAkB,CAAC,IAAI,EAAE,OAAO;IACjE,IAAII,wBAAY,CAAC,IAAI,CAAC,EAAE;QACtB,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAGC,6BAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;QAEhE,MAAM,IAAI,GAAG;YACX,aAAa;YACb,QAAQ;YACR,SAAS,IAAI,IAAI;;YAEjB,MAAM;YACN,OAAO;YACP,SAAS;SACV,CAAA;;QAGD,IAAI,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,KAAK,KAAK,EAAE;YAChD,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,OAAO,KAAK,CAAC,CAAA;SACpC;QAED,IAAI,MAAM,GAAG,eAAe,CAAA;;;;;QAM5B,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAA;QAC7B,IACE,MAAM;YACN,MAAM,CAAC,IAAI;YACX,MAAM,CAAC,OAAO;YACdC,gCAAoB,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,KAAKC,sBAAU;YAC1D,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,+BAAuB,CAAC,MAAM,KAAK,CAAC,EACtE;YACA,MAAM,GAAG,qBAAqB,CAAA;YAC9B,IAAI,EAAE,OAAO,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,KAAK,KAAK,CAAC,EAAE;gBACnD,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;aAClB;YACD,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;SAClB;QAED,IAAI,CAAC,cAAc,GAAGP,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,CAAA;KACzE;AACH,CAAC,CAAA;SAEe,oBAAoB,CAClC,IAAoB,EACpB,OAA4B;IAE5B,MAAM,UAAU,GAAG,IAAI,CAAC,cAAe,CAAA;;IAGvC,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;QACxB,MAAM,gBAAgB,GAAGE,oCAAwB,CAAC,EAAE,CAAC,CAAA;QACrD,gBAAgB,CAAC,IAAI,GAAG,0BAA0B,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;;QAEjE,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,gBAAgB,CAAA;KAC3C;;IAGD,IAAI,OAAO,CAAC,eAAe,EAAE;QAC3B,MAAM,WAAW,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;QAC3C,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,WAAW;cACjC,GAAG,WAAqB,aAAa;cACrC,UAAU,CAAA;KACf;IAED,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,cAAe,CAAC,CAAA;AAC7C;;SC1EgB,sBAAsB,CACpC,IAAmB,EACnB,GAAoB;IAEpB,OAAOM,+BAAmB,CAAC,IAAI,EAAE,GAAG,EAAE,gBAAgB,CAAqB,CAAA;AAC7E,CAAC;AAQM,MAAM,gBAAgB,GAA+B;IAC1D,iDAAwC,gCAAgC;IACxE,mDAA0C,4CAA4C;IACtF,iDAAwC,wCAAwC;CACjF;;ACZD;SACgB,kBAAkB,CAChC,IAAmB,EACnB,OAA4B;IAE5B,MAAM,UAAU,GAAGC,oBAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;IACvC,IAAI,CAAC,UAAU,EAAE;QACf,OAAO,CAAC,OAAO,CACb,sBAAsB,kDAAyC,IAAI,CAAC,GAAG,CAAC,CACzE,CAAA;QACD,OAAM;KACP;IAED,IAAI,MAAkC,CAAA;IACtC,IAAI,UAAU,CAAC,IAAI,kCAA0B;QAC3C,MAAM;YACJ,UAAU,CAAC,KAAK,IAAIC,kCAAsB,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAA;KAC7E;SAAM;QACL,MAAM,GAAG,UAAU,CAAC,GAAG,CAAA;KACxB;IACD,IAAI,CAAC,MAAM,EAAE;QACX,OAAO,CAAC,OAAO,CACb,sBAAsB,kDAEpB,UAAU,CAAC,GAAG,CACf,CACF,CAAA;QACD,OAAM;KACP;IAED,MAAM,YAAY,GAAGD,oBAAQ,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,IAAI,mBAAmB,CAAA;IAC9E,MAAM,QAAQ,GAAG,YAAY;UACzB,YAAY,CAAC,IAAI;cACf,MAAM;cACN,YAAY,CAAC,GAAG,IAAI,OAAO;UAC7B,OAAO,CAAA;IAEX,MAAM,eAAe,GAAGP,oCAAwB,CAC9C,CAAC,OAAO,CAAC,EACT,SAAS;IACT,IAAI;IACJ,KAAK;IACL,IAAI,CAAC,GAAG,CACT,CAAA;IACD,eAAe,CAAC,IAAI,GAAG,0BAA0B,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;IAChE,OAAO,CAAC,aAAa,CACnBF,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,mBAAmB,CAAC,EAAE;QACxD,OAAO;QACP,eAAe;QACf,MAAM;QACN,QAAQ;QACR,SAAS;KACV,CAAC,CACH,CAAA;AACH;;ACtDA,MAAM,MAAM,GAAG,IAAI,OAAO,EAA2B,CAAA;AAUrD;SACgB,oBAAoB,CAClC,IAAmB,EACnB,OAAyB;IAEzB,OAAO;QACL,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YACxB,MAAM,QAAQ,GAAa;gBACzB,QAAQ,EAAE,IAAK;gBACf,QAAQ,EAAE,EAAE;aACb,CAAA;YACD,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;YAC1B,QAAQ,CAAC,QAAQ,GAAGW,sBAAU,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,MAAM,EAAE,QAAQ,EAAE,GAAG;gBAClE,MAAM,EAAE,GAAGT,oCAAwB,CACjC,EAAE,EACF,SAAS;gBACT,IAAI;gBACJ,KAAK;gBACL,GAAG,CACJ,CAAA;gBACD,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC;oBACrB,EAAE;oBACF,QAAQ;iBACT,CAAC,CAAA;gBACF,OAAO,EAAE,CAAA;aACV,CAAC,CAAC,KAAK,CAAA;SACT;KACF,CAAA;AACH,CAAC;AAED;SACgB,kBAAkB,CAChC,IAAmB,EACnB,OAA4B;;IAG5B,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IACjC,IAAI,CAAC,QAAQ,EAAE;QACb,OAAM;KACP;IACD,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,QAAQ,CAAA;IACvC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACxC,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;QACxB,IAAI,CAAC,EAAE,CAAC,IAAI,GAAG,0BAA0B,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;KACzD;;IAED,OAAO,CAAC,aAAa,CACnBF,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,mBAAmB,CAAC,EAAE;QACxD,OAAO;QACP,QAAQ;KACT,CAAC,CACH,CAAA;AACH;;ACvBA;AACA;AACA,MAAM,cAAc,GAAG,IAAI,OAAO,EAG/B,CAAA;AAEI,MAAM,mBAAmB,GAAkB,CAAC,IAAI,EAAE,OAAO;IAC9D,IACE,IAAI,CAAC,IAAI;QACT,IAAI,CAAC,OAAO,mCACZ;QACA,OAAM;KACP;IAED,OAAO,SAAS,uBAAuB;;;QAGrC,MAAM,OAAO,GAAgC,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE,CAAC,CAAA;;QAE7D,MAAM,iBAAiB,GACrB,IAAI,CAAC,GAAG,KAAK,UAAU,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;;;;QAKtD,MAAM,eAAe,GAAGY,8BAAkB,CAAC,IAAI,CAAC,CAAA;QAChD,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAClC,CAAC,IAAI,CAAC,CAAC,IAAI,oCAA4B,CAACC,yBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CACnE,CAAA;QACD,MAAM,cAAc,GAAG,eAAe,IAAI,YAAY,CAAA;QACtD,IAAI,cAAc,EAAE;YAClB,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,GAAGC,sBAAU,CACtC,IAAI,EACJ,OAAO,EACP,IAAI,CAAC,KAAK,EACV,KAAK,oBACL,KAAK,2BACL,IAAI,WACL,CAAA;YACD,IAAI,KAAK,IAAI,UAAU,CAAC,MAAM,EAAE;gBAC9B,MAAM,WAAW,GAAG,aAAa,CAAC,KAAK,EAAE,UAAU,EAAE,OAAO,CAAC,CAAA;gBAC7D,MAAM,QAAQ,GAAGd,gCAAoB,CACnC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAChC,CAAC,WAAW,CAAC,CACd,CAAA;gBAED,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;oBAC3B,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAGvB,CAAA;;;oBAGb,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,IAAI,sCAA8B;;;;;wBAKlE,MAAM,MAAM,GAAG,QAAQ,OAAO,CAAC,KAAK,EAAE,EAAE,CAAA;wBACxC,QAAQ,CAAC,SAAS,GAAG;4BACnBe,sCAA0B,CACxBL,kCAAsB,CAAC,MAAM,EAAE,KAAK,CAAC,EACrC,WAAW,CACZ;yBACF,CAAA;wBACD,cAAc,CAAC,GAAG,CAChB,IAAI,EACJV,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE;4BACpDgB,uCAA2B,CACzBN,kCAAsB,CAAC,cAAc,MAAM,EAAE,EAAE,KAAK,CAAC,EACrDA,kCAAsB,CAAC,GAAG,MAAM,QAAQ,EAAE,KAAK,CAAC,EAChDA,kCAAsB,CACpB,YAAY,GAAG,YAAY,CAAC,OAAO,GAAG,EAAE,EACxC,IAAI,CACL,EACD,KAAK,CACN;yBACF,CAAC,CACH,CAAA;qBACF;iBACF;qBAAM,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,EAAE;;;;oBAI/B,MAAM,MAAM,GAAG,UAAU,CAAC,IAAI,CAAC,CAAA;oBAC/B,IAAI,MAAM,EAAE;;wBAEV,MAAM,MAAM,GAAG,QAAQ,OAAO,CAAC,KAAK,EAAE,EAAE,CAAA;wBACxC,MAAM,OAAO,GAAGA,kCAAsB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;wBACrD,QAAQ,CAAC,SAAS,GAAG;4BACnBO,oCAAwB,CAAC;gCACvBF,sCAA0B,CAAC,OAAO,EAAE,WAAW,CAAC;gCAChDf,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAACkB,uBAAW,CAAC,EAAE;oCAChD,OAAO;oCACPlB,gCAAoB,CAClB,OAAO,CAAC,MAAM,CAAC,2BAA2B,CAAC,EAC3C;wCACE,OAAO;wCACP,MAAM,CAAC,GAAI;qCACZ,CACF;iCACF,CAAC;6BACH,CAAC;yBACH,CAAA;qBACF;iBACF;gBAED,IAAI,iBAAiB,EAAE;oBACrB,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,CAAA;iBACzC;gBAED,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;aACvB;SACF;;QAGD,IAAI,mBAAmB,GAA+B,SAAS,CAAA;QAC/D,IAAI,kBAAkB,GAAuB,SAAS,CAAA;;;QAGtD,IAAI,mBAAmB,GAA+B,SAAS,CAAA;QAE/D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1C,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;;YAE1B,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;gBAClD,SAAQ;aACT;;YAED,IAAI,IAAI,CAAC,IAAI,kCAA0B;gBACrC,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,IAAI,IAAI,CAAC,GAAG,EAAE;oBACpC,cAAc,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,CAAA;iBACnC;qBAAM,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,IAAI,IAAI,CAAC,GAAG,EAAE;oBAC3C,IAAI,CAAC,QAAQ,GAAG,CAACmB,+BAAmB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA;iBAC1D;qBAAM,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,EAAE;oBAC/B,OAAO,CAAC,OAAO,CACbX,+BAAmB,yCAAgC,IAAI,CAAC,GAAG,CAAC,CAC7D,CAAA;iBACF;qBAAM,IAAI,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;oBACtD,IAAI,CAAC,cAAc,EAAE;wBACnB,IAAI,CAAC,QAAQ,GAAG,CAACW,+BAAmB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA;qBAC1D;iBACF;qBAAM,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;;oBAEhD,MAAM,kBAAkB,GAAG,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;oBACjE,IAAI,kBAAkB,EAAE;wBACtB,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,kBAAkB,CAC/C,IAAI,EACJ,IAAI,EACJ,OAAO,CACR,CAAA;wBACD,IAAI,WAAW,EAAE;4BACf,OAAO,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,CAAA;yBAC7B;wBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BACrC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,KAAK,CAAC,CAAC,CAAC,CAAA;4BAC/B,IAAIC,uBAAW,CAAC,GAAG,CAAC,EAAE;gCACpB,IAAI,QAAQ,GAAG,GAAG,CAAC,OAAO,CAAA;;gCAE1B,IAAI,QAAQ,KAAK,KAAK,IAAI,QAAQ,KAAK,KAAK,EAAE;oCAC5C,SAAQ;iCACT;gCACD,IAAI,QAAQ,KAAK,OAAO,EAAE;oCACxB,OAAO,CAAC,IAAI,CACV,UAAU,GACT,mBAAmB,GAAGpB,gCAAoB,CACzC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAChC,CAAC,KAAK,CAAC,CACR,GACD,GAAG,CACJ,CAAA;iCACF;qCAAM,IAAI,QAAQ,KAAK,OAAO,EAAE;oCAC/B,IAAI,mBAAmB,EAAE;;wCAEvB,SAAS,CAAC,mBAAmB,EAAE,KAAK,CAAC,CAAA;qCACtC;yCAAM;wCACL,OAAO,CAAC,IAAI,CACV,UAAU,GACT,mBAAmB,GAAGA,gCAAoB,CACzC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAChC,CAAC,KAAK,CAAC,CACR,GACD,GAAG,CACJ,CAAA;qCACF;iCACF;qCAAM;oCACL,QAAQ;wCACN,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC;8CACrB,QAAQ;8CACRqB,qBAAc,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,WAAW,EAAE,CAAA;oCACxD,IAAIC,oBAAa,CAAC,QAAQ,CAAC,EAAE;wCAC3B,OAAO,CAAC,IAAI,CACVN,uCAA2B,CACzBhB,gCAAoB,CAClB,OAAO,CAAC,MAAM,CAAC,wBAAwB,CAAC,EACxC,CAAC,KAAK,CAAC,CACR,EACDU,kCAAsB,CAAC,GAAG,GAAG,QAAQ,EAAE,IAAI,CAAC,EAC5CA,kCAAsB,CAAC,EAAE,EAAE,IAAI,CAAC,EAChC,KAAK,kBACN,CACF,CAAA;qCACF;yCAAM,IAAIa,wBAAiB,CAAC,QAAQ,CAAC,EAAE;wCACtC,OAAO,CAAC,IAAI,CACVvB,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE;4CACpD,GAAG;4CACH,KAAK;yCACN,CAAC,CACH,CAAA;qCACF;yCAAM;wCACL,OAAO,CAAC,OAAO,CACb,sBAAsB,gDAEpB,GAAG,CAAC,GAAG,CACR,CACF,CAAA;qCACF;iCACF;6BACF;iCAAM;;;;gCAIL,MAAM,IAAI,GAAgC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;gCACtD,IAAI,iBAAiB,EAAE;oCACrB,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,CAAA;iCAC3B;gCACD,OAAO,CAAC,IAAI,CACVA,gCAAoB,CAClB,OAAO,CAAC,MAAM,CAAC,uBAAuB,CAAC,EACvC,IAAI,CACL,CACF,CAAA;6BACF;yBACF;qBACF;iBACF;aACF;iBAAM;;gBAEL,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,KAAK,EAAE;oBAClE,cAAc,CAAC,GAAG,CAAC,IAAI,EAAEwB,iBAAU,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAA;iBACzD;qBAAM,IAAI,CAAC,cAAc,EAAE;oBAC1B,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;wBAC9C,SAAQ;qBACT;;oBAED,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,KAAK,EAAE;wBACvC,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;qBACxD;oBACD,OAAO,CAAC,IAAI,CACV,IAAI,IAAI,CAAC,IAAI,EAAE;yBACZ,IAAI,CAAC,KAAK,GAAG,KAAKA,iBAAU,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,GAAG,EAAE,CAAC,CAC7D,CAAA;iBACF;aACF;SACF;;QAGD,IAAI,mBAAmB,IAAI,kBAAkB,EAAE;YAC7C,SAAS,CAAC,mBAAmB,EAAE,kBAAkB,CAAC,CAAA;YAClD,mBAAmB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAA;SACtC;QAED,IAAI,OAAO,CAAC,OAAO,EAAE;YACnB,OAAO,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC,CAAA;SACpC;QAED,IAAI,CAAC,cAAc,GAAGC,iCAAqB,CAAC,OAAO,CAAC,CAAA;KACrD,CAAA;AACH,CAAC,CAAA;SAEe,aAAa,CAC3B,KAAkC,EAClC,UAA2B,EAC3B,OAAyB;IAEzB,IAAI,cAAc,GAAkB,EAAE,CAAA;IACtC,IAAI,KAAK,EAAE;QACT,IAAI,KAAK,CAAC,IAAI,4CAAmC;;YAE/C,cAAc,GAAG,KAAK,CAAC,SAA0B,CAAA;SAClD;aAAM;YACL,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;SAC3B;KACF;IACD,IAAI,UAAU,CAAC,MAAM,EAAE;QACrB,KAAK,MAAM,GAAG,IAAI,UAAU,EAAE;YAC5B,cAAc,CAAC,IAAI,CACjBzB,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,uBAAuB,CAAC,EAAE;gBAC5D,MAAM;gBACN,GAAG0B,8BAAkB,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,QAAQ;aAC5B,CAAC,CACpB,CAAA;SACF;KACF;IAED,OAAO,cAAc,CAAC,MAAM,GAAG,CAAC;UAC5B1B,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAACkB,uBAAW,CAAC,EAAE,cAAc,CAAC;UACjE,cAAc,CAAC,CAAC,CAAC,CAAA;AACvB,CAAC;AAED,SAAS,gBAAgB,CAAC,IAAmC;IAC3D,IAAI,IAAI,CAAC,IAAI,kCAA0B;QACrC,QACE,IAAI,CAAC,IAAI,KAAK,MAAM;YACpB,IAAI,CAAC,GAAG;YACRE,uBAAW,CAAC,IAAI,CAAC,GAAG,CAAC;aACpB,IAAI,CAAC,GAAG,CAAC,OAAO,KAAK,YAAY,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,KAAK,aAAa,CAAC,EAC1E;KACF;SAAM;QACL,OAAO,IAAI,CAAC,IAAI,KAAK,YAAY,IAAI,IAAI,CAAC,IAAI,KAAK,aAAa,CAAA;KACjE;AACH,CAAC;AAED,SAAS,mBAAmB,CAC1B,IAAsB,EACtB,IAAmB;IAEnB,OAAO,CAAC,EACN,IAAI,CAAC,GAAG,KAAK,UAAU;QACvB,IAAI,CAAC,IAAI,KAAK,MAAM;QACpBO,yBAAa,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,CACjC,CAAA;AACH,CAAC;AAED,SAAS,SAAS,CAAC,IAAoB,EAAE,GAAyB;IAChE,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAqC,CAAA;IACtE,IAAI,QAAQ,CAAC,IAAI,6CAAoC;QACnD,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;KAC5B;SAAM;QACL,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAGC,iCAAqB,CAAC,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC,CAAA;KAC3D;AACH,CAAC;AAED,SAAS,mBAAmB,CAC1B,GAAgC,EAChC,OAAe;IAEf,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,KAAK,OAAO,QAAQ,CAAC,CAAA;IAE/C,MAAM,CAAC,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;IAErE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;QACV,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;KACjB;AACH,CAAC;AAED,SAAS,UAAU,CAAC,IAAsB;IACxC,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CACpB,CAAC,IAAI,CAAC,CAAC,IAAI,oCAA4B,CAAC,CAAC,IAAI,KAAK,OAAO,IAAI,CAAC,CAAC,GAAG,CACtC,CAAA;AAChC,CAAC;SAEe,iBAAiB,CAC/B,IAAsB,EACtB,OAA4B;IAE5B,MAAM,SAAS,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,IAAIC,SAAE,CAAA;IACjD,MAAM,aAAa,GAAG,IAAI,CAAC,cAAe,CAAC,QAAQ,CAAA;IACnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC7C,OAAO,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAA;KACzC;;IAGD,IAAI,OAAO,CAAC,eAAe,EAAE;QAC3B,OAAO,CAAC,cAAc,CAACnB,kCAAsB,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC,CAAA;KAClE;;IAGD,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;IAE3B,MAAM,WAAW,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IAC5C,IAAI,WAAW,EAAE;QACf,OAAO,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;KACpC;SAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;QAC/B,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;KAC/B;IAED,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;;QAExB,OAAO,CAAC,cAAc,CAAC,KAAK,IAAI,CAAC,GAAG,GAAG,CAAC,CAAA;KACzC;AACH;;ACtaA,MAAMoB,QAAM,GAAG,IAAI,OAAO,EAA2B,CAAA;AAOrD;SACgB,2BAA2B,CACzC,IAAmB,EACnB,OAAyB;IAEzB,OAAO;QACL,MAAM,GAAG,GAAGrB,oBAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;QACjC,IAAI,GAAG,EAAE;YACP,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAA;YACpD,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,GAAGK,sBAAU,CACtC,IAAI,EACJ,OAAO,EACP,UAAU,EACV,IAAI,oBACJ,KAAK,2BACL,IAAI,kCACL,CAAA;YACD,IAAI,QAAQ,GAAG,IAAI,CAAA;YACnB,IAAI,KAAK,IAAI,UAAU,CAAC,MAAM,EAAE;gBAC9B,QAAQ,GAAGd,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAAE;oBAChE,aAAa,CAAC,KAAK,EAAE,UAAU,EAAE,OAAO,CAAC;iBAC1C,CAAC,CAAA;aACH;YACD8B,QAAM,CAAC,GAAG,CAAC,IAAI,EAAE;gBACf,GAAG;gBACH,QAAQ;aACT,CAAC,CAAA;SACH;KACF,CAAA;AACH,CAAC;AAED;SACgB,yBAAyB,CACvC,IAAmB,EACnB,OAA4B;IAE5B,MAAM,KAAK,GAAGA,QAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IAC9B,IAAI,KAAK,EAAE;QACT,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAA;QAC/B,IAAI,GAAG,CAAC,IAAI,kCAA0B;;YAEpC,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;YAC3B,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,GAAI,CAAC,CAAA;YAChC,IAAI,QAAQ,EAAE;gBACZ,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAA;aACjC;YACD,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;YAE3B,eAAe,CACb,IAAI,EACJ,OAAO,EACP,KAAK;;;;;;;YAOL,IAAI,CACL,CAAA;YACD,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,CAAA;YAC5B,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,GAAI,CAAC,CAAA;YAChC,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;SAC5B;aAAM;;YAEL,OAAO,CAAC,cAAc,CAAC,IAAI,GAAG,CAAC,KAAM,CAAC,OAAO,EAAE,CAAC,CAAA;YAChD,IAAI,QAAQ,EAAE;gBACZ,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAA;aACjC;YACD,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;YAC3B,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;YAC3C,OAAO,CAAC,cAAc,CAAC,KAAK,GAAG,CAAC,KAAM,CAAC,OAAO,GAAG,CAAC,CAAA;SACnD;KACF;SAAM;;QAEL,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAA;KAC3C;AACH;;ACzCA;AACA;AACA;AACA;AACA,MAAMA,QAAM,GAAG,IAAI,OAAO,EAAiC,CAAA;AAE3D,MAAM,QAAQ,GAAG,MAAM,EAAE,CAAA;AASzB,MAAM,gBAAgB,GAAG,IAAI,OAAO,EAGjC,CAAA;AAEH;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,qBAAqB,GAAkB,CAAC,IAAI,EAAE,OAAO;IAChE,IACE,IAAI,CAAC,IAAI;QACT,IAAI,CAAC,OAAO,qCACZ;QACA,OAAM;KACP;IAED,MAAM,SAAS,GAAGxB,gCAAoB,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,WAAW,CAAA;IACrE,MAAM,kBAAkB,GACtByB,eAAQ,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,MAAM,KAAKC,qCAAyB,CAAA;IACvE,gBAAgB,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,CAAA;IAErC,IAAIC,eAAQ,CAAC,SAAS,CAAC,EAAE;QACvB,IAAI,SAAS,KAAKC,oBAAQ,EAAE;YAC1B,OAAO,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;SAC3C;QACD,IAAI,SAAS,KAAKC,4BAAgB,EAAE;YAClC,OAAO,2BAA2B,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;SAClD;QACD,OAAM;KACP;;;;;;;IAQD,MAAM,aAAa,GAAsB,EAAE,CAAA;IAC3C,MAAM,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,CAAA;IAE9B,OAAO,SAAS,yBAAyB;;;;QAIvC,IAAI,UAAU,CAAC,QAAQ,CAAC,MAAM,EAAE;YAC9BxB,sBAAU,CAAC,UAAU,EAAE,OAAO,EAAE,CAAC,KAAK,EAAE,QAAQ;gBAC9C,aAAa,CAAC,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAA;gBACnE,OAAOT,oCAAwB,CAAC,SAAS,CAAC,CAAA;aAC3C,CAAC,CAAA;SACH;QAED,IAAI,QAAQ,GAAyB,MAAM,CAAA;QAC3C,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;;;YAGrB,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,GAAGY,sBAAU,CACtC,IAAI,EACJ,OAAO,EACP,SAAS,EACT,IAAI,EACJ,kBAAkB,CACnB,CAAA;YACD,IAAI,KAAK,IAAI,UAAU,CAAC,MAAM,EAAE;gBAC9B,QAAQ,GAAG,aAAa,CAAC,KAAK,EAAE,UAAU,EAAE,OAAO,CAAC,CAAA;aACrD;SACF;QAED,MAAM,UAAU,GAAmB,EAAE,CAAA;QACrCgB,QAAM,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;QAE5B,MAAM,cAAc,GAAkB,CAAC,KAAK,EAAE,QAAQ,EAAE,GAAG;YACzD,MAAM,EAAE,GAAG5B,oCAAwB,CACjC,CAAC,KAAK,IAAI,GAAG,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,EAC9C,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,GAAG,CACJ,CAAA;YACD,UAAU,CAAC,IAAI,CAAC;gBACd,IAAI,EAAE,QAAQ;gBACd,EAAE;gBACF,QAAQ;;gBAER,WAAW,EAAE,aAAa,CAAC,UAAU,CAAC,MAAM,CAAC;aAC9C,CAAC,CAAA;YACF,OAAO,EAAE,CAAA;SACV,CAAA;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM;cAC9BS,sBAAU,CAAC,IAAI,EAAE,OAAO,EAAE,cAAc,CAAC,CAAC,KAAK;cAC/C,MAAM,CAAA;QAEV,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;;;;YAIjC,IAAI,CAAC,cAAc,GAAGX,gCAAoB,CACxC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAChC;gBACE,OAAO;gBACPA,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAACoC,wBAAY,CAAC,EAAE;oBACjD,SAAS;oBACT,QAAQ;oBACR,KAAK;iBACN,CAAC;gBACF,SAAS;aACV,CACF,CAAA;SACF;aAAM;YACL,IAAI,CAAC,cAAc,GAAGpC,gCAAoB,CACxC,OAAO,CAAC,MAAM,CAAC,oBAAoB,CAAC,EACpC,CAAC,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,CAAC,CACxC,CAAA;SACF;KACF,CAAA;AACH,CAAC,CAAA;SAEe,mBAAmB,CACjC,IAAmB,EACnB,OAA4B,EAC5B,MAAyC;IAEzC,MAAM,SAAS,GAAG,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAE,CAAA;IAC7C,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;;QAExB,IAAI,SAAS,KAAKqC,oBAAQ,EAAE;YAC1B,OAAO,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;SACzC;aAAM,IAAI,SAAS,KAAKH,oBAAQ,EAAE;YACjC,OAAO,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;SACzC;aAAM,IAAI,SAAS,KAAKC,4BAAgB,EAAE;YACzC,OAAO,yBAAyB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;SAChD;aAAM;;;;;;YAML,IAAK,MAAuB,CAAC,IAAI,KAAK,QAAQ,EAAE;gBAC9C,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,CAAA;aAC3B;;YAED,IAAI,SAAS,KAAK5B,sBAAU,EAAE;gBAC5B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,+BAAuB,CAAA;aACxE;YACD,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;SAC/B;KACF;SAAM;;QAEL,MAAM,UAAU,GAAGuB,QAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAA;QACzC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1C,MAAM,EAAE,EAAE,EAAE,WAAW,EAAE,GAAG,UAAU,CAAC,CAAC,CAAC,CAAA;;;;;YAKzC,EAAE,CAAC,IAAI,GAAGhC,6BAAiB,CACzBY,kCAAsB,CAAC,OAAO,EAAE,KAAK,CAAC,EACtC,0BAA0B,CACxB,UAAU,CAAC,CAAC,CAAC,EACb,OAAO,EACP,KAAK,EACL,IAAI,uBACL,EACD,WAAW,CACZ,CAAA;SACF;;QAGD,IAAI,OAAO,CAAC,eAAe,EAAE;YAC3B,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;SAC/C;QAED,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;;YAEjC,OAAO,CAAC,aAAa,CACnBV,gCAAoB,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CACrD,CAAA;SACF;aAAM;;;YAGL,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,CAAA;SAC3C;KACF;AACH,CAAC;AAEM,MAAM,aAAa,GAAG,IAAI,OAAO,EAA6B,CAAA;AAErE,MAAM,CAAC,kBAAkB,EAAE,uBAAuB,CAAC,GACjDsC,kCAAsB,CAAC,IAAI,CAAC,CAAA;AAC9B,MAAM,mBAAmB,GAAG,CAAC,GAAG,kBAAkB,EAAE,GAAGC,6BAAiB,CAAC,CAAA;AACzE,MAAM,wBAAwB,GAAG;IAC/B,GAAG,uBAAuB;IAC1B,GAAGC,kCAAsB;CAC1B,CAAA;AAED,SAAS,qBAAqB,CAC5B,KAAiC,EACjC,QAA6B,EAC7B,aAA+B;;IAG/B,MAAM,UAAU,GAAG,aAAa,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAE,CAAA;IAEzD,MAAM,UAAU,GAAG;QACjB,GAAG,UAAU;;QAEb,cAAc,EAAE;YACd,GAAG,mBAAmB;YACtB,IAAI,UAAU,CAAC,cAAc,IAAI,EAAE,CAAC;SACrC;QACD,mBAAmB,EAAE;YACnB,GAAG,wBAAwB;YAC3B,IAAI,UAAU,CAAC,mBAAmB,IAAI,EAAE,CAAC;SAC1C;KACF,CAAA;;IAGD,MAAM,WAAW,GAAiB;QAChC,IAAI;QACJ,EAAE;QACF,GAAG,EAAE,UAAU;QACf,OAAO;QACP,aAAa,EAAE,KAAK;;;QAGpB,KAAK,EAAE;YACL;gBACE,IAAI;gBACJ,IAAI,EAAE,MAAM;gBACZ,GAAG,EAAE,KAAK;gBACV,GAAG,EAAE,SAAS;gBACd,SAAS,EAAE,EAAE;gBACb,GAAG,EAAEC,mBAAO;aACb;SACF;QACD,QAAQ;QACR,GAAG,EAAEA,mBAAO;QACZ,WAAW,EAAE,SAAS;KACvB,CAAA;IACD,YAAY,CAAC,WAAW,EAAE,UAAU,EAAE,aAAa,CAAC,CAAA;IACpD,OAAOC,iCAAqB,CAAC,QAAQ,CAAC,CAAA;AACxC,CAAC;AAED,SAAS,YAAY,CACnB,IAAuB,EACvB,OAAyB,EACzB,aAA+B;IAE/B,MAAM,SAAS,GAAGC,sBAAU,CAAC,CAAC,IAAI,CAAC,CAAC,CAAA;IACpC,MAAM,YAAY,GAAGC,kCAAsB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAA;;;IAG/D,YAAY,CAAC,GAAG,GAAG,KAAK,CAAA;;IAExB,YAAY,CAAC,MAAM,GAAG,EAAE,GAAG,aAAa,CAAC,MAAM,EAAE,CAAA;IACjD,YAAY,CAAC,WAAW,GAAG,EAAE,GAAG,aAAa,CAAC,WAAW,EAAE,CAAA;IAC3D,YAAY,CAAC,OAAO,GAAG,aAAa,CAAC,OAAO,CAAA;;IAE5CC,wBAAY,CAAC,SAAS,EAAE,YAAY,CAAC,CAEpC;IAAC,CAAC,SAAS,EAAE,YAAY,EAAE,YAAY,CAAW,CAAC,OAAO,CAAC,GAAG;QAC7D,YAAY,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,KAAU,EAAE,SAAc;YACnD,IAAI,GAAG,KAAK,SAAS,EAAE;gBACrB,MAAM,WAAW,GAAG,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;gBACxD,IAAI,WAAW,KAAK,SAAS,EAAE;oBAC7B,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,CAAA;iBAC5C;qBAAM;oBACL,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,KAAK,GAAG,WAAW,CAAC,CAAA;iBAC1D;aACF;iBAAM;gBACH,aAAa,CAAC,GAAG,CAAS,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;aACxC;SACF,CAAC,CAAA;KACH,CAAC,CAAA;;;;;AAKJ,CAAC;AAED,SAAS,KAAK,CAAC,CAAM;IACnB,IAAIC,cAAO,CAAC,CAAC,CAAC,EAAE;QACd,OAAO,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;KACpB;SAAM,IAAIf,eAAQ,CAAC,CAAC,CAAC,EAAE;QACtB,MAAM,GAAG,GAAQ,EAAE,CAAA;QACnB,KAAK,MAAM,GAAG,IAAI,CAAC,EAAE;YACnB,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;SACzB;QACD,OAAO,GAAG,CAAA;KACX;SAAM;QACL,OAAO,CAAC,CAAA;KACT;AACH;;ACnVA;AACA;AACA;AACA;AACA;SAEgB,mBAAmB,CAAC,GAAa,EAAE,OAAwB;IACzE,MAAM,OAAO,GAAG,yBAAyB,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;;;;IAKvD,IAAI,OAAO,CAAC,UAAU,EAAE;QACtB,MAAM,OAAO,GAAGgB,6BAAiB,CAC/BrC,kCAAsB,CAAC,OAAO,CAAC,UAAU,EAAE,KAAK,CAAC,EACjDkC,kCAAsB,CAACD,sBAAU,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,CAChD,CAAA;QACD,OAAO,CAAC,IAAI,CAAC,IAAI,CACfK,oCAAwB,CAAC,CAAC,4BAA4B,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC,CACvE,CAAA;KACF;IAED,MAAM,UAAU,GACd,GAAG,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAACC,kBAAM,CAAC,CAAC,CAAC,CAAC,CAAA;IAC/D,eAAe,CAAC,GAAG,EAAE,OAAO,EAAE,UAAU,CAAC,CAAA;IACzC,GAAG,CAAC,WAAW,GAAGlD,gCAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;;;IAIpD,GAAG,CAAC,UAAU,GAAG,KAAK,CAAC,IAAI,CACzB,IAAI,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,EAAE,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAC3E,CAAA;IAED,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI,UAAU,CAAC,CAAC,CAAA;AAC3D,CAAC;AAID,SAAS,yBAAyB,CAChC,IAAc,EACd,OAAwB,EACxB,UAAuB,IAAI,GAAG,EAAE,EAChC,eAAe,GAAG,KAAK;IAEvB,MAAM,IAAI,GAA2B,EAAE,CAAA;IACvC,IAAI,aAAa,GAA2B,IAAI,CAAA;IAEhD,OAAO;QACL,IAAI;QACJ,OAAO;QACP,IAAI;QACJ,OAAO;QACP,eAAe;QACf,OAAO,EACL,OAAO,CAAC,OAAO;aACd,CAAC;gBACA,MAAM,CAAC,CAAA;aACR,CAAC;QACJ,MAAM,CAAmB,IAAO;YAC9B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;YACjB,OAAO,IAAI,CAAA;SACZ;QACD,cAAc,CAAC,IAAoC;YACjD,IAAI,CAAC,aAAa,EAAE;gBAClB,MAAM,WAAW,GAAGC,gCAAoB,CAAC,OAAO,CAAC,CAAA;gBACjD,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;gBACtB,aAAa,GAAGyB,iCAAqB,CAAC,EAAE,CAAC,CAAA;gBACzC,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;aAC1C;YACD,MAAM,gBAAgB,GAAG,aAAa,CAAC,QAAQ,CAAA;YAC/C,MAAM,QAAQ,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;YAC9D,IAAIyB,eAAQ,CAAC,IAAI,CAAC,IAAIA,eAAQ,CAAC,QAAQ,CAAC,EAAE;gBACxC,gBAAgB,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI,CAAA;aACtD;iBAAM;gBACL,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;aAC5B;SACF;QACD,aAAa,CAAC,SAAuC;;YAEnD,aAAa,GAAG,IAAI,CAAA;YACpB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;SACrB;KACF,CAAA;AACH,CAAC;AAED,SAAS,kBAAkB,CACzB,MAA2B,EAC3B,eAAe,GAAG,MAAM,CAAC,eAAe;;IAGxC,OAAO,yBAAyB,CAC9B,MAAM,CAAC,IAAI,EACX,MAAM,CAAC,OAAO,EACd,MAAM,CAAC,OAAO,EACd,eAAe,CAChB,CAAA;AACH,CAAC;SAMe,eAAe,CAC7B,MAAiB,EACjB,OAA4B,EAC5B,UAAU,GAAG,KAAK,EAClB,sBAAsB,GAAG,KAAK;IAE9B,IAAI,UAAU,EAAE;QACd,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAA;KACnC;IACD,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,CAAA;IAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACxC,MAAM,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;QACzB,QAAQ,KAAK,CAAC,IAAI;YAChB;gBACE,QAAQ,KAAK,CAAC,OAAO;oBACnB;wBACE,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAA;wBACjC,MAAK;oBACP;wBACE,mBAAmB,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,CAAC,CAAA;wBAC3C,MAAK;oBACP;wBACE,oBAAoB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAA;wBACpC,MAAK;oBACP;;wBAEE,MAAK;oBACP;wBACE,OAAO,CAAC,OAAO,CACb,sBAAsB,gDAEnB,KAAa,CAAC,GAAG,CACnB,CACF,CAAA;;wBAED,MAAM,eAAe,GAAU,KAAK,CAAA;wBACpC,OAAO,eAAe,CAAA;iBACzB;gBACD,MAAK;YACP;gBACE,OAAO,CAAC,cAAc,CAAC1B,iBAAU,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAA;gBACjD,MAAK;YACP;;;gBAGE,OAAO,CAAC,cAAc,CAAC,OAAO,KAAK,CAAC,OAAO,KAAK,CAAC,CAAA;gBACjD,MAAK;YACP;gBACE,OAAO,CAAC,cAAc,CACpBxB,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CACvE,CAAA;gBACD,MAAK;YACP;gBACE,YAAY,CAAC,KAAK,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAAA;gBACpD,MAAK;YACP;gBACE,aAAa,CAAC,KAAK,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAAA;gBACrD,MAAK;YACP;;gBAEE,MAAK;YACP,kCAAyB;YACzB;;;gBAGE,MAAK;YACP;gBACE,OAAO,CAAC,OAAO,CACb,sBAAsB,gDAEnB,KAAa,CAAC,GAAG,CACnB,CACF,CAAA;;gBAED,MAAM,eAAe,GAAU,KAAK,CAAA;gBACpC,OAAO,eAAe,CAAA;SACzB;KACF;IACD,IAAI,UAAU,EAAE;QACd,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAA;KACnC;AACH,CAAC;SAEe,0BAA0B,CACxC,MAAiB,EACjB,aAAkC,EAClC,UAAU,GAAG,KAAK,EAClB,eAAe,GAAG,aAAa,CAAC,eAAe;IAE/C,MAAM,YAAY,GAAG,kBAAkB,CAAC,aAAa,EAAE,eAAe,CAAC,CAAA;IACvE,eAAe,CAAC,MAAM,EAAE,YAAY,EAAE,UAAU,CAAC,CAAA;IACjD,OAAOD,gCAAoB,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA;AAChD;;ACvMO,MAAM,iBAAiB,GAAuB,CAAC,GAAG,EAAE,IAAI,EAAE,OAAO;IACtE,MAAM,KAAK,GAAG,GAAG,CAAC,GAAI,CAAA;IAEtB,SAAS,oBAAoB;QAC3B,MAAM,KAAK,GAAGU,oBAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;QACrC,IAAI,KAAK,EAAE;YACT,OAAO,CAAC,OAAO,CACb0C,kCAAsB,qDAEpB,KAAK,CAAC,GAAG,CACV,CACF,CAAA;SACF;KACF;IAED,IAAI,IAAI,CAAC,OAAO,mCAA2B;QACzC,MAAM,GAAG,GAA6B,EAAE,KAAK,EAAE,EAAE,EAAE,CAAA;QACnD,MAAM,YAAY,GAAG;;YAEnBC,gCAAoB,CAAC,OAAO,EAAE,KAAK,CAAC;SACrC,CAAA;QACD,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,EAAE;YACxB,MAAM,IAAI,GAAG3C,oBAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;YACnC,IAAI,IAAI,EAAE;gBACR,MAAM,KAAK,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAA;gBACpC,IAAI,IAAI,CAAC,IAAI,kCAA0B;;oBAErC,GAAG,CAAC,WAAW,GAAG;wBAChBT,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,wBAAwB,CAAC,EAAE;4BAC7D,IAAI,CAAC,GAAI;4BACT,KAAK;4BACL,KAAK;yBACN,CAAC;qBACH,CAAA;iBACF;qBAAM,IAAI,IAAI,CAAC,KAAK,EAAE;;oBAErB,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO;wBACxB,KAAK,OAAO;4BACV,GAAG,CAAC,KAAK,GAAG;gCACVoD,gCAAoB,CAClB,SAAS,EACTpD,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE;oCACpD,KAAK;oCACL,KAAK;iCACN,CAAC,CACH;6BACF,CAAA;4BACD,MAAK;wBACP,KAAK,UAAU;4BACb,MAAM,gBAAgB,GAAGS,oBAAQ,CAAC,IAAI,EAAE,YAAY,CAAC,CAAA;4BACrD,IAAI,gBAAgB,EAAE;gCACpB,MAAM,SAAS,GACb,gBAAgB,CAAC,IAAI;sCACjB,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,KAAM,CAAC,OAAO,CAAC;sCAC/C,gBAAgB,CAAC,GAAI,CAAA;gCAC3B,GAAG,CAAC,KAAK,GAAG;oCACV2C,gCAAoB,CAClB,SAAS,EACTpD,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE;wCACpD,KAAK;wCACL,SAAS;qCACV,CAAC,CACH;iCACF,CAAA;6BACF;iCAAM;gCACL,GAAG,CAAC,KAAK,GAAG;oCACVoD,gCAAoB,CAClB,SAAS,EACTpC,uCAA2B,CACzBhB,gCAAoB,CAAC,eAAe,EAAE,CAAC,KAAK,CAAC,CAAC,EAC9CA,gCAAoB,CAAC,OAAO,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE;wCACtD,KAAK;wCACL,KAAK;qCACN,CAAC,EACF,KAAK,CACN,CACF;iCACF,CAAA;6BACF;4BACD,MAAK;wBACP,KAAK,MAAM;4BACT,OAAO,CAAC,OAAO,CACbmD,kCAAsB,yDAEpB,GAAG,CAAC,GAAG,CACR,CACF,CAAA;4BACD,MAAK;wBACP;4BACE,oBAAoB,EAAE,CAAA;4BACtB,GAAG,CAAC,KAAK,GAAG,YAAY,CAAA;4BACxB,MAAK;qBACR;iBACF;aACF;iBAAM,IAAIvC,8BAAkB,CAAC,IAAI,CAAC,EAAE,CAIpC;iBAAM;;gBAEL,oBAAoB,EAAE,CAAA;gBACtB,GAAG,CAAC,KAAK,GAAG,YAAY,CAAA;aACzB;SACF;aAAM,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;YAClC,oBAAoB,EAAE,CAAA;YACtB,IAAI,CAAC,QAAQ,GAAG,CAACO,+BAAmB,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAA;SACxD;aAAM,IAAI,IAAI,CAAC,GAAG,KAAK,QAAQ,EAAE,CAGjC;aAAM;YACL,OAAO,CAAC,OAAO,CACbgC,kCAAsB,sDAEpB,GAAG,CAAC,GAAG,CACR,CACF,CAAA;SACF;QAED,OAAO,GAAG,CAAA;KACX;SAAM;;QAEL,OAAOE,0BAAc,CAAC,GAAG,EAAE,IAAI,EAAE,OAAO,CAAC,CAAA;KAC1C;AACH,CAAC,CAAA;AAED,SAAS,gBAAgB,CAAC,IAAsB;IAC9C,MAAM,YAAY,GAAG5C,oBAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;IAC5C,OAAO,YAAY;UACf,YAAY,CAAC,IAAI;cACf,YAAY,CAAC,GAAI;cACjBC,kCAAsB,CAAC,YAAY,CAAC,KAAM,CAAC,OAAO,EAAE,IAAI,CAAC;UAC3DA,kCAAsB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;AAC3C;;AClJO,MAAM,gBAAgB,GAAuB,CAAC,GAAG,EAAE,IAAI,EAAE,OAAO;IACrE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;QACZ,OAAO,CAAC,OAAO,CACbyC,kCAAsB,+CAAsC,CAC7D,CAAA;KACF;IACD,OAAO;QACL,KAAK,EAAE;YACLC,gCAAoB,CAClB,OAAO,EACPpC,uCAA2B,CACzB,GAAG,CAAC,GAAI,EACRN,kCAAsB,CAAC,MAAM,EAAE,KAAK,CAAC,EACrC4C,kCAAsB,CAAC;gBACrBF,gCAAoB,CAClB,SAAS,EACT1C,kCAAsB,CAAC,MAAM,EAAE,IAAI,CAAC,CACrC;aACF,CAAC,EACF,KAAK,kBACN,CACF;SACF;KACF,CAAA;AACH,CAAC;;ACrBD,MAAM,WAAW,GAAG,CAAC,IAAgB,KACnC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,+BAAuB,CAAA;AAEzD,MAAM,cAAc,GAAG,CAAC,IAAgB,KACtC,WAAW,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAA;AAEzB,MAAM,yBAAyB,GAAkB,CAAC,IAAI,EAAE,OAAO;;;;IAIpE,IAAI,IAAI,CAAC,IAAI,6BAAqB;QAChC,OAAO,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAA;KAC/B;IAED,IACE,IAAI,CAAC,IAAI;QACT,IAAI,CAAC,OAAO;SACX6C,yBAAa,CAAC,IAAI,CAAC,GAAG,EAAE,YAAY,CAAC;YACpCA,yBAAa,CAAC,IAAI,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC,EACvC;QACA,MAAM,YAAY,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;QAC9C,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,IAAI,YAAY,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;YACzD,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;gBACxB,sBAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;aACzC;YACD,OAAM;SACP;KACF;IAED,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAA;IAC7B,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,6BAAqB;QAC7C,OAAM;KACP;IAED,IAAI,IAAI,CAAC,IAAI,qCAA4B,cAAc,CAAC,IAAI,CAAC,EAAE;;QAE7D,IAAI,gBAAgB,GAAG,KAAK,CAAA;QAC5B,KAAK,MAAM,CAAC,IAAI,WAAW,CAAC,MAAM,CAAC,EAAE;YACnC,IACE,CAAC,CAAC,IAAI;iBACL,CAAC,CAAC,IAAI,kCAA0BC,mBAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAClD;;gBAEA,IAAI,gBAAgB;oBAAE,OAAM;gBAC5B,gBAAgB,GAAG,IAAI,CAAA;aACxB;iBAAM;;YAEL,CAAC,gBAAgB;;gBAEjB,EAAE,CAAC,CAAC,IAAI,kCAA0BA,mBAAO,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,EAC3D;gBACA,OAAM;aACP;SACF;QACD,sBAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;KACzC;SAAM,IAAI,cAAc,CAAC,MAAM,CAAC,EAAE;QACjC,sBAAsB,CAAC,IAAI,CAAC,CAAA;KAC7B;AACH,CAAC,CAAA;AAED,SAAS,sBAAsB,CAAC,IAAkC;IAChE,IACE,IAAI,CAAC,IAAI;SACR,IAAI,CAAC,OAAO;YACX,IAAI,CAAC,OAAO,oCAA4B;QAC1C,CAACA,mBAAO,CAAC,IAAI,EAAE,KAAK,CAAC,EACrB;QACA,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;YACd,IAAI;YACJ,IAAI,EAAE,MAAM;YACZ,GAAG,EAAE,SAAS;YACd,GAAG,EAAE9C,kCAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC;YAC5C,SAAS,EAAE,EAAE;YACb,GAAG,EAAE+B,mBAAO;SACb,CAAC,CAAA;KACH;AACH;;AC7EO,MAAM,gBAAgB,GAAkB,CAAC,IAAI,EAAE,OAAO;IAC3D,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;QACvB,OAAM;KACP;;;;IAKD,IAAI,IAAI,CAAC,IAAI,6BAAqB;QAChC,OAAO,CAAC,WAAW,CAAC,QAAQ,GAAG,CAAC,CAAA;KACjC;IAED,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAA;IAC7B,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,6BAAqB;QAC7C,OAAM;KACP;IAED,IAAI,IAAI,CAAC,IAAI,mCAA0B;QACrC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,aAAa,CAAC,KAAK,CAAC,CAAA;SACrB;KACF;SAAM;QACL,aAAa,CAAC,IAAI,CAAC,CAAA;KACpB;AACH,CAAC,CAAA;AAED,SAAS,aAAa,CAAC,IAAkC;IACvD,IACE,IAAI,CAAC,IAAI;SACR,IAAI,CAAC,OAAO;YACX,IAAI,CAAC,OAAO,oCAA4B;QAC1C,CAACe,mBAAO,CAAC,IAAI,EAAE,KAAK,CAAC,EACrB;QACA,IAAID,yBAAa,CAAC,IAAI,CAAC,GAAG,EAAE,UAAU,CAAC,EAAE;YACvC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjC,IACE,KAAK,CAAC,IAAI;oBACV,KAAK,CAAC,OAAO,oCACb;;oBAEA,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,aAAa,CAAC,CAAA;iBACtC;qBAAM;oBACL,aAAa,CAAC,KAAK,CAAC,CAAA;iBACrB;aACF;SACF;aAAM;YACL,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBACd,IAAI;gBACJ,IAAI,EAAE,MAAM;gBACZ,GAAG,EAAE,SAAS;gBACd,GAAG,EAAE7C,kCAAsB,CAAC,UAAU,EAAE,KAAK,CAAC;gBAC9C,SAAS,EAAE,EAAE;gBACb,GAAG,EAAE+B,mBAAO;aACb,CAAC,CAAA;SACH;KACF;AACH;;SCvCgB,OAAO,CACrB,QAAgB,EAChB,UAA2B,EAAE;IAE7B,OAAO,GAAG;QACR,GAAG,OAAO;;QAEV,GAAGgB,yBAAa;QAChB,GAAG,EAAE,IAAI;QACT,KAAK,EAAE,IAAI;QACX,OAAO,EAAE,OAAO,CAAC,IAAI,KAAK,UAAU,GAAG,IAAI,GAAG,OAAO,CAAC,OAAO;;QAE7D,iBAAiB,EAAE,IAAI;;QAEvB,aAAa,EAAE,KAAK;QACpB,WAAW,EAAE,KAAK;KACnB,CAAA;IAED,MAAM,GAAG,GAAGC,qBAAS,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAA;;;IAIxC,aAAa,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;IAE/BC,qBAAS,CAAC,GAAG,EAAE;QACb,GAAG,OAAO;QACV,WAAW,EAAE,KAAK;QAClB,cAAc,EAAE;YACd,cAAc;YACd,eAAe;YACfC,+BAAmB;YACnBC,+BAAmB;YACnB,sBAAsB;YACtB,yBAAyB;YACzB,gBAAgB;YAChB,mBAAmB;YACnB,qBAAqB;YACrBC,2BAAe;YACfC,0BAAc;YACd,IAAI,OAAO,CAAC,cAAc,IAAI,EAAE,CAAC;SAClC;QACD,mBAAmB,EAAE;;YAEnB,IAAI,EAAEC,yBAAa;YACnB,EAAE,EAAEC,uBAAW;;YAEf,KAAK,EAAE,iBAAiB;YACxB,IAAI,EAAE,gBAAgB;;;YAGtB,KAAK,EAAEC,kCAAsB;YAC7B,IAAI,EAAEA,kCAAsB;YAC5B,IAAI,EAAEA,kCAAsB;YAC5B,IAAI,OAAO,CAAC,mBAAmB,IAAI,EAAE,CAAC;SACvC;KACF,CAAC,CAAA;;;IAIF,mBAAmB,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;IAEjC,OAAOC,oBAAQ,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;AAC/B;;;;"}