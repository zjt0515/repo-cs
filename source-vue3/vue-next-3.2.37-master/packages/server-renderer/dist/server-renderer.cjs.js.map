{"version":3,"file":"server-renderer.cjs.js","sources":["../src/helpers/ssrRenderAttrs.ts","../src/helpers/ssrCompile.ts","../src/helpers/ssrRenderTeleport.ts","../src/render.ts","../src/renderToString.ts","../src/renderToStream.ts","../src/helpers/ssrRenderComponent.ts","../src/helpers/ssrRenderSlot.ts","../src/helpers/ssrInterpolate.ts","../../reactivity/src/reactive.ts","../../reactivity/src/ref.ts","../../runtime-core/src/warning.ts","../../runtime-core/src/errorHandling.ts","../../runtime-core/src/component.ts","../src/helpers/ssrRenderList.ts","../src/helpers/ssrRenderSuspense.ts","../src/helpers/ssrGetDirectiveProps.ts","../src/helpers/ssrVModelHelpers.ts","../src/index.ts"],"sourcesContent":["import { escapeHtml, stringifyStyle } from '@vue/shared'\nimport {\n  normalizeClass,\n  normalizeStyle,\n  propsToAttrMap,\n  isString,\n  isOn,\n  isSSRSafeAttrName,\n  isBooleanAttr,\n  includeBooleanAttr,\n  makeMap\n} from '@vue/shared'\n\n// leading comma for empty string \"\"\nconst shouldIgnoreProp = makeMap(\n  `,key,ref,innerHTML,textContent,ref_key,ref_for`\n)\n\nexport function ssrRenderAttrs(\n  props: Record<string, unknown>,\n  tag?: string\n): string {\n  let ret = ''\n  for (const key in props) {\n    if (\n      shouldIgnoreProp(key) ||\n      isOn(key) ||\n      (tag === 'textarea' && key === 'value')\n    ) {\n      continue\n    }\n    const value = props[key]\n    if (key === 'class') {\n      ret += ` class=\"${ssrRenderClass(value)}\"`\n    } else if (key === 'style') {\n      ret += ` style=\"${ssrRenderStyle(value)}\"`\n    } else {\n      ret += ssrRenderDynamicAttr(key, value, tag)\n    }\n  }\n  return ret\n}\n\n// render an attr with dynamic (unknown) key.\nexport function ssrRenderDynamicAttr(\n  key: string,\n  value: unknown,\n  tag?: string\n): string {\n  if (!isRenderableValue(value)) {\n    return ``\n  }\n  const attrKey =\n    tag && tag.indexOf('-') > 0\n      ? key // preserve raw name on custom elements\n      : propsToAttrMap[key] || key.toLowerCase()\n  if (isBooleanAttr(attrKey)) {\n    return includeBooleanAttr(value) ? ` ${attrKey}` : ``\n  } else if (isSSRSafeAttrName(attrKey)) {\n    return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${escapeHtml(value)}\"`\n  } else {\n    console.warn(\n      `[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`\n    )\n    return ``\n  }\n}\n\n// Render a v-bind attr with static key. The key is pre-processed at compile\n// time and we only need to check and escape value.\nexport function ssrRenderAttr(key: string, value: unknown): string {\n  if (!isRenderableValue(value)) {\n    return ``\n  }\n  return ` ${key}=\"${escapeHtml(value)}\"`\n}\n\nfunction isRenderableValue(value: unknown): boolean {\n  if (value == null) {\n    return false\n  }\n  const type = typeof value\n  return type === 'string' || type === 'number' || type === 'boolean'\n}\n\nexport function ssrRenderClass(raw: unknown): string {\n  return escapeHtml(normalizeClass(raw))\n}\n\nexport function ssrRenderStyle(raw: unknown): string {\n  if (!raw) {\n    return ''\n  }\n  if (isString(raw)) {\n    return escapeHtml(raw)\n  }\n  const styles = normalizeStyle(raw)\n  return escapeHtml(stringifyStyle(styles))\n}\n","import { ComponentInternalInstance, ComponentOptions, warn } from 'vue'\nimport { compile } from '@vue/compiler-ssr'\nimport { extend, generateCodeFrame, isFunction, NO } from '@vue/shared'\nimport { CompilerError, CompilerOptions } from '@vue/compiler-core'\nimport { PushFn } from '../render'\n\ntype SSRRenderFunction = (\n  context: any,\n  push: PushFn,\n  parentInstance: ComponentInternalInstance\n) => void\n\nconst compileCache: Record<string, SSRRenderFunction> = Object.create(null)\n\nexport function ssrCompile(\n  template: string,\n  instance: ComponentInternalInstance\n): SSRRenderFunction {\n  if (!__NODE_JS__) {\n    throw new Error(\n      `On-the-fly template compilation is not supported in the ESM build of ` +\n        `@vue/server-renderer. All templates must be pre-compiled into ` +\n        `render functions.`\n    )\n  }\n\n  // TODO: This is copied from runtime-core/src/component.ts and should probably be refactored\n  const Component = instance.type as ComponentOptions\n  const { isCustomElement, compilerOptions } = instance.appContext.config\n  const { delimiters, compilerOptions: componentCompilerOptions } = Component\n\n  const finalCompilerOptions: CompilerOptions = extend(\n    extend(\n      {\n        isCustomElement,\n        delimiters\n      },\n      compilerOptions\n    ),\n    componentCompilerOptions\n  )\n\n  finalCompilerOptions.isCustomElement =\n    finalCompilerOptions.isCustomElement || NO\n  finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || NO\n\n  const cacheKey = JSON.stringify(\n    {\n      template,\n      compilerOptions: finalCompilerOptions\n    },\n    (key, value) => {\n      return isFunction(value) ? value.toString() : value\n    }\n  )\n\n  const cached = compileCache[cacheKey]\n  if (cached) {\n    return cached\n  }\n\n  finalCompilerOptions.onError = (err: CompilerError) => {\n    if (__DEV__) {\n      const message = `[@vue/server-renderer] Template compilation error: ${err.message}`\n      const codeFrame =\n        err.loc &&\n        generateCodeFrame(\n          template as string,\n          err.loc.start.offset,\n          err.loc.end.offset\n        )\n      warn(codeFrame ? `${message}\\n${codeFrame}` : message)\n    } else {\n      throw err\n    }\n  }\n\n  const { code } = compile(template, finalCompilerOptions)\n  return (compileCache[cacheKey] = Function('require', code)(require))\n}\n","import { ComponentInternalInstance, ssrContextKey } from 'vue'\nimport { createBuffer, PushFn, SSRBufferItem, SSRContext } from '../render'\n\nexport function ssrRenderTeleport(\n  parentPush: PushFn,\n  contentRenderFn: (push: PushFn) => void,\n  target: string,\n  disabled: boolean,\n  parentComponent: ComponentInternalInstance\n) {\n  parentPush('<!--teleport start-->')\n\n  const context = parentComponent.appContext.provides[\n    ssrContextKey as any\n  ] as SSRContext\n  const teleportBuffers =\n    context.__teleportBuffers || (context.__teleportBuffers = {})\n  const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = [])\n  // record current index of the target buffer to handle nested teleports\n  // since the parent needs to be rendered before the child\n  const bufferIndex = targetBuffer.length\n\n  let teleportContent: SSRBufferItem\n\n  if (disabled) {\n    contentRenderFn(parentPush)\n    teleportContent = `<!--teleport anchor-->`\n  } else {\n    const { getBuffer, push } = createBuffer()\n    contentRenderFn(push)\n    push(`<!--teleport anchor-->`)\n    teleportContent = getBuffer()\n  }\n\n  targetBuffer.splice(bufferIndex, 0, teleportContent)\n  parentPush('<!--teleport end-->')\n}\n","import {\n  Comment,\n  Component,\n  ComponentInternalInstance,\n  DirectiveBinding,\n  Fragment,\n  FunctionalComponent,\n  mergeProps,\n  ssrUtils,\n  Static,\n  Text,\n  VNode,\n  VNodeArrayChildren,\n  VNodeProps,\n  warn\n} from 'vue'\nimport {\n  escapeHtml,\n  escapeHtmlComment,\n  isFunction,\n  isPromise,\n  isString,\n  isVoidTag,\n  ShapeFlags,\n  isArray,\n  NOOP\n} from '@vue/shared'\nimport { ssrRenderAttrs } from './helpers/ssrRenderAttrs'\nimport { ssrCompile } from './helpers/ssrCompile'\nimport { ssrRenderTeleport } from './helpers/ssrRenderTeleport'\n\nconst {\n  createComponentInstance,\n  setCurrentRenderingInstance,\n  setupComponent,\n  renderComponentRoot,\n  normalizeVNode\n} = ssrUtils\n\nexport type SSRBuffer = SSRBufferItem[] & { hasAsync?: boolean }\nexport type SSRBufferItem = string | SSRBuffer | Promise<SSRBuffer>\nexport type PushFn = (item: SSRBufferItem) => void\nexport type Props = Record<string, unknown>\n\nexport type SSRContext = {\n  [key: string]: any\n  teleports?: Record<string, string>\n  __teleportBuffers?: Record<string, SSRBuffer>\n}\n\n// Each component has a buffer array.\n// A buffer array can contain one of the following:\n// - plain string\n// - A resolved buffer (recursive arrays of strings that can be unrolled\n//   synchronously)\n// - An async buffer (a Promise that resolves to a resolved buffer)\nexport function createBuffer() {\n  let appendable = false\n  const buffer: SSRBuffer = []\n  return {\n    getBuffer(): SSRBuffer {\n      // Return static buffer and await on items during unroll stage\n      return buffer\n    },\n    push(item: SSRBufferItem) {\n      const isStringItem = isString(item)\n      if (appendable && isStringItem) {\n        buffer[buffer.length - 1] += item as string\n      } else {\n        buffer.push(item)\n      }\n      appendable = isStringItem\n      if (isPromise(item) || (isArray(item) && item.hasAsync)) {\n        // promise, or child buffer with async, mark as async.\n        // this allows skipping unnecessary await ticks during unroll stage\n        buffer.hasAsync = true\n      }\n    }\n  }\n}\n\nexport function renderComponentVNode(\n  vnode: VNode,\n  parentComponent: ComponentInternalInstance | null = null,\n  slotScopeId?: string\n): SSRBuffer | Promise<SSRBuffer> {\n  const instance = createComponentInstance(vnode, parentComponent, null)\n  const res = setupComponent(instance, true /* isSSR */)\n  const hasAsyncSetup = isPromise(res)\n  const prefetches = instance.sp /* LifecycleHooks.SERVER_PREFETCH */\n  if (hasAsyncSetup || prefetches) {\n    let p: Promise<unknown> = hasAsyncSetup\n      ? (res as Promise<void>)\n      : Promise.resolve()\n    if (prefetches) {\n      p = p\n        .then(() =>\n          Promise.all(prefetches.map(prefetch => prefetch.call(instance.proxy)))\n        )\n        // Note: error display is already done by the wrapped lifecycle hook function.\n        .catch(() => {})\n    }\n    return p.then(() => renderComponentSubTree(instance, slotScopeId))\n  } else {\n    return renderComponentSubTree(instance, slotScopeId)\n  }\n}\n\nfunction renderComponentSubTree(\n  instance: ComponentInternalInstance,\n  slotScopeId?: string\n): SSRBuffer | Promise<SSRBuffer> {\n  const comp = instance.type as Component\n  const { getBuffer, push } = createBuffer()\n  if (isFunction(comp)) {\n    let root = renderComponentRoot(instance)\n    // #5817 scope ID attrs not falling through if functional component doesn't\n    // have props\n    if (!(comp as FunctionalComponent).props) {\n      for (const key in instance.attrs) {\n        if (key.startsWith(`data-v-`)) {\n          ;(root.props || (root.props = {}))[key] = ``\n        }\n      }\n    }\n    renderVNode(push, (instance.subTree = root), instance, slotScopeId)\n  } else {\n    if (\n      (!instance.render || instance.render === NOOP) &&\n      !instance.ssrRender &&\n      !comp.ssrRender &&\n      isString(comp.template)\n    ) {\n      comp.ssrRender = ssrCompile(comp.template, instance)\n    }\n\n    // perf: enable caching of computed getters during render\n    // since there cannot be state mutations during render.\n    for (const e of instance.scope.effects) {\n      if (e.computed) e.computed._cacheable = true\n    }\n\n    const ssrRender = instance.ssrRender || comp.ssrRender\n    if (ssrRender) {\n      // optimized\n      // resolve fallthrough attrs\n      let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined\n      let hasCloned = false\n\n      let cur = instance\n      while (true) {\n        const scopeId = cur.vnode.scopeId\n        if (scopeId) {\n          if (!hasCloned) {\n            attrs = { ...attrs }\n            hasCloned = true\n          }\n          attrs![scopeId] = ''\n        }\n        const parent = cur.parent\n        if (parent && parent.subTree && parent.subTree === cur.vnode) {\n          // parent is a non-SSR compiled component and is rendering this\n          // component as root. inherit its scopeId if present.\n          cur = parent\n        } else {\n          break\n        }\n      }\n\n      if (slotScopeId) {\n        if (!hasCloned) attrs = { ...attrs }\n        attrs![slotScopeId.trim()] = ''\n      }\n\n      // set current rendering instance for asset resolution\n      const prev = setCurrentRenderingInstance(instance)\n      ssrRender(\n        instance.proxy,\n        push,\n        instance,\n        attrs,\n        // compiler-optimized bindings\n        instance.props,\n        instance.setupState,\n        instance.data,\n        instance.ctx\n      )\n      setCurrentRenderingInstance(prev)\n    } else if (instance.render && instance.render !== NOOP) {\n      renderVNode(\n        push,\n        (instance.subTree = renderComponentRoot(instance)),\n        instance,\n        slotScopeId\n      )\n    } else {\n      const componentName = comp.name || comp.__file || `<Anonymous>`\n      warn(`Component ${componentName} is missing template or render function.`)\n      push(`<!---->`)\n    }\n  }\n  return getBuffer()\n}\n\nexport function renderVNode(\n  push: PushFn,\n  vnode: VNode,\n  parentComponent: ComponentInternalInstance,\n  slotScopeId?: string\n) {\n  const { type, shapeFlag, children } = vnode\n  switch (type) {\n    case Text:\n      push(escapeHtml(children as string))\n      break\n    case Comment:\n      push(\n        children ? `<!--${escapeHtmlComment(children as string)}-->` : `<!---->`\n      )\n      break\n    case Static:\n      push(children as string)\n      break\n    case Fragment:\n      if (vnode.slotScopeIds) {\n        slotScopeId =\n          (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ')\n      }\n      push(`<!--[-->`) // open\n      renderVNodeChildren(\n        push,\n        children as VNodeArrayChildren,\n        parentComponent,\n        slotScopeId\n      )\n      push(`<!--]-->`) // close\n      break\n    default:\n      if (shapeFlag & ShapeFlags.ELEMENT) {\n        renderElementVNode(push, vnode, parentComponent, slotScopeId)\n      } else if (shapeFlag & ShapeFlags.COMPONENT) {\n        push(renderComponentVNode(vnode, parentComponent, slotScopeId))\n      } else if (shapeFlag & ShapeFlags.TELEPORT) {\n        renderTeleportVNode(push, vnode, parentComponent, slotScopeId)\n      } else if (shapeFlag & ShapeFlags.SUSPENSE) {\n        renderVNode(push, vnode.ssContent!, parentComponent, slotScopeId)\n      } else {\n        warn(\n          '[@vue/server-renderer] Invalid VNode type:',\n          type,\n          `(${typeof type})`\n        )\n      }\n  }\n}\n\nexport function renderVNodeChildren(\n  push: PushFn,\n  children: VNodeArrayChildren,\n  parentComponent: ComponentInternalInstance,\n  slotScopeId: string | undefined\n) {\n  for (let i = 0; i < children.length; i++) {\n    renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId)\n  }\n}\n\nfunction renderElementVNode(\n  push: PushFn,\n  vnode: VNode,\n  parentComponent: ComponentInternalInstance,\n  slotScopeId: string | undefined\n) {\n  const tag = vnode.type as string\n  let { props, children, shapeFlag, scopeId, dirs } = vnode\n  let openTag = `<${tag}`\n\n  if (dirs) {\n    props = applySSRDirectives(vnode, props, dirs)\n  }\n\n  if (props) {\n    openTag += ssrRenderAttrs(props, tag)\n  }\n\n  if (scopeId) {\n    openTag += ` ${scopeId}`\n  }\n  // inherit parent chain scope id if this is the root node\n  let curParent: ComponentInternalInstance | null = parentComponent\n  let curVnode = vnode\n  while (curParent && curVnode === curParent.subTree) {\n    curVnode = curParent.vnode\n    if (curVnode.scopeId) {\n      openTag += ` ${curVnode.scopeId}`\n    }\n    curParent = curParent.parent\n  }\n  if (slotScopeId) {\n    openTag += ` ${slotScopeId}`\n  }\n\n  push(openTag + `>`)\n  if (!isVoidTag(tag)) {\n    let hasChildrenOverride = false\n    if (props) {\n      if (props.innerHTML) {\n        hasChildrenOverride = true\n        push(props.innerHTML)\n      } else if (props.textContent) {\n        hasChildrenOverride = true\n        push(escapeHtml(props.textContent))\n      } else if (tag === 'textarea' && props.value) {\n        hasChildrenOverride = true\n        push(escapeHtml(props.value))\n      }\n    }\n    if (!hasChildrenOverride) {\n      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n        push(escapeHtml(children as string))\n      } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        renderVNodeChildren(\n          push,\n          children as VNodeArrayChildren,\n          parentComponent,\n          slotScopeId\n        )\n      }\n    }\n    push(`</${tag}>`)\n  }\n}\n\nfunction applySSRDirectives(\n  vnode: VNode,\n  rawProps: VNodeProps | null,\n  dirs: DirectiveBinding[]\n): VNodeProps {\n  const toMerge: VNodeProps[] = []\n  for (let i = 0; i < dirs.length; i++) {\n    const binding = dirs[i]\n    const {\n      dir: { getSSRProps }\n    } = binding\n    if (getSSRProps) {\n      const props = getSSRProps(binding, vnode)\n      if (props) toMerge.push(props)\n    }\n  }\n  return mergeProps(rawProps || {}, ...toMerge)\n}\n\nfunction renderTeleportVNode(\n  push: PushFn,\n  vnode: VNode,\n  parentComponent: ComponentInternalInstance,\n  slotScopeId: string | undefined\n) {\n  const target = vnode.props && vnode.props.to\n  const disabled = vnode.props && vnode.props.disabled\n  if (!target) {\n    if (!disabled) {\n      warn(`[@vue/server-renderer] Teleport is missing target prop.`)\n    }\n    return []\n  }\n  if (!isString(target)) {\n    warn(\n      `[@vue/server-renderer] Teleport target must be a query selector string.`\n    )\n    return []\n  }\n  ssrRenderTeleport(\n    push,\n    push => {\n      renderVNodeChildren(\n        push,\n        vnode.children as VNodeArrayChildren,\n        parentComponent,\n        slotScopeId\n      )\n    },\n    target,\n    disabled || disabled === '',\n    parentComponent\n  )\n}\n","import {\n  App,\n  createApp,\n  createVNode,\n  ssrContextKey,\n  ssrUtils,\n  VNode\n} from 'vue'\nimport { isPromise, isString } from '@vue/shared'\nimport { SSRContext, renderComponentVNode, SSRBuffer } from './render'\n\nconst { isVNode } = ssrUtils\n\nasync function unrollBuffer(buffer: SSRBuffer): Promise<string> {\n  if (buffer.hasAsync) {\n    let ret = ''\n    for (let i = 0; i < buffer.length; i++) {\n      let item = buffer[i]\n      if (isPromise(item)) {\n        item = await item\n      }\n      if (isString(item)) {\n        ret += item\n      } else {\n        ret += await unrollBuffer(item)\n      }\n    }\n    return ret\n  } else {\n    // sync buffer can be more efficiently unrolled without unnecessary await\n    // ticks\n    return unrollBufferSync(buffer)\n  }\n}\n\nfunction unrollBufferSync(buffer: SSRBuffer): string {\n  let ret = ''\n  for (let i = 0; i < buffer.length; i++) {\n    let item = buffer[i]\n    if (isString(item)) {\n      ret += item\n    } else {\n      // since this is a sync buffer, child buffers are never promises\n      ret += unrollBufferSync(item as SSRBuffer)\n    }\n  }\n  return ret\n}\n\nexport async function renderToString(\n  input: App | VNode,\n  context: SSRContext = {}\n): Promise<string> {\n  if (isVNode(input)) {\n    // raw vnode, wrap with app (for context)\n    return renderToString(createApp({ render: () => input }), context)\n  }\n\n  // rendering an app\n  const vnode = createVNode(input._component, input._props)\n  vnode.appContext = input._context\n  // provide the ssr context to the tree\n  input.provide(ssrContextKey, context)\n  const buffer = await renderComponentVNode(vnode)\n\n  const result = await unrollBuffer(buffer as SSRBuffer)\n\n  await resolveTeleports(context)\n\n  return result\n}\n\nexport async function resolveTeleports(context: SSRContext) {\n  if (context.__teleportBuffers) {\n    context.teleports = context.teleports || {}\n    for (const key in context.__teleportBuffers) {\n      // note: it's OK to await sequentially here because the Promises were\n      // created eagerly in parallel.\n      context.teleports[key] = await unrollBuffer(\n        await Promise.all([context.__teleportBuffers[key]])\n      )\n    }\n  }\n}\n","import {\n  App,\n  VNode,\n  createVNode,\n  ssrUtils,\n  createApp,\n  ssrContextKey\n} from 'vue'\nimport { isString, isPromise } from '@vue/shared'\nimport { renderComponentVNode, SSRBuffer, SSRContext } from './render'\nimport { Readable, Writable } from 'stream'\nimport { resolveTeleports } from './renderToString'\n\nconst { isVNode } = ssrUtils\n\nexport interface SimpleReadable {\n  push(chunk: string | null): void\n  destroy(err: any): void\n}\n\nasync function unrollBuffer(\n  buffer: SSRBuffer,\n  stream: SimpleReadable\n): Promise<void> {\n  if (buffer.hasAsync) {\n    for (let i = 0; i < buffer.length; i++) {\n      let item = buffer[i]\n      if (isPromise(item)) {\n        item = await item\n      }\n      if (isString(item)) {\n        stream.push(item)\n      } else {\n        await unrollBuffer(item, stream)\n      }\n    }\n  } else {\n    // sync buffer can be more efficiently unrolled without unnecessary await\n    // ticks\n    unrollBufferSync(buffer, stream)\n  }\n}\n\nfunction unrollBufferSync(buffer: SSRBuffer, stream: SimpleReadable) {\n  for (let i = 0; i < buffer.length; i++) {\n    let item = buffer[i]\n    if (isString(item)) {\n      stream.push(item)\n    } else {\n      // since this is a sync buffer, child buffers are never promises\n      unrollBufferSync(item as SSRBuffer, stream)\n    }\n  }\n}\n\nexport function renderToSimpleStream<T extends SimpleReadable>(\n  input: App | VNode,\n  context: SSRContext,\n  stream: T\n): T {\n  if (isVNode(input)) {\n    // raw vnode, wrap with app (for context)\n    return renderToSimpleStream(\n      createApp({ render: () => input }),\n      context,\n      stream\n    )\n  }\n\n  // rendering an app\n  const vnode = createVNode(input._component, input._props)\n  vnode.appContext = input._context\n  // provide the ssr context to the tree\n  input.provide(ssrContextKey, context)\n\n  Promise.resolve(renderComponentVNode(vnode))\n    .then(buffer => unrollBuffer(buffer, stream))\n    .then(() => resolveTeleports(context))\n    .then(() => stream.push(null))\n    .catch(error => {\n      stream.destroy(error)\n    })\n\n  return stream\n}\n\n/**\n * @deprecated\n */\nexport function renderToStream(\n  input: App | VNode,\n  context: SSRContext = {}\n): Readable {\n  console.warn(\n    `[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`\n  )\n  return renderToNodeStream(input, context)\n}\n\nexport function renderToNodeStream(\n  input: App | VNode,\n  context: SSRContext = {}\n): Readable {\n  const stream: Readable = __NODE_JS__\n    ? new (require('stream').Readable)({ read() {} })\n    : null\n\n  if (!stream) {\n    throw new Error(\n      `ESM build of renderToStream() does not support renderToNodeStream(). ` +\n        `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\n        `instance instead.`\n    )\n  }\n\n  return renderToSimpleStream(input, context, stream)\n}\n\nexport function pipeToNodeWritable(\n  input: App | VNode,\n  context: SSRContext = {},\n  writable: Writable\n) {\n  renderToSimpleStream(input, context, {\n    push(content) {\n      if (content != null) {\n        writable.write(content)\n      } else {\n        writable.end()\n      }\n    },\n    destroy(err) {\n      writable.destroy(err)\n    }\n  })\n}\n\nexport function renderToWebStream(\n  input: App | VNode,\n  context: SSRContext = {}\n): ReadableStream {\n  if (typeof ReadableStream !== 'function') {\n    throw new Error(\n      `ReadableStream constructor is not available in the global scope. ` +\n        `If the target environment does support web streams, consider using ` +\n        `pipeToWebWritable() with an existing WritableStream instance instead.`\n    )\n  }\n\n  const encoder = new TextEncoder()\n  let cancelled = false\n\n  return new ReadableStream({\n    start(controller) {\n      renderToSimpleStream(input, context, {\n        push(content) {\n          if (cancelled) return\n          if (content != null) {\n            controller.enqueue(encoder.encode(content))\n          } else {\n            controller.close()\n          }\n        },\n        destroy(err) {\n          controller.error(err)\n        }\n      })\n    },\n    cancel() {\n      cancelled = true\n    }\n  })\n}\n\nexport function pipeToWebWritable(\n  input: App | VNode,\n  context: SSRContext = {},\n  writable: WritableStream\n): void {\n  const writer = writable.getWriter()\n  const encoder = new TextEncoder()\n\n  // #4287 CloudFlare workers do not implement `ready` property\n  let hasReady = false\n  try {\n    hasReady = isPromise(writer.ready)\n  } catch (e: any) {}\n\n  renderToSimpleStream(input, context, {\n    async push(content) {\n      if (hasReady) {\n        await writer.ready\n      }\n      if (content != null) {\n        return writer.write(encoder.encode(content))\n      } else {\n        return writer.close()\n      }\n    },\n    destroy(err) {\n      // TODO better error handling?\n      console.log(err)\n      writer.close()\n    }\n  })\n}\n","import { Component, ComponentInternalInstance, createVNode, Slots } from 'vue'\nimport { Props, renderComponentVNode, SSRBuffer } from '../render'\nimport { SSRSlots } from './ssrRenderSlot'\n\nexport function ssrRenderComponent(\n  comp: Component,\n  props: Props | null = null,\n  children: Slots | SSRSlots | null = null,\n  parentComponent: ComponentInternalInstance | null = null,\n  slotScopeId?: string\n): SSRBuffer | Promise<SSRBuffer> {\n  return renderComponentVNode(\n    createVNode(comp, props, children),\n    parentComponent,\n    slotScopeId\n  )\n}\n","import { ComponentInternalInstance, Slots } from 'vue'\nimport { Props, PushFn, renderVNodeChildren, SSRBufferItem } from '../render'\nimport { isArray } from '@vue/shared'\n\nexport type SSRSlots = Record<string, SSRSlot>\nexport type SSRSlot = (\n  props: Props,\n  push: PushFn,\n  parentComponent: ComponentInternalInstance | null,\n  scopeId: string | null\n) => void\n\nexport function ssrRenderSlot(\n  slots: Slots | SSRSlots,\n  slotName: string,\n  slotProps: Props,\n  fallbackRenderFn: (() => void) | null,\n  push: PushFn,\n  parentComponent: ComponentInternalInstance,\n  slotScopeId?: string\n) {\n  // template-compiled slots are always rendered as fragments\n  push(`<!--[-->`)\n  ssrRenderSlotInner(\n    slots,\n    slotName,\n    slotProps,\n    fallbackRenderFn,\n    push,\n    parentComponent,\n    slotScopeId\n  )\n  push(`<!--]-->`)\n}\n\nexport function ssrRenderSlotInner(\n  slots: Slots | SSRSlots,\n  slotName: string,\n  slotProps: Props,\n  fallbackRenderFn: (() => void) | null,\n  push: PushFn,\n  parentComponent: ComponentInternalInstance,\n  slotScopeId?: string,\n  transition?: boolean\n) {\n  const slotFn = slots[slotName]\n  if (slotFn) {\n    const slotBuffer: SSRBufferItem[] = []\n    const bufferedPush = (item: SSRBufferItem) => {\n      slotBuffer.push(item)\n    }\n    const ret = slotFn(\n      slotProps,\n      bufferedPush,\n      parentComponent,\n      slotScopeId ? ' ' + slotScopeId : ''\n    )\n    if (isArray(ret)) {\n      // normal slot\n      renderVNodeChildren(push, ret, parentComponent, slotScopeId)\n    } else {\n      // ssr slot.\n      // check if the slot renders all comments, in which case use the fallback\n      let isEmptySlot = true\n      if (transition) {\n        isEmptySlot = false\n      } else {\n        for (let i = 0; i < slotBuffer.length; i++) {\n          if (!isComment(slotBuffer[i])) {\n            isEmptySlot = false\n            break\n          }\n        }\n      }\n      if (isEmptySlot) {\n        if (fallbackRenderFn) {\n          fallbackRenderFn()\n        }\n      } else {\n        for (let i = 0; i < slotBuffer.length; i++) {\n          push(slotBuffer[i])\n        }\n      }\n    }\n  } else if (fallbackRenderFn) {\n    fallbackRenderFn()\n  }\n}\n\nconst commentTestRE = /^<!--.*-->$/s\nconst commentRE = /<!--[^]*?-->/gm\nfunction isComment(item: SSRBufferItem) {\n  if (typeof item !== 'string' || !commentTestRE.test(item)) return false\n  // if item is '<!---->' or '<!--[-->' or '<!--]-->', return true directly\n  if (item.length <= 8) return true\n  return !item.replace(commentRE, '').trim()\n}\n","import { escapeHtml, toDisplayString } from '@vue/shared'\n\nexport function ssrInterpolate(value: unknown): string {\n  return escapeHtml(toDisplayString(value))\n}\n","import { isObject, toRawType, def } from '@vue/shared'\nimport {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReactiveHandlers,\n  shallowReadonlyHandlers\n} from './baseHandlers'\nimport {\n  mutableCollectionHandlers,\n  readonlyCollectionHandlers,\n  shallowCollectionHandlers,\n  shallowReadonlyCollectionHandlers\n} from './collectionHandlers'\nimport type { UnwrapRefSimple, Ref, RawSymbol } from './ref'\n\nexport const enum ReactiveFlags {\n  SKIP = '__v_skip',\n  IS_REACTIVE = '__v_isReactive',\n  IS_READONLY = '__v_isReadonly',\n  IS_SHALLOW = '__v_isShallow',\n  RAW = '__v_raw'\n}\n\nexport interface Target {\n  [ReactiveFlags.SKIP]?: boolean\n  [ReactiveFlags.IS_REACTIVE]?: boolean\n  [ReactiveFlags.IS_READONLY]?: boolean\n  [ReactiveFlags.IS_SHALLOW]?: boolean\n  [ReactiveFlags.RAW]?: any\n}\n\nexport const reactiveMap = new WeakMap<Target, any>()\nexport const shallowReactiveMap = new WeakMap<Target, any>()\nexport const readonlyMap = new WeakMap<Target, any>()\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\n\nconst enum TargetType {\n  INVALID = 0,\n  COMMON = 1,\n  COLLECTION = 2\n}\n\nfunction targetTypeMap(rawType: string) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n\nfunction getTargetType(value: Target) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\n// only unwrap nested ref\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\n\n/**\n * Creates a reactive copy of the original object.\n *\n * The reactive conversion is \"deep\"â€”it affects all nested properties. In the\n * ES2015 Proxy based implementation, the returned proxy is **not** equal to the\n * original object. It is recommended to work exclusively with the reactive\n * proxy and avoid relying on the original object.\n *\n * A reactive object also automatically unwraps refs contained in it, so you\n * don't need to use `.value` when accessing and mutating their value:\n *\n * ```js\n * const count = ref(0)\n * const obj = reactive({\n *   count\n * })\n *\n * obj.count++\n * obj.count // -> 1\n * count.value // -> 1\n * ```\n */\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n\nexport declare const ShallowReactiveMarker: unique symbol\n\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\n\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nexport function shallowReactive<T extends object>(\n  target: T\n): ShallowReactive<T> {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  )\n}\n\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\ntype Builtin = Primitive | Function | Date | Error | RegExp\nexport type DeepReadonly<T> = T extends Builtin\n  ? T\n  : T extends Map<infer K, infer V>\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends ReadonlyMap<infer K, infer V>\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends WeakMap<infer K, infer V>\n  ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends Set<infer U>\n  ? ReadonlySet<DeepReadonly<U>>\n  : T extends ReadonlySet<infer U>\n  ? ReadonlySet<DeepReadonly<U>>\n  : T extends WeakSet<infer U>\n  ? WeakSet<DeepReadonly<U>>\n  : T extends Promise<infer U>\n  ? Promise<DeepReadonly<U>>\n  : T extends Ref<infer U>\n  ? Readonly<Ref<DeepReadonly<U>>>\n  : T extends {}\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : Readonly<T>\n\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nexport function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>> {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  )\n}\n\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  )\n}\n\nfunction createReactiveObject(\n  target: Target,\n  isReadonly: boolean,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>,\n  proxyMap: WeakMap<Target, any>\n) {\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // target already has corresponding Proxy\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // only specific value types can be observed.\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  proxyMap.set(target, proxy)\n  return proxy\n}\n\nexport function isReactive(value: unknown): boolean {\n  if (isReadonly(value)) {\n    return isReactive((value as Target)[ReactiveFlags.RAW])\n  }\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\n}\n\nexport function isReadonly(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\n}\n\nexport function isShallow(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\n}\n\nexport function isProxy(value: unknown): boolean {\n  return isReactive(value) || isReadonly(value)\n}\n\nexport function toRaw<T>(observed: T): T {\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\n  return raw ? toRaw(raw) : observed\n}\n\nexport function markRaw<T extends object>(\n  value: T\n): T & { [RawSymbol]?: true } {\n  def(value, ReactiveFlags.SKIP, true)\n  return value\n}\n\nexport const toReactive = <T extends unknown>(value: T): T =>\n  isObject(value) ? reactive(value) : value\n\nexport const toReadonly = <T extends unknown>(value: T): T =>\n  isObject(value) ? readonly(value as Record<any, any>) : value\n","import {\n  activeEffect,\n  shouldTrack,\n  trackEffects,\n  triggerEffects\n} from './effect'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { isArray, hasChanged, IfAny } from '@vue/shared'\nimport {\n  isProxy,\n  toRaw,\n  isReactive,\n  toReactive,\n  isReadonly,\n  isShallow\n} from './reactive'\nimport type { ShallowReactiveMarker } from './reactive'\nimport { CollectionTypes } from './collectionHandlers'\nimport { createDep, Dep } from './dep'\n\ndeclare const RefSymbol: unique symbol\nexport declare const RawSymbol: unique symbol\n\nexport interface Ref<T = any> {\n  value: T\n  /**\n   * Type differentiator only.\n   * We need this to be in public d.ts but don't want it to show up in IDE\n   * autocomplete, so we use a private Symbol instead.\n   */\n  [RefSymbol]: true\n}\n\ntype RefBase<T> = {\n  dep?: Dep\n  value: T\n}\n\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    if (__DEV__) {\n      trackEffects(ref.dep || (ref.dep = createDep()), {\n        target: ref,\n        type: TrackOpTypes.GET,\n        key: 'value'\n      })\n    } else {\n      trackEffects(ref.dep || (ref.dep = createDep()))\n    }\n  }\n}\n\nexport function triggerRefValue(ref: RefBase<any>, newVal?: any) {\n  ref = toRaw(ref)\n  if (ref.dep) {\n    if (__DEV__) {\n      triggerEffects(ref.dep, {\n        target: ref,\n        type: TriggerOpTypes.SET,\n        key: 'value',\n        newValue: newVal\n      })\n    } else {\n      triggerEffects(ref.dep)\n    }\n  }\n}\n\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\nexport function isRef(r: any): r is Ref {\n  return !!(r && r.__v_isRef === true)\n}\n\nexport function ref<T extends object>(\n  value: T\n): [T] extends [Ref] ? T : Ref<UnwrapRef<T>>\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n\ndeclare const ShallowRefMarker: unique symbol\n\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\n\nexport function shallowRef<T extends object>(\n  value: T\n): T extends Ref ? T : ShallowRef<T>\nexport function shallowRef<T>(value: T): ShallowRef<T>\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\nexport function shallowRef(value?: unknown) {\n  return createRef(value, true)\n}\n\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(value: T, public readonly __v_isShallow: boolean) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, newVal)\n    }\n  }\n}\n\nexport function triggerRef(ref: Ref) {\n  triggerRefValue(ref, __DEV__ ? ref.value : void 0)\n}\n\nexport function unref<T>(ref: T | Ref<T>): T {\n  return isRef(ref) ? (ref.value as any) : ref\n}\n\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key]\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value\n      return true\n    } else {\n      return Reflect.set(target, key, value, receiver)\n    }\n  }\n}\n\nexport function proxyRefs<T extends object>(\n  objectWithRefs: T\n): ShallowUnwrapRef<T> {\n  return isReactive(objectWithRefs)\n    ? objectWithRefs\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\n}\n\nexport type CustomRefFactory<T> = (\n  track: () => void,\n  trigger: () => void\n) => {\n  get: () => T\n  set: (value: T) => void\n}\n\nclass CustomRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\n\n  public readonly __v_isRef = true\n\n  constructor(factory: CustomRefFactory<T>) {\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newVal) {\n    this._set(newVal)\n  }\n}\n\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\n  return new CustomRefImpl(factory) as any\n}\n\nexport type ToRefs<T = any> = {\n  [K in keyof T]: ToRef<T[K]>\n}\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\n  if (__DEV__ && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\n  }\n  const ret: any = isArray(object) ? new Array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toRef(object, key)\n  }\n  return ret\n}\n\nclass ObjectRefImpl<T extends object, K extends keyof T> {\n  public readonly __v_isRef = true\n\n  constructor(\n    private readonly _object: T,\n    private readonly _key: K,\n    private readonly _defaultValue?: T[K]\n  ) {}\n\n  get value() {\n    const val = this._object[this._key]\n    return val === undefined ? (this._defaultValue as T[K]) : val\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal\n  }\n}\n\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): ToRef<T[K]>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  defaultValue: T[K]\n): ToRef<Exclude<T[K], undefined>>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  defaultValue?: T[K]\n): ToRef<T[K]> {\n  const val = object[key]\n  return isRef(val)\n    ? val\n    : (new ObjectRefImpl(object, key, defaultValue) as any)\n}\n\n// corner case when use narrows type\n// Ex. type RelativePath = string & { __brand: unknown }\n// RelativePath extends object -> true\ntype BaseTypes = string | number | boolean\n\n/**\n * This is a special exported interface for other packages to declare\n * additional types that should bail out for ref unwrapping. For example\n * \\@vue/runtime-dom can declare it like so in its d.ts:\n *\n * ``` ts\n * declare module '@vue/reactivity' {\n *   export interface RefUnwrapBailTypes {\n *     runtimeDOMBailTypes: Node | Window\n *   }\n * }\n * ```\n *\n * Note that api-extractor somehow refuses to include `declare module`\n * augmentations in its generated d.ts, so we have to manually append them\n * to the final generated d.ts in our build process.\n */\nexport interface RefUnwrapBailTypes {}\n\nexport type ShallowUnwrapRef<T> = {\n  [K in keyof T]: T[K] extends Ref<infer V>\n    ? V\n    : // if `V` is `unknown` that means it does not extend `Ref` and is undefined\n    T[K] extends Ref<infer V> | undefined\n    ? unknown extends V\n      ? undefined\n      : V | undefined\n    : T[K]\n}\n\nexport type UnwrapRef<T> = T extends ShallowRef<infer V>\n  ? V\n  : T extends Ref<infer V>\n  ? UnwrapRefSimple<V>\n  : UnwrapRefSimple<T>\n\nexport type UnwrapRefSimple<T> = T extends\n  | Function\n  | CollectionTypes\n  | BaseTypes\n  | Ref\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\n  | { [RawSymbol]?: true }\n  ? T\n  : T extends Array<any>\n  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\n  : T extends object & { [ShallowReactiveMarker]?: never }\n  ? {\n      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\n    }\n  : T\n","import { VNode } from './vnode'\nimport {\n  Data,\n  ComponentInternalInstance,\n  ConcreteComponent,\n  formatComponentName\n} from './component'\nimport { isString, isFunction } from '@vue/shared'\nimport { toRaw, isRef, pauseTracking, resetTracking } from '@vue/reactivity'\nimport { callWithErrorHandling, ErrorCodes } from './errorHandling'\n\ntype ComponentVNode = VNode & {\n  type: ConcreteComponent\n}\n\nconst stack: VNode[] = []\n\ntype TraceEntry = {\n  vnode: ComponentVNode\n  recurseCount: number\n}\n\ntype ComponentTraceStack = TraceEntry[]\n\nexport function pushWarningContext(vnode: VNode) {\n  stack.push(vnode)\n}\n\nexport function popWarningContext() {\n  stack.pop()\n}\n\nexport function warn(msg: string, ...args: any[]) {\n  // avoid props formatting or warn handler tracking deps that might be mutated\n  // during patch, leading to infinite recursion.\n  pauseTracking()\n\n  const instance = stack.length ? stack[stack.length - 1].component : null\n  const appWarnHandler = instance && instance.appContext.config.warnHandler\n  const trace = getComponentTrace()\n\n  if (appWarnHandler) {\n    callWithErrorHandling(\n      appWarnHandler,\n      instance,\n      ErrorCodes.APP_WARN_HANDLER,\n      [\n        msg + args.join(''),\n        instance && instance.proxy,\n        trace\n          .map(\n            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`\n          )\n          .join('\\n'),\n        trace\n      ]\n    )\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args]\n    /* istanbul ignore if */\n    if (\n      trace.length &&\n      // avoid spamming console during tests\n      !__TEST__\n    ) {\n      warnArgs.push(`\\n`, ...formatTrace(trace))\n    }\n    console.warn(...warnArgs)\n  }\n\n  resetTracking()\n}\n\nexport function getComponentTrace(): ComponentTraceStack {\n  let currentVNode: VNode | null = stack[stack.length - 1]\n  if (!currentVNode) {\n    return []\n  }\n\n  // we can't just use the stack because it will be incomplete during updates\n  // that did not start from the root. Re-construct the parent chain using\n  // instance parent pointers.\n  const normalizedStack: ComponentTraceStack = []\n\n  while (currentVNode) {\n    const last = normalizedStack[0]\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode as ComponentVNode,\n        recurseCount: 0\n      })\n    }\n    const parentInstance: ComponentInternalInstance | null =\n      currentVNode.component && currentVNode.component.parent\n    currentVNode = parentInstance && parentInstance.vnode\n  }\n\n  return normalizedStack\n}\n\n/* istanbul ignore next */\nfunction formatTrace(trace: ComponentTraceStack): any[] {\n  const logs: any[] = []\n  trace.forEach((entry, i) => {\n    logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry))\n  })\n  return logs\n}\n\nfunction formatTraceEntry({ vnode, recurseCount }: TraceEntry): any[] {\n  const postfix =\n    recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``\n  const isRoot = vnode.component ? vnode.component.parent == null : false\n  const open = ` at <${formatComponentName(\n    vnode.component,\n    vnode.type,\n    isRoot\n  )}`\n  const close = `>` + postfix\n  return vnode.props\n    ? [open, ...formatProps(vnode.props), close]\n    : [open + close]\n}\n\n/* istanbul ignore next */\nfunction formatProps(props: Data): any[] {\n  const res: any[] = []\n  const keys = Object.keys(props)\n  keys.slice(0, 3).forEach(key => {\n    res.push(...formatProp(key, props[key]))\n  })\n  if (keys.length > 3) {\n    res.push(` ...`)\n  }\n  return res\n}\n\nfunction formatProp(key: string, value: unknown): any[]\nfunction formatProp(key: string, value: unknown, raw: true): any\n/* istanbul ignore next */\nfunction formatProp(key: string, value: unknown, raw?: boolean): any {\n  if (isString(value)) {\n    value = JSON.stringify(value)\n    return raw ? value : [`${key}=${value}`]\n  } else if (\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    value == null\n  ) {\n    return raw ? value : [`${key}=${value}`]\n  } else if (isRef(value)) {\n    value = formatProp(key, toRaw(value.value), true)\n    return raw ? value : [`${key}=Ref<`, value, `>`]\n  } else if (isFunction(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`]\n  } else {\n    value = toRaw(value)\n    return raw ? value : [`${key}=`, value]\n  }\n}\n","import { VNode } from './vnode'\nimport { ComponentInternalInstance, LifecycleHooks } from './component'\nimport { warn, pushWarningContext, popWarningContext } from './warning'\nimport { isPromise, isFunction } from '@vue/shared'\n\n// contexts where user provided function may be executed, in addition to\n// lifecycle hooks.\nexport const enum ErrorCodes {\n  SETUP_FUNCTION,\n  RENDER_FUNCTION,\n  WATCH_GETTER,\n  WATCH_CALLBACK,\n  WATCH_CLEANUP,\n  NATIVE_EVENT_HANDLER,\n  COMPONENT_EVENT_HANDLER,\n  VNODE_HOOK,\n  DIRECTIVE_HOOK,\n  TRANSITION_HOOK,\n  APP_ERROR_HANDLER,\n  APP_WARN_HANDLER,\n  FUNCTION_REF,\n  ASYNC_COMPONENT_LOADER,\n  SCHEDULER\n}\n\nexport const ErrorTypeStrings: Record<number | string, string> = {\n  [LifecycleHooks.SERVER_PREFETCH]: 'serverPrefetch hook',\n  [LifecycleHooks.BEFORE_CREATE]: 'beforeCreate hook',\n  [LifecycleHooks.CREATED]: 'created hook',\n  [LifecycleHooks.BEFORE_MOUNT]: 'beforeMount hook',\n  [LifecycleHooks.MOUNTED]: 'mounted hook',\n  [LifecycleHooks.BEFORE_UPDATE]: 'beforeUpdate hook',\n  [LifecycleHooks.UPDATED]: 'updated',\n  [LifecycleHooks.BEFORE_UNMOUNT]: 'beforeUnmount hook',\n  [LifecycleHooks.UNMOUNTED]: 'unmounted hook',\n  [LifecycleHooks.ACTIVATED]: 'activated hook',\n  [LifecycleHooks.DEACTIVATED]: 'deactivated hook',\n  [LifecycleHooks.ERROR_CAPTURED]: 'errorCaptured hook',\n  [LifecycleHooks.RENDER_TRACKED]: 'renderTracked hook',\n  [LifecycleHooks.RENDER_TRIGGERED]: 'renderTriggered hook',\n  [ErrorCodes.SETUP_FUNCTION]: 'setup function',\n  [ErrorCodes.RENDER_FUNCTION]: 'render function',\n  [ErrorCodes.WATCH_GETTER]: 'watcher getter',\n  [ErrorCodes.WATCH_CALLBACK]: 'watcher callback',\n  [ErrorCodes.WATCH_CLEANUP]: 'watcher cleanup function',\n  [ErrorCodes.NATIVE_EVENT_HANDLER]: 'native event handler',\n  [ErrorCodes.COMPONENT_EVENT_HANDLER]: 'component event handler',\n  [ErrorCodes.VNODE_HOOK]: 'vnode hook',\n  [ErrorCodes.DIRECTIVE_HOOK]: 'directive hook',\n  [ErrorCodes.TRANSITION_HOOK]: 'transition hook',\n  [ErrorCodes.APP_ERROR_HANDLER]: 'app errorHandler',\n  [ErrorCodes.APP_WARN_HANDLER]: 'app warnHandler',\n  [ErrorCodes.FUNCTION_REF]: 'ref function',\n  [ErrorCodes.ASYNC_COMPONENT_LOADER]: 'async component loader',\n  [ErrorCodes.SCHEDULER]:\n    'scheduler flush. This is likely a Vue internals bug. ' +\n    'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\n}\n\nexport type ErrorTypes = LifecycleHooks | ErrorCodes\n\nexport function callWithErrorHandling(\n  fn: Function,\n  instance: ComponentInternalInstance | null,\n  type: ErrorTypes,\n  args?: unknown[]\n) {\n  let res\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    handleError(err, instance, type)\n  }\n  return res\n}\n\nexport function callWithAsyncErrorHandling(\n  fn: Function | Function[],\n  instance: ComponentInternalInstance | null,\n  type: ErrorTypes,\n  args?: unknown[]\n): any[] {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args)\n    if (res && isPromise(res)) {\n      res.catch(err => {\n        handleError(err, instance, type)\n      })\n    }\n    return res\n  }\n\n  const values = []\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args))\n  }\n  return values\n}\n\nexport function handleError(\n  err: unknown,\n  instance: ComponentInternalInstance | null,\n  type: ErrorTypes,\n  throwInDev = true\n) {\n  const contextVNode = instance ? instance.vnode : null\n  if (instance) {\n    let cur = instance.parent\n    // the exposed instance is the render proxy to keep it consistent with 2.x\n    const exposedInstance = instance.proxy\n    // in production the hook receives only the error code\n    const errorInfo = __DEV__ ? ErrorTypeStrings[type] : type\n    while (cur) {\n      const errorCapturedHooks = cur.ec\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (\n            errorCapturedHooks[i](err, exposedInstance, errorInfo) === false\n          ) {\n            return\n          }\n        }\n      }\n      cur = cur.parent\n    }\n    // app-level handling\n    const appErrorHandler = instance.appContext.config.errorHandler\n    if (appErrorHandler) {\n      callWithErrorHandling(\n        appErrorHandler,\n        null,\n        ErrorCodes.APP_ERROR_HANDLER,\n        [err, exposedInstance, errorInfo]\n      )\n      return\n    }\n  }\n  logError(err, type, contextVNode, throwInDev)\n}\n\nfunction logError(\n  err: unknown,\n  type: ErrorTypes,\n  contextVNode: VNode | null,\n  throwInDev = true\n) {\n  if (__DEV__) {\n    const info = ErrorTypeStrings[type]\n    if (contextVNode) {\n      pushWarningContext(contextVNode)\n    }\n    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`)\n    if (contextVNode) {\n      popWarningContext()\n    }\n    // crash in dev by default so it's more noticeable\n    if (throwInDev) {\n      throw err\n    } else if (!__TEST__) {\n      console.error(err)\n    }\n  } else {\n    // recover in prod to reduce the impact on end-user\n    console.error(err)\n  }\n}\n","import { VNode, VNodeChild, isVNode } from './vnode'\nimport {\n  pauseTracking,\n  resetTracking,\n  shallowReadonly,\n  proxyRefs,\n  EffectScope,\n  markRaw,\n  track,\n  TrackOpTypes,\n  ReactiveEffect\n} from '@vue/reactivity'\nimport {\n  ComponentPublicInstance,\n  PublicInstanceProxyHandlers,\n  createDevRenderContext,\n  exposePropsOnRenderContext,\n  exposeSetupStateOnRenderContext,\n  ComponentPublicInstanceConstructor,\n  publicPropertiesMap,\n  RuntimeCompiledPublicInstanceProxyHandlers\n} from './componentPublicInstance'\nimport {\n  ComponentPropsOptions,\n  NormalizedPropsOptions,\n  initProps,\n  normalizePropsOptions\n} from './componentProps'\nimport { Slots, initSlots, InternalSlots } from './componentSlots'\nimport { warn } from './warning'\nimport { ErrorCodes, callWithErrorHandling, handleError } from './errorHandling'\nimport { AppContext, createAppContext, AppConfig } from './apiCreateApp'\nimport { Directive, validateDirectiveName } from './directives'\nimport {\n  applyOptions,\n  ComponentOptions,\n  ComputedOptions,\n  MethodOptions\n} from './componentOptions'\nimport {\n  EmitsOptions,\n  ObjectEmitsOptions,\n  EmitFn,\n  emit,\n  normalizeEmitsOptions\n} from './componentEmits'\nimport {\n  EMPTY_OBJ,\n  isFunction,\n  NOOP,\n  isObject,\n  NO,\n  makeMap,\n  isPromise,\n  ShapeFlags,\n  extend\n} from '@vue/shared'\nimport { SuspenseBoundary } from './components/Suspense'\nimport { CompilerOptions } from '@vue/compiler-core'\nimport { markAttrsAccessed } from './componentRenderUtils'\nimport { currentRenderingInstance } from './componentRenderContext'\nimport { startMeasure, endMeasure } from './profiling'\nimport { convertLegacyRenderFn } from './compat/renderFn'\nimport {\n  CompatConfig,\n  globalCompatConfig,\n  validateCompatConfig\n} from './compat/compatConfig'\nimport { SchedulerJob } from './scheduler'\n\nexport type Data = Record<string, unknown>\n\n/**\n * For extending allowed non-declared props on components in TSX\n */\nexport interface ComponentCustomProps {}\n\n/**\n * Default allowed non-declared props on component in TSX\n */\nexport interface AllowedComponentProps {\n  class?: unknown\n  style?: unknown\n}\n\n// Note: can't mark this whole interface internal because some public interfaces\n// extend it.\nexport interface ComponentInternalOptions {\n  /**\n   * @internal\n   */\n  __scopeId?: string\n  /**\n   * @internal\n   */\n  __cssModules?: Data\n  /**\n   * @internal\n   */\n  __hmrId?: string\n  /**\n   * Compat build only, for bailing out of certain compatibility behavior\n   */\n  __isBuiltIn?: boolean\n  /**\n   * This one should be exposed so that devtools can make use of it\n   */\n  __file?: string\n  /**\n   * name inferred from filename\n   */\n  __name?: string\n}\n\nexport interface FunctionalComponent<P = {}, E extends EmitsOptions = {}>\n  extends ComponentInternalOptions {\n  // use of any here is intentional so it can be a valid JSX Element constructor\n  (props: P, ctx: Omit<SetupContext<E>, 'expose'>): any\n  props?: ComponentPropsOptions<P>\n  emits?: E | (keyof E)[]\n  inheritAttrs?: boolean\n  displayName?: string\n  compatConfig?: CompatConfig\n}\n\nexport interface ClassComponent {\n  new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>\n  __vccOpts: ComponentOptions\n}\n\n/**\n * Concrete component type matches its actual value: it's either an options\n * object, or a function. Use this where the code expects to work with actual\n * values, e.g. checking if its a function or not. This is mostly for internal\n * implementation code.\n */\nexport type ConcreteComponent<\n  Props = {},\n  RawBindings = any,\n  D = any,\n  C extends ComputedOptions = ComputedOptions,\n  M extends MethodOptions = MethodOptions\n> =\n  | ComponentOptions<Props, RawBindings, D, C, M>\n  | FunctionalComponent<Props, any>\n\n/**\n * A type used in public APIs where a component type is expected.\n * The constructor type is an artificial type returned by defineComponent().\n */\nexport type Component<\n  Props = any,\n  RawBindings = any,\n  D = any,\n  C extends ComputedOptions = ComputedOptions,\n  M extends MethodOptions = MethodOptions\n> =\n  | ConcreteComponent<Props, RawBindings, D, C, M>\n  | ComponentPublicInstanceConstructor<Props>\n\nexport { ComponentOptions }\n\ntype LifecycleHook<TFn = Function> = TFn[] | null\n\nexport const enum LifecycleHooks {\n  BEFORE_CREATE = 'bc',\n  CREATED = 'c',\n  BEFORE_MOUNT = 'bm',\n  MOUNTED = 'm',\n  BEFORE_UPDATE = 'bu',\n  UPDATED = 'u',\n  BEFORE_UNMOUNT = 'bum',\n  UNMOUNTED = 'um',\n  DEACTIVATED = 'da',\n  ACTIVATED = 'a',\n  RENDER_TRIGGERED = 'rtg',\n  RENDER_TRACKED = 'rtc',\n  ERROR_CAPTURED = 'ec',\n  SERVER_PREFETCH = 'sp'\n}\n\nexport interface SetupContext<E = EmitsOptions> {\n  attrs: Data\n  slots: Slots\n  emit: EmitFn<E>\n  expose: (exposed?: Record<string, any>) => void\n}\n\n/**\n * @internal\n */\nexport type InternalRenderFunction = {\n  (\n    ctx: ComponentPublicInstance,\n    cache: ComponentInternalInstance['renderCache'],\n    // for compiler-optimized bindings\n    $props: ComponentInternalInstance['props'],\n    $setup: ComponentInternalInstance['setupState'],\n    $data: ComponentInternalInstance['data'],\n    $options: ComponentInternalInstance['ctx']\n  ): VNodeChild\n  _rc?: boolean // isRuntimeCompiled\n\n  // __COMPAT__ only\n  _compatChecked?: boolean // v3 and already checked for v2 compat\n  _compatWrapped?: boolean // is wrapped for v2 compat\n}\n\n/**\n * We expose a subset of properties on the internal instance as they are\n * useful for advanced external libraries and tools.\n */\nexport interface ComponentInternalInstance {\n  uid: number\n  type: ConcreteComponent\n  parent: ComponentInternalInstance | null\n  root: ComponentInternalInstance\n  appContext: AppContext\n  /**\n   * Vnode representing this component in its parent's vdom tree\n   */\n  vnode: VNode\n  /**\n   * The pending new vnode from parent updates\n   * @internal\n   */\n  next: VNode | null\n  /**\n   * Root vnode of this component's own vdom tree\n   */\n  subTree: VNode\n  /**\n   * Render effect instance\n   */\n  effect: ReactiveEffect\n  /**\n   * Bound effect runner to be passed to schedulers\n   */\n  update: SchedulerJob\n  /**\n   * The render function that returns vdom tree.\n   * @internal\n   */\n  render: InternalRenderFunction | null\n  /**\n   * SSR render function\n   * @internal\n   */\n  ssrRender?: Function | null\n  /**\n   * Object containing values this component provides for its descendents\n   * @internal\n   */\n  provides: Data\n  /**\n   * Tracking reactive effects (e.g. watchers) associated with this component\n   * so that they can be automatically stopped on component unmount\n   * @internal\n   */\n  scope: EffectScope\n  /**\n   * cache for proxy access type to avoid hasOwnProperty calls\n   * @internal\n   */\n  accessCache: Data | null\n  /**\n   * cache for render function values that rely on _ctx but won't need updates\n   * after initialized (e.g. inline handlers)\n   * @internal\n   */\n  renderCache: (Function | VNode)[]\n\n  /**\n   * Resolved component registry, only for components with mixins or extends\n   * @internal\n   */\n  components: Record<string, ConcreteComponent> | null\n  /**\n   * Resolved directive registry, only for components with mixins or extends\n   * @internal\n   */\n  directives: Record<string, Directive> | null\n  /**\n   * Resolved filters registry, v2 compat only\n   * @internal\n   */\n  filters?: Record<string, Function>\n  /**\n   * resolved props options\n   * @internal\n   */\n  propsOptions: NormalizedPropsOptions\n  /**\n   * resolved emits options\n   * @internal\n   */\n  emitsOptions: ObjectEmitsOptions | null\n  /**\n   * resolved inheritAttrs options\n   * @internal\n   */\n  inheritAttrs?: boolean\n  /**\n   * is custom element?\n   */\n  isCE?: boolean\n  /**\n   * custom element specific HMR method\n   */\n  ceReload?: (newStyles?: string[]) => void\n\n  // the rest are only for stateful components ---------------------------------\n\n  // main proxy that serves as the public instance (`this`)\n  proxy: ComponentPublicInstance | null\n\n  // exposed properties via expose()\n  exposed: Record<string, any> | null\n  exposeProxy: Record<string, any> | null\n\n  /**\n   * alternative proxy used only for runtime-compiled render functions using\n   * `with` block\n   * @internal\n   */\n  withProxy: ComponentPublicInstance | null\n  /**\n   * This is the target for the public instance proxy. It also holds properties\n   * injected by user options (computed, methods etc.) and user-attached\n   * custom properties (via `this.x = ...`)\n   * @internal\n   */\n  ctx: Data\n\n  // state\n  data: Data\n  props: Data\n  attrs: Data\n  slots: InternalSlots\n  refs: Data\n  emit: EmitFn\n  /**\n   * used for keeping track of .once event handlers on components\n   * @internal\n   */\n  emitted: Record<string, boolean> | null\n  /**\n   * used for caching the value returned from props default factory functions to\n   * avoid unnecessary watcher trigger\n   * @internal\n   */\n  propsDefaults: Data\n  /**\n   * setup related\n   * @internal\n   */\n  setupState: Data\n  /**\n   * devtools access to additional info\n   * @internal\n   */\n  devtoolsRawSetupState?: any\n  /**\n   * @internal\n   */\n  setupContext: SetupContext | null\n\n  /**\n   * suspense related\n   * @internal\n   */\n  suspense: SuspenseBoundary | null\n  /**\n   * suspense pending batch id\n   * @internal\n   */\n  suspenseId: number\n  /**\n   * @internal\n   */\n  asyncDep: Promise<any> | null\n  /**\n   * @internal\n   */\n  asyncResolved: boolean\n\n  // lifecycle\n  isMounted: boolean\n  isUnmounted: boolean\n  isDeactivated: boolean\n  /**\n   * @internal\n   */\n  [LifecycleHooks.BEFORE_CREATE]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.CREATED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.MOUNTED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.UPDATED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.UNMOUNTED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.RENDER_TRACKED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.ACTIVATED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.DEACTIVATED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.SERVER_PREFETCH]: LifecycleHook<() => Promise<unknown>>\n\n  /**\n   * For caching bound $forceUpdate on public proxy access\n   */\n  f?: () => void\n  /**\n   * For caching bound $nextTick on public proxy access\n   */\n  n?: () => Promise<void>\n}\n\nconst emptyAppContext = createAppContext()\n\nlet uid = 0\n\nexport function createComponentInstance(\n  vnode: VNode,\n  parent: ComponentInternalInstance | null,\n  suspense: SuspenseBoundary | null\n) {\n  const type = vnode.type as ConcreteComponent\n  // inherit parent app context - or - if root, adopt from root vnode\n  const appContext =\n    (parent ? parent.appContext : vnode.appContext) || emptyAppContext\n\n  const instance: ComponentInternalInstance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null!, // to be immediately set\n    next: null,\n    subTree: null!, // will be set synchronously right after creation\n    effect: null!,\n    update: null!, // will be set synchronously right after creation\n    scope: new EffectScope(true /* detached */),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null!,\n    renderCache: [],\n\n    // local resolved assets\n    components: null,\n    directives: null,\n\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n\n    // emit\n    emit: null!, // to be set immediately\n    emitted: null,\n\n    // props default value\n    propsDefaults: EMPTY_OBJ,\n\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n\n    // state\n    ctx: EMPTY_OBJ,\n    data: EMPTY_OBJ,\n    props: EMPTY_OBJ,\n    attrs: EMPTY_OBJ,\n    slots: EMPTY_OBJ,\n    refs: EMPTY_OBJ,\n    setupState: EMPTY_OBJ,\n    setupContext: null,\n\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  }\n  if (__DEV__) {\n    instance.ctx = createDevRenderContext(instance)\n  } else {\n    instance.ctx = { _: instance }\n  }\n  instance.root = parent ? parent.root : instance\n  instance.emit = emit.bind(null, instance)\n\n  // apply custom element special handling\n  if (vnode.ce) {\n    vnode.ce(instance)\n  }\n\n  return instance\n}\n\nexport let currentInstance: ComponentInternalInstance | null = null\n\nexport const getCurrentInstance: () => ComponentInternalInstance | null = () =>\n  currentInstance || currentRenderingInstance\n\nexport const setCurrentInstance = (instance: ComponentInternalInstance) => {\n  currentInstance = instance\n  instance.scope.on()\n}\n\nexport const unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off()\n  currentInstance = null\n}\n\nconst isBuiltInTag = /*#__PURE__*/ makeMap('slot,component')\n\nexport function validateComponentName(name: string, config: AppConfig) {\n  const appIsNativeTag = config.isNativeTag || NO\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component id: ' + name\n    )\n  }\n}\n\nexport function isStatefulComponent(instance: ComponentInternalInstance) {\n  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\n}\n\nexport let isInSSRComponentSetup = false\n\nexport function setupComponent(\n  instance: ComponentInternalInstance,\n  isSSR = false\n) {\n  isInSSRComponentSetup = isSSR\n\n  const { props, children } = instance.vnode\n  const isStateful = isStatefulComponent(instance)\n  initProps(instance, props, isStateful, isSSR)\n  initSlots(instance, children)\n\n  const setupResult = isStateful\n    ? setupStatefulComponent(instance, isSSR)\n    : undefined\n  isInSSRComponentSetup = false\n  return setupResult\n}\n\nfunction setupStatefulComponent(\n  instance: ComponentInternalInstance,\n  isSSR: boolean\n) {\n  const Component = instance.type as ComponentOptions\n\n  if (__DEV__) {\n    if (Component.name) {\n      validateComponentName(Component.name, instance.appContext.config)\n    }\n    if (Component.components) {\n      const names = Object.keys(Component.components)\n      for (let i = 0; i < names.length; i++) {\n        validateComponentName(names[i], instance.appContext.config)\n      }\n    }\n    if (Component.directives) {\n      const names = Object.keys(Component.directives)\n      for (let i = 0; i < names.length; i++) {\n        validateDirectiveName(names[i])\n      }\n    }\n    if (Component.compilerOptions && isRuntimeOnly()) {\n      warn(\n        `\"compilerOptions\" is only supported when using a build of Vue that ` +\n          `includes the runtime compiler. Since you are using a runtime-only ` +\n          `build, the options should be passed via your build tool config instead.`\n      )\n    }\n  }\n  // 0. create render proxy property access cache\n  instance.accessCache = Object.create(null)\n  // 1. create public instance / render proxy\n  // also mark it raw so it's never observed\n  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))\n  if (__DEV__) {\n    exposePropsOnRenderContext(instance)\n  }\n  // 2. call setup()\n  const { setup } = Component\n  if (setup) {\n    const setupContext = (instance.setupContext =\n      setup.length > 1 ? createSetupContext(instance) : null)\n\n    setCurrentInstance(instance)\n    pauseTracking()\n    const setupResult = callWithErrorHandling(\n      setup,\n      instance,\n      ErrorCodes.SETUP_FUNCTION,\n      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext]\n    )\n    resetTracking()\n    unsetCurrentInstance()\n\n    if (isPromise(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)\n      if (isSSR) {\n        // return the promise so server-renderer can wait on it\n        return setupResult\n          .then((resolvedResult: unknown) => {\n            handleSetupResult(instance, resolvedResult, isSSR)\n          })\n          .catch(e => {\n            handleError(e, instance, ErrorCodes.SETUP_FUNCTION)\n          })\n      } else if (__FEATURE_SUSPENSE__) {\n        // async setup returned Promise.\n        // bail here and wait for re-entry.\n        instance.asyncDep = setupResult\n        if (__DEV__ && !instance.suspense) {\n          const name = Component.name ?? 'Anonymous'\n          warn(\n            `Component <${name}>: setup function returned a promise, but no ` +\n              `<Suspense> boundary was found in the parent component tree. ` +\n              `A component with async setup() must be nested in a <Suspense> ` +\n              `in order to be rendered.`\n          )\n        }\n      } else if (__DEV__) {\n        warn(\n          `setup() returned a Promise, but the version of Vue you are using ` +\n            `does not support it yet.`\n        )\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR)\n    }\n  } else {\n    finishComponentSetup(instance, isSSR)\n  }\n}\n\nexport function handleSetupResult(\n  instance: ComponentInternalInstance,\n  setupResult: unknown,\n  isSSR: boolean\n) {\n  if (isFunction(setupResult)) {\n    // setup returned an inline render function\n    if (__SSR__ && (instance.type as ComponentOptions).__ssrInlineRender) {\n      // when the function's name is `ssrRender` (compiled by SFC inline mode),\n      // set it as ssrRender instead.\n      instance.ssrRender = setupResult\n    } else {\n      instance.render = setupResult as InternalRenderFunction\n    }\n  } else if (isObject(setupResult)) {\n    if (__DEV__ && isVNode(setupResult)) {\n      warn(\n        `setup() should not return VNodes directly - ` +\n          `return a render function instead.`\n      )\n    }\n    // setup returned bindings.\n    // assuming a render function compiled from template is present.\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n      instance.devtoolsRawSetupState = setupResult\n    }\n    instance.setupState = proxyRefs(setupResult)\n    if (__DEV__) {\n      exposeSetupStateOnRenderContext(instance)\n    }\n  } else if (__DEV__ && setupResult !== undefined) {\n    warn(\n      `setup() should return an object. Received: ${\n        setupResult === null ? 'null' : typeof setupResult\n      }`\n    )\n  }\n  finishComponentSetup(instance, isSSR)\n}\n\ntype CompileFunction = (\n  template: string | object,\n  options?: CompilerOptions\n) => InternalRenderFunction\n\nlet compile: CompileFunction | undefined\nlet installWithProxy: (i: ComponentInternalInstance) => void\n\n/**\n * For runtime-dom to register the compiler.\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\n */\nexport function registerRuntimeCompiler(_compile: any) {\n  compile = _compile\n  installWithProxy = i => {\n    if (i.render!._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)\n    }\n  }\n}\n\n// dev only\nexport const isRuntimeOnly = () => !compile\n\nexport function finishComponentSetup(\n  instance: ComponentInternalInstance,\n  isSSR: boolean,\n  skipOptions?: boolean\n) {\n  const Component = instance.type as ComponentOptions\n\n  if (__COMPAT__) {\n    convertLegacyRenderFn(instance)\n\n    if (__DEV__ && Component.compatConfig) {\n      validateCompatConfig(Component.compatConfig)\n    }\n  }\n\n  // template / render function normalization\n  // could be already set when returned from setup()\n  if (!instance.render) {\n    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\n    // is done by server-renderer\n    if (!isSSR && compile && !Component.render) {\n      const template =\n        (__COMPAT__ &&\n          instance.vnode.props &&\n          instance.vnode.props['inline-template']) ||\n        Component.template\n      if (template) {\n        if (__DEV__) {\n          startMeasure(instance, `compile`)\n        }\n        const { isCustomElement, compilerOptions } = instance.appContext.config\n        const { delimiters, compilerOptions: componentCompilerOptions } =\n          Component\n        const finalCompilerOptions: CompilerOptions = extend(\n          extend(\n            {\n              isCustomElement,\n              delimiters\n            },\n            compilerOptions\n          ),\n          componentCompilerOptions\n        )\n        if (__COMPAT__) {\n          // pass runtime compat config into the compiler\n          finalCompilerOptions.compatConfig = Object.create(globalCompatConfig)\n          if (Component.compatConfig) {\n            // @ts-expect-error types are not compatible\n            extend(finalCompilerOptions.compatConfig, Component.compatConfig)\n          }\n        }\n        Component.render = compile(template, finalCompilerOptions)\n        if (__DEV__) {\n          endMeasure(instance, `compile`)\n        }\n      }\n    }\n\n    instance.render = (Component.render || NOOP) as InternalRenderFunction\n\n    // for runtime-compiled render functions using `with` blocks, the render\n    // proxy used needs a different `has` handler which is more performant and\n    // also only allows a whitelist of globals to fallthrough.\n    if (installWithProxy) {\n      installWithProxy(instance)\n    }\n  }\n\n  // support for 2.x options\n  if (__FEATURE_OPTIONS_API__ && !(__COMPAT__ && skipOptions)) {\n    setCurrentInstance(instance)\n    pauseTracking()\n    applyOptions(instance)\n    resetTracking()\n    unsetCurrentInstance()\n  }\n\n  // warn missing template/render\n  // the runtime compilation of template in SSR is done by server-render\n  if (__DEV__ && !Component.render && instance.render === NOOP && !isSSR) {\n    /* istanbul ignore if */\n    if (!compile && Component.template) {\n      warn(\n        `Component provided template option but ` +\n          `runtime compilation is not supported in this build of Vue.` +\n          (__ESM_BUNDLER__\n            ? ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\n            : __ESM_BROWSER__\n            ? ` Use \"vue.esm-browser.js\" instead.`\n            : __GLOBAL__\n            ? ` Use \"vue.global.js\" instead.`\n            : ``) /* should not happen */\n      )\n    } else {\n      warn(`Component is missing template or render function.`)\n    }\n  }\n}\n\nfunction createAttrsProxy(instance: ComponentInternalInstance): Data {\n  return new Proxy(\n    instance.attrs,\n    __DEV__\n      ? {\n          get(target, key: string) {\n            markAttrsAccessed()\n            track(instance, TrackOpTypes.GET, '$attrs')\n            return target[key]\n          },\n          set() {\n            warn(`setupContext.attrs is readonly.`)\n            return false\n          },\n          deleteProperty() {\n            warn(`setupContext.attrs is readonly.`)\n            return false\n          }\n        }\n      : {\n          get(target, key: string) {\n            track(instance, TrackOpTypes.GET, '$attrs')\n            return target[key]\n          }\n        }\n  )\n}\n\nexport function createSetupContext(\n  instance: ComponentInternalInstance\n): SetupContext {\n  const expose: SetupContext['expose'] = exposed => {\n    if (__DEV__ && instance.exposed) {\n      warn(`expose() should be called only once per setup().`)\n    }\n    instance.exposed = exposed || {}\n  }\n\n  let attrs: Data\n  if (__DEV__) {\n    // We use getters in dev in case libs like test-utils overwrite instance\n    // properties (overwrites should not be done in prod)\n    return Object.freeze({\n      get attrs() {\n        return attrs || (attrs = createAttrsProxy(instance))\n      },\n      get slots() {\n        return shallowReadonly(instance.slots)\n      },\n      get emit() {\n        return (event: string, ...args: any[]) => instance.emit(event, ...args)\n      },\n      expose\n    })\n  } else {\n    return {\n      get attrs() {\n        return attrs || (attrs = createAttrsProxy(instance))\n      },\n      slots: instance.slots,\n      emit: instance.emit,\n      expose\n    }\n  }\n}\n\nexport function getExposeProxy(instance: ComponentInternalInstance) {\n  if (instance.exposed) {\n    return (\n      instance.exposeProxy ||\n      (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\n        get(target, key: string) {\n          if (key in target) {\n            return target[key]\n          } else if (key in publicPropertiesMap) {\n            return publicPropertiesMap[key](instance)\n          }\n        }\n      }))\n    )\n  }\n}\n\nconst classifyRE = /(?:^|[-_])(\\w)/g\nconst classify = (str: string): string =>\n  str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '')\n\nexport function getComponentName(\n  Component: ConcreteComponent,\n  includeInferred = true\n): string | false | undefined {\n  return isFunction(Component)\n    ? Component.displayName || Component.name\n    : Component.name || (includeInferred && Component.__name)\n}\n\n/* istanbul ignore next */\nexport function formatComponentName(\n  instance: ComponentInternalInstance | null,\n  Component: ConcreteComponent,\n  isRoot = false\n): string {\n  let name = getComponentName(Component)\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/)\n    if (match) {\n      name = match[1]\n    }\n  }\n\n  if (!name && instance && instance.parent) {\n    // try to infer the name based on reverse resolution\n    const inferFromRegistry = (registry: Record<string, any> | undefined) => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key\n        }\n      }\n    }\n    name =\n      inferFromRegistry(\n        instance.components ||\n          (instance.parent.type as ComponentOptions).components\n      ) || inferFromRegistry(instance.appContext.components)\n  }\n\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`\n}\n\nexport function isClassComponent(value: unknown): value is ClassComponent {\n  return isFunction(value) && '__vccOpts' in value\n}\n","import { isArray, isString, isObject } from '@vue/shared'\nimport { warn } from '@vue/runtime-core'\n\nexport function ssrRenderList(\n  source: unknown,\n  renderItem: (value: unknown, key: string | number, index?: number) => void\n) {\n  if (isArray(source) || isString(source)) {\n    for (let i = 0, l = source.length; i < l; i++) {\n      renderItem(source[i], i)\n    }\n  } else if (typeof source === 'number') {\n    if (__DEV__ && !Number.isInteger(source)) {\n      warn(`The v-for range expect an integer value but got ${source}.`)\n      return\n    }\n    for (let i = 0; i < source; i++) {\n      renderItem(i + 1, i)\n    }\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator as any]) {\n      const arr = Array.from(source as Iterable<any>)\n      for (let i = 0, l = arr.length; i < l; i++) {\n        renderItem(arr[i], i)\n      }\n    } else {\n      const keys = Object.keys(source)\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i]\n        renderItem(source[key], key, i)\n      }\n    }\n  }\n}\n","import { PushFn } from '../render'\n\nexport async function ssrRenderSuspense(\n  push: PushFn,\n  { default: renderContent }: Record<string, (() => void) | undefined>\n) {\n  if (renderContent) {\n    renderContent()\n  } else {\n    push(`<!---->`)\n  }\n}\n","import { ComponentPublicInstance, Directive } from '@vue/runtime-core'\n\nexport function ssrGetDirectiveProps(\n  instance: ComponentPublicInstance,\n  dir: Directive,\n  value?: any,\n  arg?: string,\n  modifiers: Record<string, boolean> = {}\n): Record<string, any> {\n  if (typeof dir !== 'function' && dir.getSSRProps) {\n    return (\n      dir.getSSRProps(\n        {\n          dir,\n          instance,\n          value,\n          oldValue: undefined,\n          arg,\n          modifiers\n        },\n        null as any\n      ) || {}\n    )\n  }\n  return {}\n}\n","import { looseEqual, looseIndexOf, isArray } from '@vue/shared'\nimport { ssrRenderAttr } from './ssrRenderAttrs'\n\nexport const ssrLooseEqual = looseEqual as (a: unknown, b: unknown) => boolean\n\nexport function ssrLooseContain(arr: unknown[], value: unknown): boolean {\n  return looseIndexOf(arr, value) > -1\n}\n\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\nexport function ssrRenderDynamicModel(\n  type: unknown,\n  model: unknown,\n  value: unknown\n) {\n  switch (type) {\n    case 'radio':\n      return looseEqual(model, value) ? ' checked' : ''\n    case 'checkbox':\n      return (isArray(model) ? ssrLooseContain(model, value) : model)\n        ? ' checked'\n        : ''\n    default:\n      // text types\n      return ssrRenderAttr('value', model)\n  }\n}\n\n// for <input v-bind=\"obj\" v-model=\"model\">\nexport function ssrGetDynamicModelProps(\n  existingProps: any = {},\n  model: unknown\n) {\n  const { type, value } = existingProps\n  switch (type) {\n    case 'radio':\n      return looseEqual(model, value) ? { checked: true } : null\n    case 'checkbox':\n      return (isArray(model) ? ssrLooseContain(model, value) : model)\n        ? { checked: true }\n        : null\n    default:\n      // text types\n      return { value: model }\n  }\n}\n","import { initDirectivesForSSR } from 'vue'\ninitDirectivesForSSR()\n\n// public\nexport { SSRContext } from './render'\nexport { renderToString } from './renderToString'\nexport {\n  renderToSimpleStream,\n  renderToNodeStream,\n  pipeToNodeWritable,\n  renderToWebStream,\n  pipeToWebWritable,\n  SimpleReadable,\n  // deprecated\n  renderToStream\n} from './renderToStream'\n\n// internal runtime helpers\nexport { renderVNode as ssrRenderVNode } from './render'\nexport { ssrRenderComponent } from './helpers/ssrRenderComponent'\nexport { ssrRenderSlot, ssrRenderSlotInner } from './helpers/ssrRenderSlot'\nexport { ssrRenderTeleport } from './helpers/ssrRenderTeleport'\nexport {\n  ssrRenderClass,\n  ssrRenderStyle,\n  ssrRenderAttrs,\n  ssrRenderAttr,\n  ssrRenderDynamicAttr\n} from './helpers/ssrRenderAttrs'\nexport { ssrInterpolate } from './helpers/ssrInterpolate'\nexport { ssrRenderList } from './helpers/ssrRenderList'\nexport { ssrRenderSuspense } from './helpers/ssrRenderSuspense'\nexport { ssrGetDirectiveProps } from './helpers/ssrGetDirectiveProps'\nexport { includeBooleanAttr as ssrIncludeBooleanAttr } from '@vue/shared'\n\n// v-model helpers\nexport {\n  ssrLooseEqual,\n  ssrLooseContain,\n  ssrRenderDynamicModel,\n  ssrGetDynamicModelProps\n} from './helpers/ssrVModelHelpers'\n"],"names":["makeMap","isOn","propsToAttrMap","isBooleanAttr","includeBooleanAttr","isSSRSafeAttrName","escapeHtml","normalizeClass","isString","normalizeStyle","stringifyStyle","extend","NO","isFunction","generateCodeFrame","warn","compile","ssrContextKey","ssrUtils","isPromise","isArray","NOOP","Text","Comment","escapeHtmlComment","Static","Fragment","isVoidTag","mergeProps","createApp","createVNode","isVNode","unrollBuffer","unrollBufferSync","toDisplayString","isObject","looseEqual","looseIndexOf","initDirectivesForSSR"],"mappings":"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"}